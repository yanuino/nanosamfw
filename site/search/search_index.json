{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api/download.config/","title":"Package API <code>download.config</code>","text":""},{"location":"api/download.config/#download.config","title":"download.config","text":""},{"location":"api/download.db/","title":"Package API <code>download.db</code>","text":""},{"location":"api/download.db/#download.db","title":"download.db","text":""},{"location":"api/download.db/#download.db.connect","title":"connect","text":"<pre><code>connect()\n</code></pre> <p>Ouvre une connexion SQLite avec PRAGMAs adapt\u00e9s (WAL, timeouts). Une connexion par thread/process est recommand\u00e9e.</p> Source code in <code>download/db.py</code> <pre><code>def connect() -&gt; sqlite3.Connection:\n    \"\"\"\n    Ouvre une connexion SQLite avec PRAGMAs adapt\u00e9s (WAL, timeouts).\n    Une connexion par thread/process est recommand\u00e9e.\n    \"\"\"\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    conn = sqlite3.connect(\n        PATHS.db_path,\n        timeout=10.0,\n        isolation_level=None,  # autocommit, on g\u00e8re avec BEGIN\n        check_same_thread=False,  # si tu partages via pool (sinon, open/close par op\u00e9ration)\n    )\n    conn.row_factory = sqlite3.Row\n    _apply_pragmas(conn)\n    return conn\n</code></pre>"},{"location":"api/download.db/#download.db.repair_db","title":"repair_db","text":"<pre><code>repair_db()\n</code></pre> <p>Tente de r\u00e9parer la base de donn\u00e9es SQLite corrompue en effectuant un dump et un restore dans une nouvelle base de donn\u00e9es.</p> Source code in <code>download/db.py</code> <pre><code>def repair_db() -&gt; None:\n    \"\"\"\n    Tente de r\u00e9parer la base de donn\u00e9es SQLite corrompue en effectuant un dump\n    et un restore dans une nouvelle base de donn\u00e9es.\n    \"\"\"\n    if is_healthy():\n        return\n\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    temp_dump_path = PATHS.data_dir / \"temp_dump.sql\"\n    _dump_db(temp_dump_path)\n    # Supprimer l'ancienne base corrompue\n    try:\n        PATHS.db_path.unlink()\n    except FileNotFoundError:\n        pass\n    # Restaurer depuis le dump\n    _restore_db(temp_dump_path)\n    # Supprimer le dump temporaire\n    try:\n        temp_dump_path.unlink()\n    except FileNotFoundError:\n        pass\n</code></pre>"},{"location":"api/download.imei_repository/","title":"Package API <code>download.imei_repository</code>","text":""},{"location":"api/download.imei_repository/#download.imei_repository","title":"download.imei_repository","text":""},{"location":"api/download.imei_repository/#download.imei_repository.add_imei_event","title":"add_imei_event","text":"<pre><code>add_imei_event(\n    *,\n    imei,\n    model,\n    csc,\n    version_code,\n    status_fus=\"ok\",\n    status_upgrade=\"unknown\",\n    upgrade_at=None\n)\n</code></pre> <p>Ins\u00e8re un \u00e9v\u00e9nement IMEI. Aucune contrainte d'unicit\u00e9 : on garde tout pour la tra\u00e7abilit\u00e9. Retourne l'id autoincr\u00e9ment\u00e9.</p> Source code in <code>download/imei_repository.py</code> <pre><code>def add_imei_event(\n    *,\n    imei: str,\n    model: str,\n    csc: str,\n    version_code: str,\n    status_fus: str = \"ok\",\n    status_upgrade: str = \"unknown\",\n    upgrade_at: str | None = None,\n) -&gt; int:\n    \"\"\"\n    Ins\u00e8re un \u00e9v\u00e9nement IMEI. Aucune contrainte d'unicit\u00e9 : on garde tout pour la tra\u00e7abilit\u00e9.\n    Retourne l'id autoincr\u00e9ment\u00e9.\n    \"\"\"\n    sql = \"\"\"\n    INSERT INTO imei_log\n        (imei, model, csc, version_code, status_fus, status_upgrade, created_at, upgrade_at)\n    VALUES\n        (:imei, :model, :csc, :version_code, :status_fus, :status_upgrade, :created_at, :upgrade_at);\n    \"\"\"\n    params = {\n        \"imei\": imei,\n        \"model\": model,\n        \"csc\": csc,\n        \"version_code\": version_code,\n        \"status_fus\": status_fus,\n        \"status_upgrade\": status_upgrade,\n        \"created_at\": _iso_now(),\n        \"upgrade_at\": upgrade_at,\n    }\n    with connect() as conn:\n        cur = conn.execute(sql, params)\n        return int(cur.lastrowid)  # type: ignore\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.set_upgrade_status","title":"set_upgrade_status","text":"<pre><code>set_upgrade_status(id_, status_upgrade, upgrade_at=None)\n</code></pre> <p>Met \u00e0 jour le statut d'upgrade pour un \u00e9v\u00e9nement existant (ex. ok/failed/skipped).</p> Source code in <code>download/imei_repository.py</code> <pre><code>def set_upgrade_status(id_: int, status_upgrade: str, upgrade_at: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Met \u00e0 jour le statut d'upgrade pour un \u00e9v\u00e9nement existant (ex. ok/failed/skipped).\n    \"\"\"\n    if upgrade_at is None:\n        upgrade_at = _iso_now()\n    sql = \"\"\"\n    UPDATE imei_log\n       SET status_upgrade = :status_upgrade,\n           upgrade_at = :upgrade_at\n     WHERE id = :id\n    \"\"\"\n    with connect() as conn:\n        conn.execute(sql, {\"status_upgrade\": status_upgrade, \"upgrade_at\": upgrade_at, \"id\": id_})\n</code></pre>"},{"location":"api/download.repository/","title":"Package API <code>download.repository</code>","text":""},{"location":"api/download.repository/#download.repository","title":"download.repository","text":""},{"location":"api/download.service/","title":"Package API <code>download.service</code>","text":""},{"location":"api/download.service/#download.service","title":"download.service","text":""},{"location":"api/download.service/#download.service.download_firmware","title":"download_firmware","text":"<pre><code>download_firmware(\n    *,\n    model,\n    csc,\n    device_id,\n    version=None,\n    decrypt=True,\n    resume=True,\n    progress_cb=None\n)\n</code></pre> <p>T\u00e9l\u00e9charge (et \u00e9ventuellement d\u00e9chiffre) un firmware puis persiste les m\u00e9tadonn\u00e9es en BDD. Flux:   1) R\u00e9solution version (si None) via FOTA version.xml   2) INFORM  -&gt; parse filename (+ size)   3) INIT    -&gt; LOGIC_CHECK calcul\u00e9 \u00e0 partir du nom de fichier (16 derniers chars du base-name)   4) DOWNLOAD (Range + .part)   5) (Optionnel) DECRYPT ENC4   6) UPSERT en base (model, csc, ver 4-part, encoded_filename, size, path)</p> Source code in <code>download/service.py</code> <pre><code>def download_firmware(\n    *,\n    model: str,\n    csc: str,\n    device_id: str,\n    version: Optional[str] = None,\n    decrypt: bool = True,\n    resume: bool = True,\n    progress_cb: Optional[Callable[[int, Optional[int]], None]] = None,\n) -&gt; DownloadRecord:\n    \"\"\"\n    T\u00e9l\u00e9charge (et \u00e9ventuellement d\u00e9chiffre) un firmware puis persiste les m\u00e9tadonn\u00e9es en BDD.\n    Flux:\n      1) R\u00e9solution version (si None) via FOTA version.xml\n      2) INFORM  -&gt; parse filename (+ size)\n      3) INIT    -&gt; LOGIC_CHECK calcul\u00e9 \u00e0 partir du nom de fichier (16 derniers chars du base-name)\n      4) DOWNLOAD (Range + .part)\n      5) (Optionnel) DECRYPT ENC4\n      6) UPSERT en base (model, csc, ver 4-part, encoded_filename, size, path)\n    \"\"\"\n    # 1) Version (4-part)\n    if not version:\n        version = get_latest_version(model, csc)  # peut lever FUSError si 403 / pas de version\n    version_norm = normalize_vercode(version)\n\n    # Dossier de sortie (par model/CSC)\n    out_dir = _safe_dir(model, csc)\n\n    # 2) INFORM\n    client = FUSClient()\n    inform_payload = build_binary_inform(version_norm, model, csc, device_id, client.nonce)\n    inform_root = client.inform(inform_payload)\n\n    filename, expected_size = _extract_filename_and_size(inform_root)\n\n    # 3) INIT (LOGIC_CHECK calcul\u00e9 c\u00f4t\u00e9 client \u2014 conforme \u00e0 GNSF d'origine)\n    init_payload = build_binary_init(filename, client.nonce)\n    client.init(init_payload)\n\n    # 4) DOWNLOAD binaire enc4 (fichier \"encoded_filename\")\n    enc_path = out_dir / filename\n    enc_final = _download_to_file(\n        client=client,\n        filename=filename,\n        out_path=enc_path,\n        expected_size=expected_size,\n        resume=resume,\n        progress_cb=progress_cb,\n    )\n\n    # 5) (Optionnel) DECRYPT ENC4 -&gt; ZIP\n    dec_path: Optional[Path] = None\n    if decrypt:\n        key = get_v4_key(version_norm, model, csc, device_id, client)\n        dec_path = enc_final.with_suffix(\"\")  # retire .enc4 -&gt; .zip (ou autre suffixe r\u00e9el)\n        decrypt_file(\n            str(enc_final),\n            str(dec_path),\n            enc_ver=4,\n            key=key,  # type: ignore\n            progress_cb=progress_cb,\n        )\n\n    # 6) UPSERT BDD\n    size_bytes = enc_final.stat().st_size if enc_final.exists() else None\n    preferred_path = dec_path if dec_path else enc_final\n\n    rec = DownloadRecord(\n        model=model,\n        csc=csc,\n        version_code=version_norm,\n        encoded_filename=filename,\n        size_bytes=size_bytes,\n        status=\"done\",\n        path=str(preferred_path.resolve()),\n    )\n    upsert_download(rec)\n    return rec\n</code></pre>"},{"location":"api/fus.client/","title":"Package API <code>fus.client</code>","text":""},{"location":"api/fus.client/#fus.client","title":"fus.client","text":""},{"location":"api/fus.client/#fus.client.FUSClient","title":"FUSClient","text":"<p>Samsung Firmware Update Service (FUS) client implementation.</p> <p>Handles core FUS protocol operations including NONCE rotation, signature generation, and session management.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>FUSConfig</code> <p>FUS configuration settings. Defaults to DEFAULT_CONFIG.</p> <code>DEFAULT_CONFIG</code> <code>session</code> <code>Optional[Session]</code> <p>Optional requests.Session for connection reuse.</p> <code>None</code> Source code in <code>fus/client.py</code> <pre><code>class FUSClient:\n    \"\"\"\n    Samsung Firmware Update Service (FUS) client implementation.\n\n    Handles core FUS protocol operations including NONCE rotation,\n    signature generation, and session management.\n\n    Args:\n        cfg: FUS configuration settings. Defaults to DEFAULT_CONFIG.\n        session: Optional requests.Session for connection reuse.\n    \"\"\"\n\n    def __init__(self, cfg: FUSConfig = DEFAULT_CONFIG, session: Optional[requests.Session] = None):\n        self.cfg = cfg\n        self.sess = session or requests.Session()\n        self._auth = \"\"\n        self._sessid = \"\"\n        self._enc_nonce = \"\"\n        self.nonce = \"\"\n        # bootstrap: r\u00e9cup\u00e9rer un NONCE\n        self._makereq(\"NF_DownloadGenerateNonce.do\")\n\n    def _headers(self, with_server_nonce: bool = False) -&gt; dict:\n        \"\"\"\n        Build request headers including Authorization and User-Agent.\n\n        Args:\n            with_server_nonce: Whether to include encrypted NONCE in Authorization.\n\n        Returns:\n            dict: Headers dictionary for FUS requests.\n        \"\"\"\n        nonce = self._enc_nonce if with_server_nonce else \"\"\n        authv = (\n            f'FUS nonce=\"{nonce}\", signature=\"{self._auth}\", nc=\"\", type=\"\", realm=\"\", newauth=\"1\"'\n        )\n        return {\"Authorization\": authv, \"User-Agent\": self.cfg.user_agent}\n\n    def _makereq(self, path: str, data: bytes | str = b\"\") -&gt; str:\n        \"\"\"\n        Make an authenticated request to FUS server with NONCE rotation.\n\n        Args:\n            path: API endpoint path.\n            data: Request payload (XML or bytes).\n\n        Returns:\n            str: Response text from server.\n\n        Raises:\n            requests.exceptions.HTTPError: On non-200 response.\n        \"\"\"\n        url = f\"{self.cfg.base_url}/{path}\"\n        r = self.sess.post(\n            url,\n            data=data,\n            headers=self._headers(),\n            timeout=self.cfg.request_timeout,\n            cookies={\"JSESSIONID\": self._sessid},\n        )\n        # rotation de nonce + signature\n        if \"NONCE\" in r.headers:\n            self._enc_nonce = r.headers[\"NONCE\"]\n            self.nonce = decrypt_nonce(self._enc_nonce)\n            self._auth = make_signature(self.nonce)\n        if \"JSESSIONID\" in r.cookies:\n            self._sessid = r.cookies[\"JSESSIONID\"]\n        r.raise_for_status()\n        return r.text\n\n    def inform(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Send inform request to get firmware information.\n\n        Args:\n            payload: XML payload containing device and firmware details.\n\n        Returns:\n            ET.Element: Parsed XML response containing firmware metadata.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n        return ET.fromstring(xml)\n\n    def init(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Initialize binary download session.\n\n        Args:\n            payload: XML payload with download request details.\n\n        Returns:\n            ET.Element: Parsed XML response with download authorization.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n        return ET.fromstring(xml)\n\n    def stream(self, filename: str, start: int = 0):\n        \"\"\"\n        Stream firmware download from cloud server.\n\n        Args:\n            filename: Remote firmware file path.\n            start: Byte offset for resume capability.\n\n        Returns:\n            requests.Response: Streaming response object.\n\n        Raises:\n            DownloadError: On download initialization failure.\n        \"\"\"\n        # cloud download (transmits client-side encrypted NONCE)\n        url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n        headers = self._headers(with_server_nonce=True)\n        if start &gt; 0:\n            headers[\"Range\"] = f\"bytes={start}-\"\n        r = self.sess.get(\n            url,\n            params=\"file=\" + filename,\n            headers=headers,\n            stream=True,\n            timeout=self.cfg.request_timeout,\n        )\n        if not r.ok:\n            raise DownloadError(f\"HTTP {r.status_code} on download\")\n        return r\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.inform","title":"inform","text":"<pre><code>inform(payload)\n</code></pre> <p>Send inform request to get firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload containing device and firmware details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response containing firmware metadata.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus/client.py</code> <pre><code>def inform(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Send inform request to get firmware information.\n\n    Args:\n        payload: XML payload containing device and firmware details.\n\n    Returns:\n        ET.Element: Parsed XML response containing firmware metadata.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.init","title":"init","text":"<pre><code>init(payload)\n</code></pre> <p>Initialize binary download session.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload with download request details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response with download authorization.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus/client.py</code> <pre><code>def init(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Initialize binary download session.\n\n    Args:\n        payload: XML payload with download request details.\n\n    Returns:\n        ET.Element: Parsed XML response with download authorization.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.stream","title":"stream","text":"<pre><code>stream(filename, start=0)\n</code></pre> <p>Stream firmware download from cloud server.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Remote firmware file path.</p> required <code>start</code> <code>int</code> <p>Byte offset for resume capability.</p> <code>0</code> <p>Returns:</p> Type Description <p>requests.Response: Streaming response object.</p> <p>Raises:</p> Type Description <code>DownloadError</code> <p>On download initialization failure.</p> Source code in <code>fus/client.py</code> <pre><code>def stream(self, filename: str, start: int = 0):\n    \"\"\"\n    Stream firmware download from cloud server.\n\n    Args:\n        filename: Remote firmware file path.\n        start: Byte offset for resume capability.\n\n    Returns:\n        requests.Response: Streaming response object.\n\n    Raises:\n        DownloadError: On download initialization failure.\n    \"\"\"\n    # cloud download (transmits client-side encrypted NONCE)\n    url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n    headers = self._headers(with_server_nonce=True)\n    if start &gt; 0:\n        headers[\"Range\"] = f\"bytes={start}-\"\n    r = self.sess.get(\n        url,\n        params=\"file=\" + filename,\n        headers=headers,\n        stream=True,\n        timeout=self.cfg.request_timeout,\n    )\n    if not r.ok:\n        raise DownloadError(f\"HTTP {r.status_code} on download\")\n    return r\n</code></pre>"},{"location":"api/fus.config/","title":"Package API <code>fus.config</code>","text":""},{"location":"api/fus.config/#fus.config","title":"fus.config","text":"<p>FUS configuration helpers.</p> <p>This module defines the FUSConfig dataclass which centralizes default endpoints and HTTP settings used by the FUS client.</p>"},{"location":"api/fus.config/#fus.config.FUSConfig","title":"FUSConfig  <code>dataclass</code>","text":"<p>Configuration for the Firmware Update Service (FUS) client.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for FUS control endpoints. Some clients/tools may use a different host.</p> <code>'https://neofussvr.sslcs.cdngc.net'</code> <code>cloud_url</code> <code>str</code> <p>Primary cloud URL used for firmware downloads.</p> <code>'http://cloud-neofussvr.samsungmobile.com'</code> <code>old_cloud_url</code> <code>str</code> <p>Legacy cloud URL kept for compatibility.</p> <code>'http://cloud-fussvr.sslcs.cdngc.net'</code> <code>user_agent</code> <code>str</code> <p>User-Agent header used for HTTP requests.</p> <code>'Kies2.0_FUS'</code> <code>request_timeout</code> <code>int</code> <p>Default timeout in seconds for HTTP requests.</p> <code>60</code> Source code in <code>fus/config.py</code> <pre><code>@dataclass(frozen=True)\nclass FUSConfig:\n    \"\"\"\n    Configuration for the Firmware Update Service (FUS) client.\n\n    Args:\n        base_url: Base URL for FUS control endpoints. Some clients/tools may use a different host.\n        cloud_url: Primary cloud URL used for firmware downloads.\n        old_cloud_url: Legacy cloud URL kept for compatibility.\n        user_agent: User-Agent header used for HTTP requests.\n        request_timeout: Default timeout in seconds for HTTP requests.\n    \"\"\"\n\n    # Endpoints (some clients/tools may use a different cloud host)\n    base_url: str = \"https://neofussvr.sslcs.cdngc.net\"\n    cloud_url: str = \"http://cloud-neofussvr.samsungmobile.com\"\n    old_cloud_url: str = \"http://cloud-fussvr.sslcs.cdngc.net\"\n    # Default User-Agent and timeout for HTTP requests\n    user_agent: str = \"Kies2.0_FUS\"\n    request_timeout: int = 60  # seconds\n</code></pre>"},{"location":"api/fus.crypto/","title":"Package API <code>fus.crypto</code>","text":""},{"location":"api/fus.crypto/#fus.crypto","title":"fus.crypto","text":"<p>FUS crypto helpers: AES CBC utilities, padding, key derivation and logic checks.</p> <p>Provides small helpers used by the FUS client and decryption routines.</p>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_pad","title":"pkcs_pad","text":"<pre><code>pkcs_pad(data)\n</code></pre> <p>Apply PKCS#7 padding to reach a 16-byte boundary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw bytes to pad.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Padded bytes.</p> Source code in <code>fus/crypto.py</code> <pre><code>def pkcs_pad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Apply PKCS#7 padding to reach a 16-byte boundary.\n\n    Args:\n        data: Raw bytes to pad.\n\n    Returns:\n        Padded bytes.\n    \"\"\"\n    pad_len = 16 - (len(data) % 16)\n    return data + bytes([pad_len]) * pad_len\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_unpad","title":"pkcs_unpad","text":"<pre><code>pkcs_unpad(data)\n</code></pre> <p>Remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Padded bytes.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Original unpadded bytes.</p> Source code in <code>fus/crypto.py</code> <pre><code>def pkcs_unpad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Remove PKCS#7 padding.\n\n    Args:\n        data: Padded bytes.\n\n    Returns:\n        Original unpadded bytes.\n    \"\"\"\n    return data[: -data[-1]]\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_encrypt","title":"aes_cbc_encrypt","text":"<pre><code>aes_cbc_encrypt(inp, key)\n</code></pre> <p>Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Plaintext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key (16/24/32 bytes).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Ciphertext bytes.</p> Source code in <code>fus/crypto.py</code> <pre><code>def aes_cbc_encrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.\n\n    Args:\n        inp: Plaintext bytes.\n        key: AES key (16/24/32 bytes).\n\n    Returns:\n        Ciphertext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return cipher.encrypt(pkcs_pad(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_decrypt","title":"aes_cbc_decrypt","text":"<pre><code>aes_cbc_decrypt(inp, key)\n</code></pre> <p>Decrypt AES-CBC ciphertext and remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Ciphertext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key used to encrypt.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Plaintext bytes.</p> Source code in <code>fus/crypto.py</code> <pre><code>def aes_cbc_decrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt AES-CBC ciphertext and remove PKCS#7 padding.\n\n    Args:\n        inp: Ciphertext bytes.\n        key: AES key used to encrypt.\n\n    Returns:\n        Plaintext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return pkcs_unpad(cipher.decrypt(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.derive_key","title":"derive_key","text":"<pre><code>derive_key(nonce)\n</code></pre> <p>Build a key from a 16-character server nonce.</p> <p>The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars, concatenated with KEY_2, returned as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>16-character nonce string.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Derived key bytes.</p> Source code in <code>fus/crypto.py</code> <pre><code>def derive_key(nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a key from a 16-character server nonce.\n\n    The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars,\n    concatenated with KEY_2, returned as bytes.\n\n    Args:\n        nonce: 16-character nonce string.\n\n    Returns:\n        Derived key bytes.\n    \"\"\"\n    k = \"\".join(KEY_1[ord(nonce[i]) % 16] for i in range(16))\n    k += KEY_2\n    return k.encode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.make_signature","title":"make_signature","text":"<pre><code>make_signature(nonce)\n</code></pre> <p>Compute the base64-encoded signature for a nonce.</p> <p>The signature is base64(AES-CBC(nonce, derive_key(nonce))).</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>Plaintext nonce.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base64-encoded signature string.</p> Source code in <code>fus/crypto.py</code> <pre><code>def make_signature(nonce: str) -&gt; str:\n    \"\"\"\n    Compute the base64-encoded signature for a nonce.\n\n    The signature is base64(AES-CBC(nonce, derive_key(nonce))).\n\n    Args:\n        nonce: Plaintext nonce.\n\n    Returns:\n        Base64-encoded signature string.\n    \"\"\"\n    raw = aes_cbc_encrypt(nonce.encode(), derive_key(nonce))\n    return base64.b64encode(raw).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.decrypt_nonce","title":"decrypt_nonce","text":"<pre><code>decrypt_nonce(enc_nonce)\n</code></pre> <p>Decrypt a server NONCE header.</p> <p>Parameters:</p> Name Type Description Default <code>enc_nonce</code> <code>str</code> <p>Base64-encoded ciphertext from server.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Decrypted plaintext nonce.</p> Source code in <code>fus/crypto.py</code> <pre><code>def decrypt_nonce(enc_nonce: str) -&gt; str:\n    \"\"\"\n    Decrypt a server NONCE header.\n\n    Args:\n        enc_nonce: Base64-encoded ciphertext from server.\n\n    Returns:\n        Decrypted plaintext nonce.\n\n    Raises:\n        (propagates base64 and AES decode errors if malformed)\n    \"\"\"\n    data = base64.b64decode(enc_nonce)\n    return aes_cbc_decrypt(data, KEY_1.encode()).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.logic_check","title":"logic_check","text":"<pre><code>logic_check(inp, nonce)\n</code></pre> <p>Compute the FUS logic-check value.</p> <p>Picks characters from <code>inp</code> using the low 4 bits of each character in <code>nonce</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Input string (must be at least 16 characters).</p> required <code>nonce</code> <code>str</code> <p>Server nonce string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Computed logic-check string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>inp</code> is shorter than 16 characters.</p> Source code in <code>fus/crypto.py</code> <pre><code>def logic_check(inp: str, nonce: str) -&gt; str:\n    \"\"\"\n    Compute the FUS logic-check value.\n\n    Picks characters from `inp` using the low 4 bits of each character in `nonce`.\n\n    Args:\n        inp: Input string (must be at least 16 characters).\n        nonce: Server nonce string.\n\n    Returns:\n        Computed logic-check string.\n\n    Raises:\n        ValueError: If `inp` is shorter than 16 characters.\n    \"\"\"\n    if len(inp) &lt; 16:\n        raise ValueError(\"logic_check input too short\")\n    return \"\".join(inp[ord(c) &amp; 0xF] for c in nonce)\n</code></pre>"},{"location":"api/fus.csclist/","title":"Package API <code>fus.csclist</code>","text":""},{"location":"api/fus.csclist/#fus.csclist","title":"fus.csclist","text":"<p>CSC mapping for Samsung firmware regions.</p> <p>This module provides CSC_DICT, a dictionary that maps 3-letter Samsung CSC codes to their corresponding country or region names. It is used by the CLI and GUI components to display or validate CSC/region information.</p> <p>Attributes:</p> Name Type Description <code>CSC_DICT</code> <code>dict</code> <p>Mapping of 3-letter CSC codes to region/country names.</p>"},{"location":"api/fus.decrypt/","title":"Package API <code>fus.decrypt</code>","text":""},{"location":"api/fus.decrypt/#fus.decrypt","title":"fus.decrypt","text":"<p>FUS decryption helpers.</p> <p>Provides functions to derive ENC2/ENC4 keys and to decrypt streaming firmware blobs.</p> <p>Functions: - get_v2_key: derive MD5-based ENC2 key. - get_v4_key: retrieve logic value via FUS inform and derive ENC4 key. - decrypt_file: decrypt a file encrypting in 16-byte AES blocks.</p>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v2_key","title":"get_v2_key","text":"<pre><code>get_v2_key(version, model, region, _device_id)\n</code></pre> <p>Derive ENC2 key (V2) using MD5.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>_device_id</code> <code>str</code> <p>Unused for V2 (kept for API parity).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>MD5 digest bytes of the string \"region:model:version\".</p> Source code in <code>fus/decrypt.py</code> <pre><code>def get_v2_key(version: str, model: str, region: str, _device_id: str) -&gt; bytes:\n    \"\"\"\n    Derive ENC2 key (V2) using MD5.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        _device_id: Unused for V2 (kept for API parity).\n\n    Returns:\n        MD5 digest bytes of the string \"region:model:version\".\n    \"\"\"\n    deckey = f\"{region}:{model}:{version}\"\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v4_key","title":"get_v4_key","text":"<pre><code>get_v4_key(version, model, region, device_id, client=None)\n</code></pre> <p>Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>device_id</code> <code>str</code> <p>IMEI or Serial required by Samsung for ENC4.</p> required <code>client</code> <code>FUSClient | None</code> <p>Optional FUSClient instance to use (a new one is created if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>MD5 digest bytes derived from the logic-check value, or None on failure.</p> <p>Raises:</p> Type Description <code>DecryptError</code> <p>If device_id is not provided.</p> <code>InformError</code> <p>If the inform response lacks expected fields.</p> Source code in <code>fus/decrypt.py</code> <pre><code>def get_v4_key(\n    version: str, model: str, region: str, device_id: str, client: FUSClient | None = None\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        device_id: IMEI or Serial required by Samsung for ENC4.\n        client: Optional FUSClient instance to use (a new one is created if None).\n\n    Returns:\n        MD5 digest bytes derived from the logic-check value, or None on failure.\n\n    Raises:\n        DecryptError: If device_id is not provided.\n        InformError: If the inform response lacks expected fields.\n    \"\"\"\n    if not device_id:\n        raise DecryptError(\n            \"Device ID (IMEI or Serial) required for ENC4 key (Samsung requirement).\"\n        )\n    client = client or FUSClient()\n    ver = normalize_vercode(version)\n    resp = client.inform(build_binary_inform(ver, model, region, device_id, client.nonce))\n    try:\n        fwver = resp.find(\"./FUSBody/Results/LATEST_FW_VERSION/Data\").text  # type: ignore\n        logicval = resp.find(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\").text  # type: ignore\n    except Exception as exc:\n        raise InformError(\"Could not obtain decryption key; check model/region/device_id.\") from exc\n    deckey = logic_check(fwver, logicval)  # type: ignore\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.decrypt_file","title":"decrypt_file","text":"<pre><code>decrypt_file(\n    enc_path, out_path, *, enc_ver, key, progress_cb=None\n)\n</code></pre> <p>Decrypt an encrypted firmware file to disk.</p> <p>Parameters:</p> Name Type Description Default <code>enc_path</code> <code>str</code> <p>Path to the encrypted input file.</p> required <code>out_path</code> <code>str</code> <p>Path to write the decrypted output file.</p> required <code>enc_ver</code> <code>int</code> <p>Encryption version (unused by this function but kept for API parity).</p> required <code>key</code> <code>bytes</code> <p>AES key used for decryption.</p> required <code>progress_cb</code> <p>Optional progress callback(progress_bytes, total_bytes).</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>fus/decrypt.py</code> <pre><code>def decrypt_file(\n    enc_path: str, out_path: str, *, enc_ver: int, key: bytes, progress_cb=None\n) -&gt; None:\n    \"\"\"\n    Decrypt an encrypted firmware file to disk.\n\n    Args:\n        enc_path: Path to the encrypted input file.\n        out_path: Path to write the decrypted output file.\n        enc_ver: Encryption version (unused by this function but kept for API parity).\n        key: AES key used for decryption.\n        progress_cb: Optional progress callback(progress_bytes, total_bytes).\n\n    Returns:\n        None\n    \"\"\"\n    size = os.stat(enc_path).st_size\n    with open(enc_path, \"rb\") as fin, open(out_path, \"wb\") as fout:\n        _decrypt_progress(fin, fout, key, size, progress_cb=progress_cb)\n</code></pre>"},{"location":"api/fus.deviceid/","title":"Package API <code>fus.deviceid</code>","text":""},{"location":"api/fus.deviceid/#fus.deviceid","title":"fus.deviceid","text":"<p>Device identifier helpers for FUS interactions.</p> <p>Provides IMEI Luhn checksum computation, TAC-based IMEI autofill, and validation helpers for serial numbers and IMEIs.</p> <p>Functions: - luhn_checksum: compute Luhn check digit for a 14-digit IMEI core. - autofill_imei: complete a TAC to a full 15-digit IMEI (random fill + Luhn). - validate_serial: basic alphanumeric serial validation. - validate_imei: full 15-digit IMEI validation using Luhn. - is_device_id_required: policy for when a device id is required by commands.</p>"},{"location":"api/fus.deviceid/#fus.deviceid.luhn_checksum","title":"luhn_checksum","text":"<pre><code>luhn_checksum(imei_without_cd)\n</code></pre> <p>Compute the Luhn check digit for the provided IMEI core.</p> <p>Parameters:</p> Name Type Description Default <code>imei_without_cd</code> <code>str</code> <p>IMEI digits excluding the check digit (typically 14 digits).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The single-digit Luhn checksum as an int.</p> Source code in <code>fus/deviceid.py</code> <pre><code>def luhn_checksum(imei_without_cd: str) -&gt; int:\n    \"\"\"\n    Compute the Luhn check digit for the provided IMEI core.\n\n    Args:\n        imei_without_cd: IMEI digits excluding the check digit (typically 14 digits).\n\n    Returns:\n        The single-digit Luhn checksum as an int.\n    \"\"\"\n    s, tmp = 0, imei_without_cd + \"0\"\n    parity = len(tmp) % 2\n    for idx, ch in enumerate(tmp):\n        d = int(ch)\n        if idx % 2 == parity:\n            d *= 2\n            if d &gt; 9:\n                d -= 9\n        s += d\n    return (10 - (s % 10)) % 10\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.autofill_imei","title":"autofill_imei","text":"<pre><code>autofill_imei(tac)\n</code></pre> <p>Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.</p> <p>Parameters:</p> Name Type Description Default <code>tac</code> <code>str</code> <p>TAC prefix (must be numeric and at least 8 digits).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A 15-digit IMEI string.</p> <p>Raises:</p> Type Description <code>DeviceIdError</code> <p>If TAC is not numeric or shorter than 8 digits.</p> Source code in <code>fus/deviceid.py</code> <pre><code>def autofill_imei(tac: str) -&gt; str:\n    \"\"\"\n    Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.\n\n    Args:\n        tac: TAC prefix (must be numeric and at least 8 digits).\n\n    Returns:\n        A 15-digit IMEI string.\n\n    Raises:\n        DeviceIdError: If TAC is not numeric or shorter than 8 digits.\n    \"\"\"\n    if not tac.isdecimal() or len(tac) &lt; 8:\n        raise DeviceIdError(\"TAC must have at least 8 digits\")\n    if len(tac) &gt;= 15:\n        return tac[:15]\n    missing = 14 - len(tac)\n    rnd = f\"{random.randint(0, 10**missing - 1):0{missing}d}\"\n    core = tac + rnd\n    return core + str(luhn_checksum(core))\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_serial","title":"validate_serial","text":"<pre><code>validate_serial(serial)\n</code></pre> <p>Validate a device serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str</code> <p>Serial string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if serial is non-empty, alphanumeric and length between 1 and 35.</p> Source code in <code>fus/deviceid.py</code> <pre><code>def validate_serial(serial: str) -&gt; bool:\n    \"\"\"\n    Validate a device serial number.\n\n    Args:\n        serial: Serial string to validate.\n\n    Returns:\n        True if serial is non-empty, alphanumeric and length between 1 and 35.\n    \"\"\"\n    return bool(serial) and (1 &lt;= len(serial) &lt;= 35) and serial.isalnum()\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_imei","title":"validate_imei","text":"<pre><code>validate_imei(imei)\n</code></pre> <p>Validate a full 15-digit IMEI using the Luhn checksum.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>IMEI string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.</p> Source code in <code>fus/deviceid.py</code> <pre><code>def validate_imei(imei: str) -&gt; bool:\n    \"\"\"\n    Validate a full 15-digit IMEI using the Luhn checksum.\n\n    Args:\n        imei: IMEI string to validate.\n\n    Returns:\n        True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.\n    \"\"\"\n    if not imei or not imei.isdecimal():\n        return False\n    if len(imei) != 15:\n        return False\n    try:\n        check_digit = int(imei[14])\n    except ValueError:\n        return False\n    return luhn_checksum(imei[:14]) == check_digit\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.is_device_id_required","title":"is_device_id_required","text":"<pre><code>is_device_id_required(command, enc_ver)\n</code></pre> <p>Policy deciding whether a device id is required for an operation.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name (e.g. \"download\", \"decrypt\").</p> required <code>enc_ver</code> <code>int | None</code> <p>Encryption version (None if unknown).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the command requires a device id (download always, decrypt only for ENC4).</p> Source code in <code>fus/deviceid.py</code> <pre><code>def is_device_id_required(command: str, enc_ver: int | None) -&gt; bool:\n    \"\"\"\n    Policy deciding whether a device id is required for an operation.\n\n    Args:\n        command: Command name (e.g. \"download\", \"decrypt\").\n        enc_ver: Encryption version (None if unknown).\n\n    Returns:\n        True if the command requires a device id (download always, decrypt only for ENC4).\n    \"\"\"\n    return command == \"download\" or (command == \"decrypt\" and enc_ver == 4)\n</code></pre>"},{"location":"api/fus.errors/","title":"Package API <code>fus.errors</code>","text":""},{"location":"api/fus.errors/#fus.errors","title":"fus.errors","text":"<p>FUS package error definitions.</p> <p>This module defines custom exceptions used across the FUS package. In particular, DeviceIdError is raised by the device identifier utilities (e.g. IMEI/TAC validation and autofill) when provided input is invalid.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>Base class for FUS-related errors.</p> <code>DeviceIdError</code> <p>Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.</p>"},{"location":"api/fus.firmware/","title":"Package API <code>fus.firmware</code>","text":""},{"location":"api/fus.firmware/#fus.firmware","title":"fus.firmware","text":"<p>Firmware parsing and FOTA helpers for Samsung FUS.</p> <p>Provides utilities to normalize firmware version codes, parse PDA strings into meaningful fields (bootloader type, year, month, iteration), format human-readable info and fetch the latest firmware version from the FOTA endpoint.</p> <p>Functions: - normalize_vercode: Normalize a version code to a 4-part representation. - _read_firmware: Extract structured fields from a PDA/firmware string. - read_firmware_info: Return parsed firmware fields as a dictionary. - format_firmware_info: Produce a human-readable summary. - get_latest_version: Query the FOTA service for the latest version.</p>"},{"location":"api/fus.firmware/#fus.firmware.normalize_vercode","title":"normalize_vercode","text":"<pre><code>normalize_vercode(vercode)\n</code></pre> <p>Normalize a 3- or 4-part firmware version code to exactly 4 parts.</p> <p>Parameters:</p> Name Type Description Default <code>vercode</code> <code>str</code> <p>Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A normalized 4-part version string separated by '/'.</p> Source code in <code>fus/firmware.py</code> <pre><code>def normalize_vercode(vercode: str) -&gt; str:\n    \"\"\"\n    Normalize a 3- or 4-part firmware version code to exactly 4 parts.\n\n    Args:\n        vercode: Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".\n\n    Returns:\n        A normalized 4-part version string separated by '/'.\n    \"\"\"\n    parts = vercode.split(\"/\")\n    if len(parts) == 3:\n        parts.append(parts[0])\n    if parts[2] == \"\":\n        parts[2] = parts[0]\n    return \"/\".join(parts)\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.read_firmware_info","title":"read_firmware_info","text":"<pre><code>read_firmware_info(firmware)\n</code></pre> <p>Return parsed firmware information as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: - \"bl\": bootloader type or None - \"date\": formatted \"YYYY.MM\" string - \"it\": iteration string \"major.minor\"</p> Source code in <code>fus/firmware.py</code> <pre><code>def read_firmware_info(firmware: str) -&gt; dict:\n    \"\"\"\n    Return parsed firmware information as a dictionary.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        Dictionary with keys:\n            - \"bl\": bootloader type or None\n            - \"date\": formatted \"YYYY.MM\" string\n            - \"it\": iteration string \"major.minor\"\n    \"\"\"\n    ff = _read_firmware(firmware)\n    return {\"bl\": ff[0], \"date\": f\"{ff[2]}.{ff[3]+1:02d}\", \"it\": f\"{ff[1]}.{ff[4]}\"}\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.format_firmware_info","title":"format_firmware_info","text":"<pre><code>format_firmware_info(firmware)\n</code></pre> <p>Produce a human-readable summary of firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A multi-line string with normalized firmware, bootloader (if any),</p> <code>str</code> <p>date (YYYY.MM) and version iteration. If parsing fails, returns an</p> <code>str</code> <p>explanatory message containing the original input.</p> Source code in <code>fus/firmware.py</code> <pre><code>def format_firmware_info(firmware: str) -&gt; str:\n    \"\"\"\n    Produce a human-readable summary of firmware information.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        A multi-line string with normalized firmware, bootloader (if any),\n        date (YYYY.MM) and version iteration. If parsing fails, returns an\n        explanatory message containing the original input.\n    \"\"\"\n    try:\n        info = read_firmware_info(firmware)\n        norm_fw = normalize_vercode(firmware)\n\n        result = f\"Firmware: {norm_fw}\\n\"\n        if info[\"bl\"]:\n            result += f\"Bootloader type: {info['bl']}\\n\"\n        result += f\"Date: {info['date']} (YYYY.MM)\\n\"\n        result += f\"Version iteration: {info['it']}\"\n\n        return result\n    except ValueError:\n        return f\"Could not parse firmware string: {firmware}\"\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.get_latest_version","title":"get_latest_version","text":"<pre><code>get_latest_version(model, region)\n</code></pre> <p>Query the FOTA endpoint and return the latest firmware version code.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier (e.g. \"SM-G900F\").</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized version code string.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>If the endpoint returns 403 or other domain-specific errors.</p> <code>HTTPError</code> <p>For other non-success HTTP responses.</p> Source code in <code>fus/firmware.py</code> <pre><code>def get_latest_version(model: str, region: str) -&gt; str:\n    \"\"\"\n    Query the FOTA endpoint and return the latest firmware version code.\n\n    Args:\n        model: Device model identifier (e.g. \"SM-G900F\").\n        region: CSC/region code.\n\n    Returns:\n        Normalized version code string.\n\n    Raises:\n        FUSError: If the endpoint returns 403 or other domain-specific errors.\n        requests.exceptions.HTTPError: For other non-success HTTP responses.\n    \"\"\"\n    req = requests.get(\n        \"https://fota-cloud-dn.ospserver.net/firmware/\" + region + \"/\" + model + \"/version.xml\",\n        headers={'User-Agent': 'curl/7.87.0'},\n        timeout=10,\n    )\n    # Use the request_timeout from DEFAULT_CONFIG (FUSConfig), fallback to 30 if not present.\n    if hasattr(DEFAULT_CONFIG, \"request_timeout\"):\n        timeout = DEFAULT_CONFIG.request_timeout\n    else:\n        timeout = 30\n    req = requests.get(\n        \"https://fota-cloud-dn.ospserver.net/firmware/\" + region + \"/\" + model + \"/version.xml\",\n        headers={'User-Agent': 'curl/7.87.0'},\n        timeout=timeout,\n    )\n    if req.status_code == 403:\n        raise FUSError(\"Model or region not found (403)\")\n    req.raise_for_status()\n    root = ET.fromstring(req.text)\n    latest = root.find(\"./firmware/version/latest\").text  # type: ignore\n    if latest is None:\n        raise FUSError(\"No latest firmware available\")\n    return normalize_vercode(latest)\n</code></pre>"},{"location":"api/fus.messages/","title":"Package API <code>fus.messages</code>","text":""},{"location":"api/fus.messages/#fus.messages","title":"fus.messages","text":"<p>FUS XML message builders.</p> <p>Provides helpers to construct XML payloads used by the FUS protocol (inform/init). These builders return raw XML bytes ready to be posted to the FUS endpoints.</p>"},{"location":"api/fus.messages/#fus.messages.build_binary_inform","title":"build_binary_inform","text":"<pre><code>build_binary_inform(fwv, model, region, device_id, nonce)\n</code></pre> <p>Build a BinaryInform request payload.</p> <p>Parameters:</p> Name Type Description Default <code>fwv</code> <code>str</code> <p>Firmware version code.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or Serial number.</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus/messages.py</code> <pre><code>def build_binary_inform(fwv: str, model: str, region: str, device_id: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInform request payload.\n\n    Args:\n        fwv: Firmware version code.\n        model: Device model identifier.\n        region: CSC/region code.\n        device_id: Device IMEI or Serial number.\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    params = {\n        \"ACCESS_MODE\": 2,\n        \"BINARY_NATURE\": 1,\n        \"CLIENT_PRODUCT\": \"Smart Switch\",\n        \"CLIENT_VERSION\": \"4.3.23123_1\",\n        \"DEVICE_IMEI_PUSH\": device_id,\n        \"DEVICE_FW_VERSION\": fwv,\n        \"DEVICE_LOCAL_CODE\": region,\n        \"DEVICE_MODEL_NAME\": model,\n        \"LOGIC_CHECK\": logic_check(fwv, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.messages/#fus.messages.build_binary_init","title":"build_binary_init","text":"<pre><code>build_binary_init(filename, nonce)\n</code></pre> <p>Build a BinaryInitForMass request payload.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Firmware file name (including extension).</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus/messages.py</code> <pre><code>def build_binary_init(filename: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInitForMass request payload.\n\n    Args:\n        filename: Firmware file name (including extension).\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    checkinp = filename.split(\".\")[0][-16:]\n    params = {\n        \"BINARY_FILE_NAME\": filename,\n        \"LOGIC_CHECK\": logic_check(checkinp, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.responses/","title":"Package API <code>fus.responses</code>","text":""},{"location":"api/fus.responses/#fus.responses","title":"fus.responses","text":"<p>FUS inform response parsing helpers.</p> <p>Provides a small dataclass and utilities to extract firmware-related metadata (filename, path, size) and server-provided values from a FUS BinaryInform XML response.</p> <p>Functions: - get_info_from_inform: extract server path, filename and size from an inform response. - parse_inform: build an InformInfo instance combining results and logic values.</p>"},{"location":"api/fus.responses/#fus.responses.get_info_from_inform","title":"get_info_from_inform","text":"<pre><code>get_info_from_inform(root)\n</code></pre> <p>Extract download metadata from a BinaryInform XML response.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>Parsed XML root element of the BinaryInform response.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str, int]</code> <p>A tuple (filename, path, size_bytes).</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If the inform response status is not 200.</p> Source code in <code>fus/responses.py</code> <pre><code>def get_info_from_inform(root: ET.Element) -&gt; Tuple[str, str, int]:\n    \"\"\"\n    Extract download metadata from a BinaryInform XML response.\n\n    Args:\n        root: Parsed XML root element of the BinaryInform response.\n\n    Returns:\n        A tuple (filename, path, size_bytes).\n\n    Raises:\n        InformError: If the inform response status is not 200.\n        (Other exceptions may propagate if expected XML elements are missing or malformed.)\n    \"\"\"\n    status = int(root.find(\"./FUSBody/Results/Status\").text)  # type: ignore\n    if status != 200:\n        raise InformError(f\"DownloadBinaryInform returned {status}\")\n    filename = root.find(\"./FUSBody/Put/BINARY_NAME/Data\").text  # type: ignore\n    size = int(root.find(\"./FUSBody/Put/BINARY_BYTE_SIZE/Data\").text)  # type: ignore\n    path = root.find(\"./FUSBody/Put/MODEL_PATH/Data\").text  # type: ignore\n    return filename, path, size  # type: ignore\n</code></pre>"},{"location":"api/fus.responses/#fus.responses.parse_inform","title":"parse_inform","text":"<pre><code>parse_inform(root)\n</code></pre> <p>Parse a BinaryInform XML response into an InformInfo structure.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>Parsed XML root element of the BinaryInform response.</p> required <p>Returns:</p> Name Type Description <code>InformInfo</code> <code>InformInfo</code> <p>Dataclass containing latest firmware version, logic value,         filename, path and size in bytes.</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If get_info_from_inform detects a non-200 status or other          inform-related errors occur.</p> Source code in <code>fus/responses.py</code> <pre><code>def parse_inform(root: ET.Element) -&gt; InformInfo:\n    \"\"\"\n    Parse a BinaryInform XML response into an InformInfo structure.\n\n    Args:\n        root: Parsed XML root element of the BinaryInform response.\n\n    Returns:\n        InformInfo: Dataclass containing latest firmware version, logic value,\n                    filename, path and size in bytes.\n\n    Raises:\n        InformError: If get_info_from_inform detects a non-200 status or other\n                     inform-related errors occur.\n    \"\"\"\n    latest = root.findtext(\"./FUSBody/Results/LATEST_FW_VERSION/Data\")\n    logic = root.findtext(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\")\n    filename, path, size = get_info_from_inform(root)\n    return InformInfo(\n        latest_fw_version=latest,\n        logic_value_factory=logic,\n        filename=filename,\n        path=path,\n        size_bytes=size,\n    )\n</code></pre>"},{"location":"database/schema/","title":"Database Schema","text":"<p>This document describes the database schema used by nanosamfw for tracking firmware downloads and IMEI operations.</p>"},{"location":"database/schema/#overview","title":"Overview","text":"<p>The application uses SQLite for local data persistence with two main tables:</p> <ul> <li>downloads - Tracks firmware download metadata and status</li> <li>imei_log - Logs IMEI-based firmware queries and upgrade operations</li> </ul>"},{"location":"database/schema/#tables","title":"Tables","text":""},{"location":"database/schema/#downloads","title":"downloads","text":"<p>Stores metadata about firmware downloads including model, CSC, version, and download status.</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>model</code> TEXT NOT NULL Device model identifier (e.g., SM-G998B) <code>csc</code> TEXT NOT NULL Country Specific Code <code>version_code</code> TEXT NOT NULL Firmware version identifier <code>encoded_filename</code> TEXT NOT NULL Encoded filename from FUS <code>size_bytes</code> INTEGER - File size in bytes <code>status</code> TEXT NOT NULL, DEFAULT 'done' Download status <code>path</code> TEXT - Local filesystem path to downloaded file <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of creation <code>updated_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of last update <p>Unique Constraint: <code>(model, csc, version_code)</code></p>"},{"location":"database/schema/#indexes","title":"Indexes","text":"<ul> <li><code>idx_downloads_model_csc</code> - Composite index on <code>(model, csc)</code> for efficient lookups</li> </ul>"},{"location":"database/schema/#triggers","title":"Triggers","text":"<ul> <li><code>trg_downloads_updated_at</code> - Automatically updates <code>updated_at</code> timestamp on row updates</li> </ul>"},{"location":"database/schema/#imei_log","title":"imei_log","text":"<p>Logs IMEI-based firmware query and upgrade operations with status tracking.</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>imei</code> TEXT NOT NULL Device IMEI number <code>model</code> TEXT NOT NULL Device model identifier <code>csc</code> TEXT NOT NULL, CHECK length Country Specific Code (3-5 chars, supports multi-CSC like EUX/FTM) <code>version_code</code> TEXT NOT NULL, CHECK format Firmware version in AAA/BBB/CCC/DDD format <code>status_fus</code> TEXT NOT NULL, DEFAULT 'unknown' FUS query status (ok, error, denied, unauthorized, throttled, unknown) <code>status_upgrade</code> TEXT NOT NULL, DEFAULT 'unknown' Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown) <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of log entry creation <code>upgrade_at</code> TEXT - ISO 8601 timestamp when upgrade operation occurred <p>Constraints:</p> <ul> <li><code>status_fus</code> must be one of: <code>ok</code>, <code>error</code>, <code>denied</code>, <code>unauthorized</code>, <code>throttled</code>, <code>unknown</code></li> <li><code>status_upgrade</code> must be one of: <code>queued</code>, <code>in_progress</code>, <code>ok</code>, <code>failed</code>, <code>skipped</code>, <code>unknown</code></li> <li><code>version_code</code> must contain exactly 3 forward slashes (AAA/BBB/CCC/DDD format)</li> <li><code>csc</code> length must be between 3 and 5 characters</li> </ul>"},{"location":"database/schema/#indexes_1","title":"Indexes","text":"<ul> <li><code>idx_imei_log__imei_created</code> - Composite index on <code>(imei, created_at DESC)</code> for IMEI history queries</li> <li><code>idx_imei_log__model_csc_created</code> - Composite index on <code>(model, csc, created_at DESC)</code> for device queries</li> <li><code>idx_imei_log__model_csc_version</code> - Composite index on <code>(model, csc, version_code)</code> for version lookups</li> <li><code>idx_imei_log__created_at</code> - Index on <code>created_at</code> for chronological queries</li> <li><code>idx_imei_log__upgrade_at</code> - Index on <code>upgrade_at</code> for upgrade operation queries</li> </ul>"},{"location":"database/schema/#sql-schema-files","title":"SQL Schema Files","text":"<p>The schema definitions are maintained in the following files:</p> <ul> <li><code>download/sql/download.sql</code> - Downloads table schema</li> <li><code>download/sql/imei_log.sql</code> - IMEI log table schema</li> </ul>"},{"location":"database/schema/#usage","title":"Usage","text":"<p>The database is managed through the repository pattern:</p> <ul> <li>download.repository - Main download operations</li> <li>download.imei_repository - IMEI log operations</li> <li>download.db - Database connection management</li> </ul>"}]}