{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"nanosamfw Documentation","text":"<p>nanosamfw (NotANOtherSamsungFirmware downloader) is a Python package providing programmatic access to Samsung firmware downloads through the Samsung Firmware Update Service (FUS).</p> <p>Release v0.1.2a \u2014 v0.1.2</p>"},{"location":"#overview","title":"Overview","text":"<p>This package offers a clean, well-documented Python API for:</p> <ul> <li>Firmware Discovery: Query latest firmware versions from Samsung FOTA service</li> <li>Secure Downloads: Download firmware with resume capability via FUS protocol</li> <li>Decryption: Automatic decryption of ENC2/ENC4 encrypted firmware files</li> <li>Device Integration: Read device info via AT commands (normal/recovery mode) or Odin protocol (download mode)</li> <li>Database Tracking: Built-in SQLite tracking for firmware repository and IMEI operations</li> <li>Integration Ready: Designed for easy integration into tools and workflows</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#full-fus-protocol-support","title":"\ud83d\udd10 Full FUS Protocol Support","text":"<ul> <li>BinaryInform, BinaryInit, and BinaryDownload operations</li> <li>Server nonce handling and cryptographic signature generation</li> <li>Device ID (IMEI/Serial) validation and auto-detection</li> </ul>"},{"location":"#device-detection-two-modes","title":"\ud83d\udcf1 Device Detection (Two Modes)","text":"<ul> <li>AT Commands (Normal/Recovery Mode): <code>read_device_info_at()</code> \u2014 reads model, IMEI, firmware, region via AT+DEVCONINFO</li> <li>Odin Protocol (Download Mode): <code>read_device_info()</code> \u2014 sends DVIF command for detailed device info</li> <li>Auto-detect via <code>detect_download_mode_devices()</code> (cross-platform, requires pyserial and Samsung USB drivers on Windows)</li> <li>Seamless integration with firmware download workflow</li> </ul>"},{"location":"#high-level-download-api","title":"\ud83d\udce6 High-Level Download API","text":"<ul> <li>One-line firmware downloads with automatic version resolution</li> <li>HTTP Range support for resuming interrupted downloads</li> <li>Progress callback support for custom UI integration</li> </ul>"},{"location":"#firmware-decryption","title":"\ud83d\udd13 Firmware Decryption","text":"<ul> <li>ENC2 (MD5-based) and ENC4 (logic-value-based) decryption</li> <li>Automatic key derivation from FUS responses</li> <li>Streaming decryption with progress tracking</li> </ul>"},{"location":"#firmware-repository","title":"\ud83d\udcbe Firmware Repository","text":"<ul> <li>Centralized firmware storage (one record per version, no model/CSC duplication)</li> <li>Cached InformInfo metadata including logic values for efficient operations</li> <li>IMEI event logging with FUS status tracking (ok/error/denied/unauthorized/throttled/unknown)</li> <li>Repository pattern with clean data access layers</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>nanosamfw uses a three-layer architecture for clean separation of concerns:</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Service Layer                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 check_and_prepare_firmware() \u2502 FOTA check + cache   \u2502\n\u2502 get_or_download_firmware()   \u2502 FUS download + resume\u2502\n\u2502 decrypt_firmware()           \u2502 Repository \u2192 decrypt \u2502\n\u2502 download_and_decrypt()       \u2502 Full workflow end-end\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Repository Layer                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 firmware_repository.py   \u2502 FirmwareRecord CRUD      \u2502\n\u2502 imei_repository.py       \u2502 IMEIEvent logging        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Database Layer                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 firmware.db (SQLite, WAL mode)                       \u2502\n\u2502  \u251c\u2500 firmware  \u2502 one per version, logic_value cached \u2502\n\u2502  \u2514\u2500 imei_log  \u2502 FOTA queries + FUS status tracking  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key Design Principles:</p> <ul> <li>Firmware Repository: Centralized storage \u2014 one record per firmware version (no model/CSC duplication)</li> <li>Smart Downloads: Checks repository before downloading from FUS servers</li> <li>Cached Metadata: Stores InformInfo data including logic values for efficient ENC4 decryption without extra FUS calls</li> <li>Separation of Concerns: FOTA check, download, and decrypt are independent operations</li> <li>Status Tracking: IMEI log captures all FOTA queries with FUS operation status (ok/error/denied/unauthorized/throttled/unknown)</li> <li>Error Handling: FUSError subclasses with built-in messages (InformError.BadStatus, FOTAError, etc.)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#complete-workflow","title":"Complete Workflow","text":"Python<pre><code>from download import download_and_decrypt\n\n# Download and decrypt in one call\nfirmware, decrypted = download_and_decrypt(\n    model=\"SM-G998B\",\n    csc=\"EUX\",\n    device_id=\"352976245060954\",\n    resume=True,\n)\n\nprint(f\"Version: {firmware.version_code}\")\nprint(f\"Decrypted file: {decrypted}\")\n</code></pre>"},{"location":"#separate-operations","title":"Separate Operations","text":"Python<pre><code>from download import check_and_prepare_firmware, get_or_download_firmware, decrypt_firmware\n\n# 1. Check FOTA for latest version and repository cache\nversion, is_cached = check_and_prepare_firmware(\n    \"SM-G998B\", \"EUX\", \"352976245060954\", \"current_firmware_version\"\n)\nprint(f\"Latest: {version}, Cached: {is_cached}\")\n\n# 2. Download to repository (if not already present)\nfirmware = get_or_download_firmware(version, \"SM-G998B\", \"EUX\", \"352976245060954\")\nprint(f\"Encrypted file: {firmware.encrypted_file_path}\")\n\n# 3. Decrypt from repository (can be deferred!)\ndecrypted = decrypt_firmware(version)\nprint(f\"Decrypted file: {decrypted}\")\n</code></pre>"},{"location":"#repository-queries","title":"Repository Queries","text":"Python<pre><code>from download import find_firmware, list_firmware\n\n# Find specific version\nfw = find_firmware(\"G998BXXU1ATCT/...\")\nif fw:\n    print(f\"Logic value: {fw.logic_value_factory}\")\n    print(f\"Size: {fw.size_bytes} bytes\")\n\n# List all firmware in repository\nfor fw in list_firmware(limit=10):\n    print(f\"{fw.version_code}: {fw.filename}\")\n</code></pre>"},{"location":"#device-integration-at-commands-normalrecovery-mode","title":"Device Integration \u2014 AT Commands (Normal/Recovery Mode)","text":"Python<pre><code>from device import read_device_info_at\nfrom download import check_and_prepare_firmware, download_and_decrypt\n\n# Auto-detect connected device (requires pyserial)\ndevice = read_device_info_at()\nprint(f\"Connected: {device.model} \u2014 IMEI: {device.imei}\")\nprint(f\"Current firmware: {device.firmware_version}\")\nprint(f\"Region: {device.sales_code}\")\n\n# Check for updates and download if available\nlatest, is_cached = check_and_prepare_firmware(\n    device.model, device.sales_code, device.imei, device.firmware_version\n)\n\nif latest != device.firmware_version:\n    firmware, decrypted = download_and_decrypt(\n        device.model, device.sales_code, device.imei, device.firmware_version\n    )\n    print(f\"Decrypted: {decrypted}\")\n</code></pre>"},{"location":"#device-integration-odin-protocol-download-mode","title":"Device Integration \u2014 Odin Protocol (Download Mode)","text":"Python<pre><code>from device import read_device_info, detect_download_mode_devices, is_odin_mode\nfrom download import check_and_prepare_firmware, download_and_decrypt\n\n# 1. Detect device in download mode\ndevices = detect_download_mode_devices()\nif devices:\n    # 2. Verify it's in Odin mode\n    if is_odin_mode(devices[0].port_name):\n        # 3. Read device info via DVIF protocol\n        device = read_device_info(devices[0].port_name)\n        print(f\"Connected: {device.model} \u2014 Firmware: {device.fwver}\")\n        print(f\"Region: {device.sales}\")\n\n        # 4. Check for updates (no IMEI available in download mode)\n        latest, is_cached = check_and_prepare_firmware(\n            device.model, device.sales, \"\", device.fwver\n        )\n\n        if latest != device.fwver:\n            firmware, decrypted = download_and_decrypt(\n                device.model, device.sales, \"\", device.fwver\n            )\n            print(f\"Decrypted: {decrypted}\")\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.14 or higher</li> <li>Core Dependencies:</li> <li><code>pycryptodome</code> \u2014 Cryptographic operations (AES, PKCS7)</li> <li><code>requests</code> \u2014 HTTP client for FUS/FOTA communication</li> <li><code>tqdm</code> \u2014 Progress bars for download/decrypt</li> <li>Device Detection (optional):</li> <li><code>pyserial \u2265 3.5</code> \u2014 Serial port communication (cross-platform)</li> <li>Samsung USB drivers (Windows only, for download mode)</li> </ul>"},{"location":"#installation","title":"Installation","text":"Bash<pre><code>pip install -r requirements.txt\n</code></pre> <p>For development/docs building:</p> Bash<pre><code>pip install -r dev-requirements.txt\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":""},{"location":"#core-modules","title":"Core Modules","text":"<ul> <li>fus \u2014 FUS protocol client and utilities</li> <li>Client implementation with session management and NONCE rotation</li> <li>Cryptographic operations and key derivation (AES-128, MD5)</li> <li>Firmware version parsing and normalization</li> <li>Device ID validation (IMEI/Serial TAC)</li> <li> <p>Error handling with FUSError subclasses</p> </li> <li> <p>download \u2014 High-level download service</p> </li> <li>Firmware repository management (one record per version)</li> <li>FOTA version checking with IMEI logging</li> <li>Smart download (skips if already cached)</li> <li>On-demand decryption with cached logic values</li> <li>Configuration and path management</li> <li> <p>Status tracking (ok/error/denied/unauthorized/throttled/unknown)</p> </li> <li> <p>device \u2014 Device detection and information reading</p> </li> <li>AT Commands (normal/recovery mode): <code>read_device_info_at()</code></li> <li>Odin Protocol (download mode): <code>read_device_info()</code>, <code>is_odin_mode()</code></li> <li>Auto-detect via <code>detect_download_mode_devices()</code></li> <li>Cross-platform support (Windows/Linux/macOS)</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Core API \u2014 FUS client, cryptography, device validation, errors</li> <li>Download API \u2014 Service layer, repositories, configuration</li> <li>Device API \u2014 Device detection (AT/Odin protocols), models, errors</li> <li>Database \u2014 Schema documentation and repository patterns</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is MIT licensed. See the LICENSE file for details.</p> <p>Built upon GNSF by keklick1337 \u2014 thanks for the excellent foundation!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please ensure:</p> <ul> <li>Code Style: PEP 8, 100-char line length (Black + Pylint enforced)</li> <li>Type Hints: Required for all function parameters and return values</li> <li>Docstrings: Google-style with proper <code>Args:</code>, <code>Returns:</code>, <code>Raises:</code> sections</li> <li>Testing: Manual validation scripts included; test against real Samsung servers</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Releases</li> <li>Documentation</li> </ul>"},{"location":"gui-architecture/","title":"GUI Application Architecture","text":"<p>The <code>app/</code> package provides a graphical user interface for Samsung firmware downloads with automatic device detection and firmware management.</p>"},{"location":"gui-architecture/#overview","title":"Overview","text":"<p>The GUI application is built with customtkinter and follows a modular architecture pattern, separating concerns into six focused modules:</p> <ul> <li>gui.py (280 lines) - Main application window and lifecycle</li> <li>device_monitor.py (363 lines) - Device detection and firmware orchestration</li> <li>ui_builder.py (352 lines) - UI widget creation and layout</li> <li>ui_updater.py (230 lines) - Thread-safe UI updates</li> <li>progress_tracker.py (154 lines) - Progress calculations and tracking</li> <li>config.py (84 lines) - Configuration management</li> </ul>"},{"location":"gui-architecture/#module-dependencies","title":"Module Dependencies","text":"Text Only<pre><code>graph TD\n    A[gui.py] --&gt; B[config.py]\n    A --&gt; C[ui_builder.py]\n    A --&gt; D[ui_updater.py]\n    A --&gt; E[progress_tracker.py]\n    A --&gt; F[device_monitor.py]\n    F --&gt; D\n    F --&gt; E\n</code></pre>"},{"location":"gui-architecture/#dependency-flow","title":"Dependency Flow","text":"Text Only<pre><code>gui.py (main orchestrator)\n  \u251c\u2500&gt; config.py (settings via AppConfig dataclass)\n  \u251c\u2500&gt; ui_builder.py (creates CTk widgets, returns dict)\n  \u251c\u2500&gt; ui_updater.py (thread-safe updates via after())\n  \u251c\u2500&gt; progress_tracker.py (calculations, callbacks)\n  \u2514\u2500&gt; device_monitor.py (AT detection, firmware ops)\n        \u251c\u2500&gt; ui_updater (status/field updates)\n        \u2514\u2500&gt; progress_tracker (via callback)\n</code></pre>"},{"location":"gui-architecture/#module-responsibilities","title":"Module Responsibilities","text":""},{"location":"gui-architecture/#guipy-main-application","title":"gui.py - Main Application","text":"<p>Purpose: Application window orchestration and lifecycle management</p> <p>Key Features: - Window setup (geometry, icon, appearance) - Startup cleanup coordination - Monitoring thread management - Stop functionality coordination</p> <p>Main Class: <code>FirmwareDownloaderApp(ctk.CTk)</code></p>"},{"location":"gui-architecture/#configpy-configuration","title":"config.py - Configuration","text":"<p>Purpose: Load and manage application settings from TOML</p> <p>Key Features: - Parse <code>app/config.toml</code> file - Provide <code>AppConfig</code> dataclass - Handle missing config gracefully with defaults</p> <p>Configuration Sections: - <code>[gui]</code> - UI element toggles (btn_dryrun, btn_autofus) - <code>[devices]</code> - Device behavior (auto_fusmode, csc_filter)</p>"},{"location":"gui-architecture/#ui_builderpy-widget-creation","title":"ui_builder.py - Widget Creation","text":"<p>Purpose: Create and layout all customtkinter widgets</p> <p>Key Features: - Create status frame - Create device information frame (model, firmware, region, etc.) - Create progress frame (bar, label, stop button) - Create firmware components frame - Create settings frame (checkboxes, labels) - Create splash screen for startup</p> <p>Main Class: <code>UIBuilder</code></p> <p>Returns: Dictionary of widget references for other modules to use</p>"},{"location":"gui-architecture/#ui_updaterpy-thread-safe-updates","title":"ui_updater.py - Thread-Safe Updates","text":"<p>Purpose: Update UI widgets from background threads safely</p> <p>Key Features: - Thread-safe updates via <code>root.after(0, callback)</code> - Update status messages - Update device information fields - Update progress messages with color coding - Update firmware component paths - Manage stop button state</p> <p>Main Class: <code>UIUpdater</code></p> <p>Thread Safety: All updates scheduled on main thread using Tkinter's <code>after()</code> mechanism</p>"},{"location":"gui-architecture/#progress_trackerpy-progress-tracking","title":"progress_tracker.py - Progress Tracking","text":"<p>Purpose: Calculate progress, ETA, and throughput</p> <p>Key Features: - Throttle progress updates (avoid UI slowdown) - Calculate elapsed time and ETA - Track throughput (MB/s) - Format time durations - Handle multiple stages (download, decrypt, extract)</p> <p>Main Class: <code>ProgressTracker</code></p> <p>Update Conditions: - Task completion - Progress change &gt;= 1% - At least 100ms elapsed since last update</p>"},{"location":"gui-architecture/#device_monitorpy-device-detection","title":"device_monitor.py - Device Detection","text":"<p>Purpose: Monitor for Samsung devices and orchestrate firmware operations</p> <p>Key Features: - Background monitoring loop - AT command device detection - Firmware version checking via FOTA - Download/decrypt/extract orchestration - Error handling for various failure modes - Stop check integration</p> <p>Main Class: <code>DeviceMonitor</code></p> <p>Detection Method: Uses <code>device.read_device_info_at()</code> for AT protocol communication</p>"},{"location":"gui-architecture/#communication-patterns","title":"Communication Patterns","text":""},{"location":"gui-architecture/#thread-safety","title":"Thread Safety","text":"<p>All UI updates from background threads use Tkinter's <code>after()</code> mechanism:</p> Python<pre><code>self.root.after(0, lambda: widget.configure(text=\"New value\"))\n</code></pre>"},{"location":"gui-architecture/#callback-pattern","title":"Callback Pattern","text":"<p>The progress tracker uses a callback pattern to decouple progress calculations from UI updates:</p> Python<pre><code># Progress tracker callback signature\ncallback(stage: str, done: int, total: int, label: str)\n\n# Device monitor progress callback\nprogress_callback(stage: str, done: int, total: int)\n</code></pre>"},{"location":"gui-architecture/#stop-mechanism","title":"Stop Mechanism","text":"<p>The stop functionality uses a shared flag checked by download/decrypt operations:</p> Python<pre><code>def stop_check() -&gt; bool:\n    return self.stop_task\n\n# Passed to download service\ndownload_and_decrypt(..., stop_check=stop_check)\n</code></pre>"},{"location":"gui-architecture/#application-flow","title":"Application Flow","text":""},{"location":"gui-architecture/#1-initialization","title":"1. Initialization","text":"Text Only<pre><code>FirmwareDownloaderApp.__init__()\n  \u251c\u2500&gt; init_db()\n  \u251c\u2500&gt; load_config()\n  \u251c\u2500&gt; UIBuilder(root, config)\n  \u2514\u2500&gt; _run_startup_cleanup()\n</code></pre>"},{"location":"gui-architecture/#2-startup-cleanup","title":"2. Startup Cleanup","text":"Text Only<pre><code>_run_startup_cleanup()\n  \u251c\u2500&gt; UIBuilder.create_splash_widgets()\n  \u2514\u2500&gt; Thread(_perform_cleanup)\n        \u251c\u2500&gt; cleanup_repository(progress_cb)\n        \u2514\u2500&gt; _finish_startup()\n              \u251c\u2500&gt; destroy splash\n              \u251c\u2500&gt; _create_widgets()\n              \u2514\u2500&gt; start_monitoring()\n</code></pre>"},{"location":"gui-architecture/#3-widget-creation","title":"3. Widget Creation","text":"Text Only<pre><code>_create_widgets()\n  \u251c\u2500&gt; UIBuilder.create_main_widgets(stop_callback)\n  \u251c\u2500&gt; UIUpdater(root, widgets)\n  \u251c\u2500&gt; ProgressTracker(ui_callback)\n  \u2514\u2500&gt; DeviceMonitor(ui_updater, progress_callback, stop_check)\n</code></pre>"},{"location":"gui-architecture/#4-device-monitoring","title":"4. Device Monitoring","text":"Text Only<pre><code>DeviceMonitor.start()\n  \u251c\u2500&gt; while monitoring:\n  \u2502     \u251c\u2500&gt; read_device_info_at()\n  \u2502     \u251c\u2500&gt; check_and_prepare_firmware()\n  \u2502     \u251c\u2500&gt; download_and_decrypt()\n  \u2502     \u251c\u2500&gt; extract firmware\n  \u2502     \u2514\u2500&gt; populate component entries\n  \u2514\u2500&gt; handle errors (DeviceNotFoundError, FOTAError, etc.)\n</code></pre>"},{"location":"gui-architecture/#error-handling","title":"Error Handling","text":"<p>The device monitor handles various error types:</p> <ul> <li>DeviceNotFoundError - Device disconnected</li> <li>DeviceError - Communication errors</li> <li>FOTAModelOrRegionNotFound - Model/CSC not in FOTA database</li> <li>FOTANoFirmware - No firmware available</li> <li>InformError.BadStatus - FUS server errors (400, 408, etc.)</li> <li>RuntimeError - User-initiated stop or extraction errors</li> </ul>"},{"location":"gui-architecture/#configuration-example","title":"Configuration Example","text":"<p><code>app/config.toml</code>:</p> TOML<pre><code>[gui]\nbtn_dryrun = false      # Hide dry run checkbox\nbtn_autofus = true      # Show Auto FUS Mode checkbox\n\n[devices]\nauto_fusmode = true     # Automatically enter FUS mode\ncsc_filter = \"\"         # Filter devices by CSC codes (comma-separated)\n</code></pre>"},{"location":"gui-architecture/#benefits-of-modular-design","title":"Benefits of Modular Design","text":"<ol> <li>Single Responsibility: Each module has one clear purpose</li> <li>Testability: Logic separated from UI widgets</li> <li>Maintainability: Changes isolated to relevant modules</li> <li>Readability: ~100-360 lines per file vs 1000+ in monolithic design</li> <li>Reusability: Progress tracker and device monitor can be reused</li> </ol>"},{"location":"gui-architecture/#api-documentation","title":"API Documentation","text":"<p>For detailed API documentation, see:</p> <ul> <li>gui.py - Main application</li> <li>config.py - Configuration</li> <li>ui_builder.py - Widget creation</li> <li>ui_updater.py - UI updates</li> <li>device_monitor.py - Device monitoring</li> <li>progress_tracker.py - Progress tracking</li> </ul>"},{"location":"api/app.config/","title":"app.config","text":""},{"location":"api/app.config/#app.config","title":"app.config","text":"<p>Configuration management for the GUI application.</p> <p>This module handles loading and validation of configuration settings from the config.toml file.</p>"},{"location":"api/app.config/#app.config.AppConfig","title":"AppConfig  <code>dataclass</code>","text":"<p>Application configuration settings.</p> <p>Attributes:</p> Name Type Description <code>btn_dryrun</code> <code>bool</code> <p>Show/hide \"Dry run\" checkbox in GUI.</p> <code>btn_autofus</code> <code>bool</code> <p>Show/hide \"Auto FUS Mode\" checkbox in GUI.</p> <code>auto_fusmode</code> <code>bool</code> <p>Automatically enter device into FUS mode when needed.</p> <code>csc_filter</code> <code>str</code> <p>Comma-separated list of CSC codes to filter devices.</p> <code>unzip_home_csc</code> <code>bool</code> <p>Whether to extract HOME_CSC files when unzipping firmware.</p> Source code in <code>app/config.py</code> Python<pre><code>@dataclass\nclass AppConfig:\n    \"\"\"Application configuration settings.\n\n    Attributes:\n        btn_dryrun: Show/hide \"Dry run\" checkbox in GUI.\n        btn_autofus: Show/hide \"Auto FUS Mode\" checkbox in GUI.\n        auto_fusmode: Automatically enter device into FUS mode when needed.\n        csc_filter: Comma-separated list of CSC codes to filter devices.\n        unzip_home_csc: Whether to extract HOME_CSC files when unzipping firmware.\n    \"\"\"\n\n    btn_dryrun: bool\n    btn_autofus: bool\n    auto_fusmode: bool\n    csc_filter: str\n    unzip_home_csc: bool\n</code></pre>"},{"location":"api/app.config/#app.config.load_config","title":"load_config","text":"Python<pre><code>load_config(config_path=None)\n</code></pre> <p>Load configuration from config.toml file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path | None</code> <p>Path to config.toml file. If None, uses app/config.toml.</p> <code>None</code> <p>Returns:</p> Type Description <code>AppConfig</code> <p>AppConfig instance with loaded or default settings.</p> Source code in <code>app/config.py</code> Python<pre><code>def load_config(config_path: Path | None = None) -&gt; AppConfig:\n    \"\"\"Load configuration from config.toml file.\n\n    Args:\n        config_path: Path to config.toml file. If None, uses app/config.toml.\n\n    Returns:\n        AppConfig instance with loaded or default settings.\n    \"\"\"\n    if config_path is None:\n        # Resolve config path: when frozen (PyInstaller), load from .exe directory\n        if getattr(sys, \"frozen\", False) and hasattr(sys, \"executable\"):\n            base_dir = Path(sys.executable).parent\n        else:\n            base_dir = Path(__file__).parent\n        config_path = base_dir / \"config.toml\"\n\n    logger = logging.getLogger(__name__)\n\n    try:\n        with open(config_path, \"rb\") as f:\n            config = tomllib.load(f)\n        logger.info(\"Loaded config from %s\", config_path)\n\n        # GUI settings\n        gui_config = config.get(\"gui\", {})\n        btn_dryrun = gui_config.get(\"btn_dryrun\", False)\n        btn_autofus = gui_config.get(\"btn_autofus\", False)\n\n        # Device settings\n        device_config = config.get(\"devices\", {})\n        auto_fusmode = device_config.get(\"auto_fusmode\", False)\n        csc_filter = device_config.get(\"csc_filter\", \"\").strip()\n\n        # Firmware settings\n        firmware_config = config.get(\"firmware\", {})\n        unzip_home_csc = firmware_config.get(\"unzip_home_csc\", False)\n\n        logger.info(\n            \"Config loaded: dryrun=%s, autofus=%s, auto_fusmode=%s, csc_filter=%s, unzip_home_csc=%s\",\n            btn_dryrun,\n            btn_autofus,\n            auto_fusmode,\n            csc_filter,\n            unzip_home_csc,\n        )\n\n        return AppConfig(\n            btn_dryrun=btn_dryrun,\n            btn_autofus=btn_autofus,\n            auto_fusmode=auto_fusmode,\n            csc_filter=csc_filter,\n            unzip_home_csc=unzip_home_csc,\n        )\n\n    except (FileNotFoundError, OSError) as ex:\n        # Use defaults if config file not found\n        logger.warning(\"Config file not found or error reading: %s. Using defaults.\", ex)\n        return AppConfig(\n            btn_dryrun=False,\n            btn_autofus=True,\n            auto_fusmode=True,\n            csc_filter=\"\",\n            unzip_home_csc=True,\n        )\n</code></pre>"},{"location":"api/app.device_monitor/","title":"app.device_monitor","text":""},{"location":"api/app.device_monitor/#app.device_monitor","title":"app.device_monitor","text":"<p>Device monitoring and firmware orchestration logic.</p> <p>This module handles device detection, firmware checking, downloading, decrypting, and extracting in a background thread.</p>"},{"location":"api/app.device_monitor/#app.device_monitor.DeviceMonitor","title":"DeviceMonitor","text":"<p>Monitors for Samsung device connections and orchestrates firmware operations.</p> <p>Runs in a background thread, detecting devices via AT commands, checking for firmware updates, and coordinating download/decrypt/extract operations.</p> <p>CSC Filter Logic: - Empty filter (default) = accept all devices - Non-empty filter = only accept devices with CSC in the filter list</p> <p>Attributes:</p> Name Type Description <code>ui_updater</code> <p>UIUpdater instance for thread-safe UI updates.</p> <code>progress_callback</code> <p>Callback for progress updates.</p> <code>stop_check</code> <p>Function that returns True if task should stop.</p> <code>disconnect_callback</code> <p>Optional callback invoked when device disconnects.</p> <code>csc_filter</code> <code>set[str]</code> <p>Set of allowed CSC codes (empty = accept all).</p> <code>unzip_home_csc</code> <p>Whether to extract HOME_CSC files during extraction.</p> <code>logger</code> <p>Logger instance.</p> Source code in <code>app/device_monitor.py</code> Python<pre><code>class DeviceMonitor:\n    \"\"\"Monitors for Samsung device connections and orchestrates firmware operations.\n\n    Runs in a background thread, detecting devices via AT commands, checking\n    for firmware updates, and coordinating download/decrypt/extract operations.\n\n    CSC Filter Logic:\n    - Empty filter (default) = accept all devices\n    - Non-empty filter = only accept devices with CSC in the filter list\n\n    Attributes:\n        ui_updater: UIUpdater instance for thread-safe UI updates.\n        progress_callback: Callback for progress updates.\n        stop_check: Function that returns True if task should stop.\n        disconnect_callback: Optional callback invoked when device disconnects.\n        csc_filter: Set of allowed CSC codes (empty = accept all).\n        unzip_home_csc: Whether to extract HOME_CSC files during extraction.\n        logger: Logger instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        ui_updater,\n        progress_callback: Callable[[str, int, int], None],\n        stop_check: Callable[[], bool],\n        disconnect_callback: Callable[[], None] | None = None,\n        csc_filter: list[str] | None = None,\n        unzip_home_csc: bool = True,\n    ):\n        \"\"\"Initialize device monitor.\n\n        Args:\n            ui_updater: UIUpdater instance for UI updates.\n            progress_callback: Function(stage, done, total) for progress updates.\n            stop_check: Function returning True if task should be stopped.\n            disconnect_callback: Optional callback invoked when device disconnects.\n            csc_filter: Optional list of allowed CSC codes (case-insensitive).\n                Empty list = accept all devices. Non-empty = only accept listed CSCs.\n            unzip_home_csc: Whether to extract HOME_CSC files when unzipping firmware.\n        \"\"\"\n        self.ui_updater = ui_updater\n        self.progress_callback = progress_callback\n        self.stop_check = stop_check\n        self.disconnect_callback = disconnect_callback\n        self.csc_filter: set[str] = {c.strip().upper() for c in csc_filter} if csc_filter else set()\n        self.unzip_home_csc = unzip_home_csc\n        self.logger = logging.getLogger(__name__)\n        self.monitoring = False\n        self.download_in_progress = False\n\n    def start(self) -&gt; None:\n        \"\"\"Start device monitoring loop (call from background thread).\"\"\"\n        self.monitoring = True\n        self._monitor_loop()\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop device monitoring.\"\"\"\n        self.monitoring = False\n\n    def _monitor_loop(self) -&gt; None:\n        \"\"\"Main device monitoring loop.\"\"\"\n        device_connected = False\n        last_device_model = None\n\n        while self.monitoring:\n            try:\n                # Try to detect device via AT commands\n                device = read_device_info_at()\n\n                # Device found\n                if not device_connected:\n                    # New device connection\n                    device_connected = True\n                    last_device_model = device.model\n                    self.logger.info(\"Device connected: %s\", device.model)\n                    self.logger.info(\"CSC: %s, AID: %s, CC: %s\", device.sales_code, device.aid, device.cc)\n                    self.logger.info(\n                        \"IMEI: %s, SN: %s, LOCK: %s\",\n                        device.imei,\n                        device.serial_number,\n                        device.lock_status,\n                    )\n                    self.logger.info(\"Firmware: %s\", device.firmware_version)\n\n                    # Clear old component paths from previous device\n                    self.ui_updater.clear_component_entries()\n\n                    # Update device fields first (before any filtering check)\n                    self.ui_updater.update_device_fields(\n                        device.model,\n                        device.firmware_version,\n                        device.sales_code,\n                        device.imei,\n                        aid=device.aid or \"-\",\n                        cc=device.cc or \"-\",\n                    )\n\n                    # Check CSC filter (empty = allow all, non-empty = only allow listed CSCs)\n                    device_csc = (device.sales_code or \"\").strip().upper()\n                    if self.csc_filter and device_csc and device_csc not in self.csc_filter:\n                        self.logger.info(\"Device rejected by CSC filter: %s (%s)\", device.model, device_csc)\n                        self.ui_updater.update_status(\"Device filtered by CSC\")\n                        self.ui_updater.update_progress_message(\"CSC Filtered\", \"warning\")\n                        # Skip processing for this device, wait for disconnect\n                        time.sleep(1)\n                        continue\n\n                    self.ui_updater.update_status(\"Device detected! Checking firmware...\")\n\n                    # Check for firmware and handle download/decrypt/extract\n                    self._handle_firmware_check(device)\n\n                    # Wait for device disconnect after processing\n                    self.ui_updater.update_status(\"Waiting for device disconnect...\")\n\n                # Device still connected, wait for disconnect\n                time.sleep(1)\n\n            except DeviceNotFoundError:\n                # Device disconnected or not present\n                if device_connected:\n                    # Device was connected, now disconnected\n                    self.logger.info(\"Device disconnected: %s\", last_device_model)\n                    device_connected = False\n                    last_device_model = None\n                    self.ui_updater.update_status(\"Device disconnected. Waiting for new device...\")\n                    self.ui_updater.set_device_placeholders()\n                    # Keep component paths visible until new device connects\n                    self.ui_updater.update_progress_message(\"Waiting for device\", \"info\")\n\n                    # Reset stop flag for next device\n                    if self.disconnect_callback:\n                        self.disconnect_callback()\n\n                # Wait before checking again\n                time.sleep(1)\n\n            except DeviceError as ex:\n                msg = f\"Device error: {ex}\"\n                self.logger.error(msg)\n                # Reset connection state to allow fresh detection attempts\n                device_connected = False\n                last_device_model = None\n                self.ui_updater.update_status(\"Device error detected - Retrying detection\")\n                self.ui_updater.set_device_placeholders()\n                # Keep component paths visible until new device connects\n                # Keep progress zone clean of communication errors\n                self.ui_updater.update_progress_message(\"Waiting for device\", \"info\")\n                time.sleep(2)\n\n            except (OSError, IOError, ValueError, RuntimeError) as ex:\n                msg = f\"Unexpected error: {ex}\"\n                self.logger.error(msg)\n                device_connected = False\n                last_device_model = None\n                self.ui_updater.update_status(\"Error occurred - Retrying detection\")\n                self.ui_updater.set_device_placeholders()\n                # Keep component paths visible until new device connects\n                self.ui_updater.update_progress_message(\"Waiting for device\", \"info\")\n                time.sleep(2)\n\n    def _handle_firmware_check(self, device) -&gt; None:\n        \"\"\"Check for firmware updates and handle download/decrypt/extract.\n\n        Args:\n            device: ATDeviceInfo instance with device information.\n        \"\"\"\n        try:\n            self.logger.info(\"Checking FOTA for %s/%s\", device.model, device.sales_code)\n            latest, is_cached = check_and_prepare_firmware(\n                device.model,\n                device.sales_code,\n                device.imei,\n                device.firmware_version,\n                serial_number=device.serial_number,\n                lock_status=device.lock_status,\n                aid=device.aid,\n                cc=device.cc,\n            )\n            self.logger.info(\"FOTA returned version: %s (cached: %s)\", latest, is_cached)\n\n            if latest == device.firmware_version:\n                msg = f\"Firmware already latest version: {latest}\"\n                self.logger.info(msg)\n                self.ui_updater.update_status(\"Device connected\")\n                self.ui_updater.update_progress_message(msg, \"success\")\n\n            elif is_cached:\n                # Firmware already downloaded, just decrypt and extract\n                self._handle_cached_firmware(device, latest)\n\n            else:\n                # Download firmware via FUS\n                self._handle_firmware_download(device, latest)\n\n        except FOTAModelOrRegionNotFound:\n            msg = \"Model or CSC not recognized by FOTA\"\n            self.logger.warning(\"%s: %s/%s\", msg, device.model, device.sales_code)\n            self.ui_updater.update_status(\"Device connected\")\n            self.ui_updater.update_progress_message(msg, \"warning\")\n\n        except FOTANoFirmware:\n            msg = \"No firmware available from FOTA\"\n            self.logger.warning(\"%s for %s/%s\", msg, device.model, device.sales_code)\n            self.ui_updater.update_status(\"Device connected\")\n            self.ui_updater.update_progress_message(msg, \"warning\")\n\n        except (OSError, IOError, ValueError, RuntimeError) as ex:\n            # Generic non-firmware error during check/download\n            msg = f\"Error: {ex}\"\n            self.logger.error(msg)\n            self.ui_updater.update_status(\"Device connected - Firmware operation error\")\n            self.ui_updater.update_progress_message(\"Waiting for device\", \"info\")\n            self.download_in_progress = False\n            self.ui_updater.update_stop_button_state(self.download_in_progress, self.stop_check())\n\n    def _handle_cached_firmware(self, device, latest: str) -&gt; None:\n        \"\"\"Handle cached firmware preparation (decrypt and extract).\n\n        Args:\n            device: ATDeviceInfo instance.\n            latest: Latest firmware version string.\n        \"\"\"\n        msg = f\"Firmware {latest} found in repository. Preparing...\"\n        self.logger.info(msg)\n        self.ui_updater.update_status(\"Device connected - Preparing cached firmware\")\n        self.ui_updater.update_progress_message(msg, \"info\")\n\n        self.download_in_progress = True\n        self.ui_updater.update_stop_button_state(self.download_in_progress, False)\n\n        try:\n            # Use cached firmware - will skip download\n            firmware, decrypted = download_and_decrypt(\n                device.model,\n                device.sales_code,\n                device.imei,\n                device.firmware_version,\n                version=latest,  # Pass version to avoid duplicate FOTA query\n                resume=True,\n                progress_cb=self.progress_callback,\n                stop_check=self.stop_check,\n            )\n\n            msg = f\"Cached firmware ready! Version: {firmware.version_code}\"\n            self.logger.info(\"%s decrypted to %s\", msg, decrypted)\n\n            # Extract firmware\n            self._extract_firmware(Path(decrypted), firmware.version_code)\n\n            self.ui_updater.update_status(\"Device connected\")\n            self.ui_updater.update_progress_message(msg, \"success\")\n            self.download_in_progress = False\n            self.ui_updater.update_stop_button_state(self.download_in_progress, False)\n\n        except RuntimeError as ex:\n            self._handle_runtime_error(ex)\n\n        except InformError.BadStatus as ex:\n            self._handle_fus_error(ex)\n\n    def _handle_firmware_download(self, device, latest: str) -&gt; None:\n        \"\"\"Handle firmware download, decrypt, and extract.\n\n        Args:\n            device: ATDeviceInfo instance.\n            latest: Latest firmware version string.\n        \"\"\"\n        self.download_in_progress = True\n        self.ui_updater.update_stop_button_state(self.download_in_progress, False)\n        self.logger.info(\"Downloading %s (current: %s)\", latest, device.firmware_version)\n        self.ui_updater.update_status(\"Device connected - Downloading firmware\")\n\n        try:\n            firmware, decrypted = download_and_decrypt(\n                device.model,\n                device.sales_code,\n                device.imei,\n                device.firmware_version,\n                version=latest,  # Pass version to avoid duplicate FOTA query\n                resume=True,\n                progress_cb=self.progress_callback,\n                stop_check=self.stop_check,\n            )\n\n            msg = f\"Download complete! Version: {firmware.version_code}\"\n            self.logger.info(\"%s saved to %s\", msg, decrypted)\n\n            # Extract firmware\n            self._extract_firmware(Path(decrypted), firmware.version_code)\n\n            self.ui_updater.update_status(\"Device connected\")\n            self.ui_updater.update_progress_message(msg, \"success\")\n            self.download_in_progress = False\n            self.ui_updater.update_stop_button_state(self.download_in_progress, False)\n\n        except RuntimeError as ex:\n            self._handle_runtime_error(ex)\n\n        except InformError.BadStatus as ex:\n            self._handle_fus_error(ex)\n\n    def _extract_firmware(self, decrypted_path: Path, version: str) -&gt; None:  # pylint: disable=unused-argument\n        \"\"\"Extract firmware ZIP file and populate component entries.\n\n        Optionally skips HOME_CSC files based on unzip_home_csc setting.\n\n        Args:\n            decrypted_path: Path to decrypted firmware file.\n            version: Firmware version string.\n        \"\"\"\n        try:\n            if decrypted_path.exists() and decrypted_path.suffix in [\".zip\", \".ZIP\"]:\n                self.ui_updater.update_status(\"Device connected - Extracting firmware\")\n                unzip_dir = decrypted_path.parent / decrypted_path.stem\n                unzip_dir.mkdir(parents=True, exist_ok=True)\n\n                with zipfile.ZipFile(decrypted_path, \"r\") as zip_ref:\n                    members = zip_ref.namelist()\n\n                    # Filter out HOME_CSC files if disabled\n                    if not self.unzip_home_csc:\n                        filtered_members = [m for m in members if not m.startswith(\"HOME_CSC_\")]\n                        skipped_count = len(members) - len(filtered_members)\n                        if skipped_count &gt; 0:\n                            self.logger.info(\"Skipping %d HOME_CSC files (unzip_home_csc=false)\", skipped_count)\n                        members = filtered_members\n\n                    total_files = len(members)\n                    for idx, member in enumerate(members, 1):\n                        if self.stop_check():\n                            raise RuntimeError(\"Extraction task stopped by user\")\n                        zip_ref.extract(member, unzip_dir)\n                        self.progress_callback(\"extract\", idx, total_files)\n\n                self.logger.info(\"Extracted firmware to %s\", unzip_dir)\n                self.ui_updater.populate_component_entries(unzip_dir)\n\n        except zipfile.BadZipFile:\n            self.logger.error(\"File is not a valid ZIP archive\")\n        except (OSError, IOError, ValueError) as ex:\n            self.logger.error(\"Extraction failed: %s\", ex)\n\n    def _handle_runtime_error(self, ex: RuntimeError) -&gt; None:\n        \"\"\"Handle runtime errors (typically user-stopped tasks).\n\n        Args:\n            ex: RuntimeError exception.\n        \"\"\"\n        if \"stopped\" in str(ex).lower():\n            self.logger.info(\"Task stopped: %s\", ex)\n            self.ui_updater.update_status(\"Device connected\")\n            self.ui_updater.update_progress_message(\"Task stopped\", \"warning\")\n        else:\n            self.logger.error(\"Runtime error: %s\", ex)\n            self.ui_updater.update_status(\"Device connected - Error\")\n            self.ui_updater.update_progress_message(\"Waiting for device\", \"info\")\n\n        self.download_in_progress = False\n        self.ui_updater.update_stop_button_state(self.download_in_progress, False)\n\n    def _handle_fus_error(self, ex: InformError.BadStatus) -&gt; None:\n        \"\"\"Handle FUS server errors.\n\n        Args:\n            ex: InformError.BadStatus exception.\n        \"\"\"\n        status_msg = str(ex)\n        if \"400\" in status_msg:\n            msg = \"Please update via OTA (Over-The-Air)\"\n            self.logger.warning(\"FUS error 400: Firmware not available\")\n            color = \"warning\"\n        elif \"408\" in status_msg:\n            msg = \"Invalid model, CSC, or IMEI. Please check device information\"\n            self.logger.error(\"FUS error 408: %s\", msg)\n            color = \"error\"\n        else:\n            msg = f\"FUS server error: {ex}\"\n            self.logger.error(msg)\n            color = \"error\"\n\n        self.ui_updater.update_status(\"Device connected\")\n        self.ui_updater.update_progress_message(msg, color)\n        self.download_in_progress = False\n        self.ui_updater.update_stop_button_state(self.download_in_progress, False)\n</code></pre>"},{"location":"api/app.device_monitor/#app.device_monitor.DeviceMonitor.start","title":"start","text":"Python<pre><code>start()\n</code></pre> <p>Start device monitoring loop (call from background thread).</p> Source code in <code>app/device_monitor.py</code> Python<pre><code>def start(self) -&gt; None:\n    \"\"\"Start device monitoring loop (call from background thread).\"\"\"\n    self.monitoring = True\n    self._monitor_loop()\n</code></pre>"},{"location":"api/app.device_monitor/#app.device_monitor.DeviceMonitor.stop","title":"stop","text":"Python<pre><code>stop()\n</code></pre> <p>Stop device monitoring.</p> Source code in <code>app/device_monitor.py</code> Python<pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop device monitoring.\"\"\"\n    self.monitoring = False\n</code></pre>"},{"location":"api/app.gui/","title":"app.gui","text":""},{"location":"api/app.gui/#app.gui","title":"app.gui","text":"<p>Main GUI application for Samsung Firmware Downloader.</p> <p>This module provides the main application window, coordinating UI components, device monitoring, and firmware operations.</p>"},{"location":"api/app.gui/#app.gui.FirmwareDownloaderApp","title":"FirmwareDownloaderApp","text":"<p>               Bases: <code>CTk</code></p> <p>Main application window for Samsung Firmware Downloader.</p> <p>Monitors for connected Samsung devices and automatically downloads firmware when a device is detected and firmware is available.</p> <p>Attributes:</p> Name Type Description <code>monitoring</code> <p>Flag indicating if device monitoring is active.</p> <code>download_in_progress</code> <p>Flag indicating if download is in progress.</p> <code>stop_task</code> <p>Flag to stop active download/decrypt/extract.</p> Source code in <code>app/gui.py</code> Python<pre><code>class FirmwareDownloaderApp(ctk.CTk):\n    \"\"\"Main application window for Samsung Firmware Downloader.\n\n    Monitors for connected Samsung devices and automatically downloads firmware\n    when a device is detected and firmware is available.\n\n    Attributes:\n        monitoring: Flag indicating if device monitoring is active.\n        download_in_progress: Flag indicating if download is in progress.\n        stop_task: Flag to stop active download/decrypt/extract.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the application window.\"\"\"\n        super().__init__()\n\n        # Initialize database\n        init_db()\n\n        # Setup logging\n        self._setup_logging()\n\n        # Log session ID from service\n        self.logger.info(\"Session ID: %s\", get_session_id())\n\n        # Load configuration\n        self.config = load_config()\n\n        # Window configuration\n        self.title(\"Samsung Firmware Downloader\")\n        self._set_app_icon()\n        self.geometry(\"1024x\")\n        self.minsize(1024, 0)\n\n        # Set appearance\n        ctk.set_appearance_mode(\"light\")\n        ctk.set_default_color_theme(\"blue\")\n\n        # State flags\n        self.monitoring = False\n        self.download_in_progress = False\n        self.stop_task = False\n        self.monitor_thread: Optional[threading.Thread] = None\n        self.startup_cleanup_done = False\n\n        # Initialize UI builder\n        self.ui_builder = UIBuilder(self, self.config)\n\n        # Run startup cleanup before building main UI\n        self._run_startup_cleanup()\n\n    def _run_startup_cleanup(self) -&gt; None:\n        \"\"\"Perform repository cleanup with splash progress before showing UI.\n\n        Creates a temporary frame with a progress bar and status label. The\n        main application widgets are only created after cleanup completes.\n        \"\"\"\n        # Create splash widgets\n        splash_widgets = self.ui_builder.create_splash_widgets()\n        self.splash_widgets = splash_widgets\n\n        # Run cleanup in background thread to keep UI responsive\n        threading.Thread(target=self._perform_cleanup, daemon=True).start()\n\n    def _set_app_icon(self) -&gt; None:\n        \"\"\"Configure the window/taskbar icon using importlib.resources.\n\n        Prefers `.ico` on Windows, otherwise falls back to a PNG.\n        Uses importlib.resources for reliable packaging.\n        \"\"\"\n        try:\n            icons = files('AppIcons') if files('AppIcons').is_dir() else None\n            if not icons:\n                return\n\n            if sys.platform.startswith(\"win\"):\n                # Help Windows taskbar use the same icon\n                try:\n                    ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(\"nanosamfw.GUI\")\n                except (AttributeError, OSError):\n                    # Ignore failure to set AppUserModelID; not critical for UI operation\n                    pass\n\n                # Try app_icon.ico or any .ico\n                ico_candidates = ['app_icon.ico'] + [f.name for f in icons.iterdir() if f.name.endswith('.ico')]\n                for ico_name in ico_candidates:\n                    try:\n                        ico_data = (icons / ico_name).read_bytes()\n                        # iconbitmap needs a file path, write to temp\n                        with tempfile.NamedTemporaryFile(suffix='.ico', delete=False) as tmp:\n                            tmp.write(ico_data)\n                            tmp_path = tmp.name\n                        self.iconbitmap(default=tmp_path)\n                        # Keep temp file reference for cleanup\n                        self._icon_tmp = tmp_path  # type: ignore[attr-defined]\n                        return\n                    except (KeyError, FileNotFoundError, tk.TclError, OSError):\n                        continue\n\n            # Non-Windows or fallback: use PNG\n            png_candidates = ['256.png', '128.png', '64.png', '32.png']\n            for png_name in png_candidates:\n                try:\n                    png_data = (icons / png_name).read_bytes()\n                    img = tk.PhotoImage(data=png_data)\n                    self.iconphoto(True, img)\n                    self._icon_img = img  # type: ignore[attr-defined]\n                    return\n                except (KeyError, FileNotFoundError, tk.TclError, OSError):\n                    continue\n\n        except (ImportError, tk.TclError, OSError, AttributeError):\n            # Never block UI due to icon issues\n            pass\n\n    def _perform_cleanup(self) -&gt; None:\n        \"\"\"Execute repository cleanup via download service and then build UI.\"\"\"\n\n        def progress_cb(processed: int, total: int, missing: int, deleted: int, dec_deleted: int):\n            pct = processed / total if total else 1.0\n            self.after(0, lambda v=pct: self.splash_widgets[\"cleanup_progress\"].set(v))\n            self.after(\n                0,\n                lambda: self.splash_widgets[\"cleanup_details\"].configure(\n                    text=(\n                        f\"Processed {processed}/{total} | Missing encrypted: {missing} | \"\n                        f\"Records deleted: {deleted} | Decrypted deleted: {dec_deleted}\"\n                    )\n                ),\n            )\n\n        # Start cleanup\n        self.after(0, lambda: self.splash_widgets[\"cleanup_status\"].configure(text=\"Cleaning repository...\"))\n        stats = cleanup_repository(progress_cb)\n        summary = (\n            f\"Cleanup complete. Inspected: {stats['total_records']} | Missing: {stats['missing_encrypted']} | \"\n            f\"Deleted: {stats['records_deleted']} | Decrypted removed: {stats['decrypted_deleted']}\"\n        )\n        self.after(0, lambda: self.splash_widgets[\"cleanup_status\"].configure(text=summary))\n        self.after(0, lambda: self.splash_widgets[\"cleanup_progress\"].set(1.0))\n        time.sleep(0.5)\n        self.after(0, self._finish_startup)\n\n    def _finish_startup(self) -&gt; None:\n        \"\"\"Destroy splash and build main application widgets.\"\"\"\n        if \"splash_frame\" in self.splash_widgets:\n            self.splash_widgets[\"splash_frame\"].destroy()\n        self._create_widgets()\n        self.startup_cleanup_done = True\n        # Auto-start monitoring after UI is ready\n        self.start_monitoring()\n\n    def _setup_logging(self):\n        \"\"\"Setup logging to file in data directory.\"\"\"\n        log_dir = PATHS.data_dir\n        log_dir.mkdir(parents=True, exist_ok=True)\n        log_file = log_dir / \"app.log\"\n\n        logging.basicConfig(\n            level=logging.INFO,\n            format=\"%(asctime)s - %(levelname)s - %(message)s\",\n            handlers=[\n                logging.FileHandler(log_file, mode=\"a\", encoding=\"utf-8\"),\n            ],\n        )\n        self.logger = logging.getLogger(__name__)\n        self.logger.info(\"=\" * 60)\n        self.logger.info(\"Application started\")\n\n    def _log(self, level: str, message: str):\n        \"\"\"Log message with timestamp.\n\n        Args:\n            level: Log level (info, warning, error).\n            message: Message to log.\n        \"\"\"\n        log_func = getattr(self.logger, level, self.logger.info)\n        log_func(message)\n\n    def _create_widgets(self):\n        \"\"\"Create and layout all UI widgets.\"\"\"\n        # pylint: disable=W0201  # Widgets initialized here after splash screen\n        # Create main widgets using UI builder\n        self.widgets = self.ui_builder.create_main_widgets(stop_callback=self.stop_current_task)\n\n        # Initialize UI updater with widget references\n        self.ui_updater = UIUpdater(self, self.widgets)\n\n        # Initialize progress tracker\n        def progress_ui_callback(stage: str, done: int, total: int, label: str):\n            self.ui_updater.update_progress_bar(stage, done, total, label)\n\n        self.progress_tracker = ProgressTracker(progress_ui_callback)\n\n        # Initialize device monitor\n        def progress_callback(stage: str, done: int, total: int):\n            self.progress_tracker.update_progress(stage, done, total)\n\n        def stop_check() -&gt; bool:\n            return self.stop_task\n\n        def disconnect_callback() -&gt; None:\n            # Reset stop flag when device disconnects\n            self.stop_task = False\n\n        csc_filter_list = self._parse_csc_filter()\n        self.device_monitor = DeviceMonitor(\n            self.ui_updater,\n            progress_callback,\n            stop_check,\n            disconnect_callback=disconnect_callback,\n            csc_filter=csc_filter_list,\n            unzip_home_csc=self.config.unzip_home_csc,\n        )\n\n        # Set initial placeholders\n        self.ui_updater.set_device_placeholders()\n\n    def start_monitoring(self):\n        \"\"\"Start device monitoring in background thread (auto-start).\"\"\"\n        if not self.monitoring:\n            self.monitoring = True\n            self.ui_updater.update_status(\"Monitoring for devices...\")\n            self.ui_updater.update_progress_message(\"Waiting for device\", \"info\")\n            self.monitor_thread = threading.Thread(target=self._run_monitor, daemon=True)\n            self.monitor_thread.start()\n\n    def _parse_csc_filter(self) -&gt; list[str]:\n        \"\"\"Parse CSC filter config into a list of uppercase codes.\n\n        Empty string = allow all devices\n        Comma-separated values = only allow those CSC codes\n\n        Returns:\n            List of uppercase CSC codes to allow, or empty list to allow all.\n        \"\"\"\n        if not getattr(self.config, \"csc_filter\", \"\"):\n            return []\n        return [c.strip().upper() for c in self.config.csc_filter.split(\",\") if c.strip()]\n\n    def _run_monitor(self):\n        \"\"\"Run device monitor in background thread.\"\"\"\n        self.device_monitor.start()\n\n    def stop_monitoring(self):  # pragma: no cover\n        \"\"\"Stop device monitoring.\"\"\"\n        self.monitoring = False\n        self.device_monitor.stop()\n        self.ui_updater.update_status(\"Monitoring stopped\")\n        self.ui_updater.update_progress_message(\"Monitoring stopped\", \"info\")\n\n    def stop_current_task(self):\n        \"\"\"Stop any active download, decrypt, or extract task.\n\n        Device monitoring remains active. The stop flag is checked in download loops.\n        \"\"\"\n        if self.device_monitor.download_in_progress:\n            self._log(\"info\", \"User requested task stop\")\n            self.stop_task = True\n            self.ui_updater.update_status(\"Stopping task...\")\n\n    def run(self):\n        \"\"\"Start the application main loop.\"\"\"\n        self.mainloop()\n</code></pre>"},{"location":"api/app.gui/#app.gui.FirmwareDownloaderApp.start_monitoring","title":"start_monitoring","text":"Python<pre><code>start_monitoring()\n</code></pre> <p>Start device monitoring in background thread (auto-start).</p> Source code in <code>app/gui.py</code> Python<pre><code>def start_monitoring(self):\n    \"\"\"Start device monitoring in background thread (auto-start).\"\"\"\n    if not self.monitoring:\n        self.monitoring = True\n        self.ui_updater.update_status(\"Monitoring for devices...\")\n        self.ui_updater.update_progress_message(\"Waiting for device\", \"info\")\n        self.monitor_thread = threading.Thread(target=self._run_monitor, daemon=True)\n        self.monitor_thread.start()\n</code></pre>"},{"location":"api/app.gui/#app.gui.FirmwareDownloaderApp.stop_monitoring","title":"stop_monitoring","text":"Python<pre><code>stop_monitoring()\n</code></pre> <p>Stop device monitoring.</p> Source code in <code>app/gui.py</code> Python<pre><code>def stop_monitoring(self):  # pragma: no cover\n    \"\"\"Stop device monitoring.\"\"\"\n    self.monitoring = False\n    self.device_monitor.stop()\n    self.ui_updater.update_status(\"Monitoring stopped\")\n    self.ui_updater.update_progress_message(\"Monitoring stopped\", \"info\")\n</code></pre>"},{"location":"api/app.gui/#app.gui.FirmwareDownloaderApp.stop_current_task","title":"stop_current_task","text":"Python<pre><code>stop_current_task()\n</code></pre> <p>Stop any active download, decrypt, or extract task.</p> <p>Device monitoring remains active. The stop flag is checked in download loops.</p> Source code in <code>app/gui.py</code> Python<pre><code>def stop_current_task(self):\n    \"\"\"Stop any active download, decrypt, or extract task.\n\n    Device monitoring remains active. The stop flag is checked in download loops.\n    \"\"\"\n    if self.device_monitor.download_in_progress:\n        self._log(\"info\", \"User requested task stop\")\n        self.stop_task = True\n        self.ui_updater.update_status(\"Stopping task...\")\n</code></pre>"},{"location":"api/app.gui/#app.gui.FirmwareDownloaderApp.run","title":"run","text":"Python<pre><code>run()\n</code></pre> <p>Start the application main loop.</p> Source code in <code>app/gui.py</code> Python<pre><code>def run(self):\n    \"\"\"Start the application main loop.\"\"\"\n    self.mainloop()\n</code></pre>"},{"location":"api/app.gui/#app.gui.main","title":"main","text":"Python<pre><code>main()\n</code></pre> <p>Entry point for the GUI application.</p> Source code in <code>app/gui.py</code> Python<pre><code>def main():\n    \"\"\"Entry point for the GUI application.\"\"\"\n    app = FirmwareDownloaderApp()\n    app.run()\n</code></pre>"},{"location":"api/app.progress_tracker/","title":"app.progress_tracker","text":""},{"location":"api/app.progress_tracker/#app.progress_tracker","title":"app.progress_tracker","text":"<p>Progress tracking and calculation for firmware operations.</p> <p>This module handles progress state management, throttling, ETA calculations, and throughput monitoring for download, decrypt, and extract operations.</p>"},{"location":"api/app.progress_tracker/#app.progress_tracker.ProgressTracker","title":"ProgressTracker","text":"<p>Tracks progress for multi-stage firmware operations.</p> <p>Manages progress state, throttles UI updates, and calculates ETAs and throughput for download, decrypt, and extract stages.</p> <p>Attributes:</p> Name Type Description <code>update_callback</code> <p>Callback function(stage, done, total, label) for UI updates.</p> Source code in <code>app/progress_tracker.py</code> Python<pre><code>class ProgressTracker:\n    \"\"\"Tracks progress for multi-stage firmware operations.\n\n    Manages progress state, throttles UI updates, and calculates ETAs and\n    throughput for download, decrypt, and extract stages.\n\n    Attributes:\n        update_callback: Callback function(stage, done, total, label) for UI updates.\n    \"\"\"\n\n    def __init__(self, update_callback: Callable[[str, int, int, str], None]):\n        \"\"\"Initialize progress tracker.\n\n        Args:\n            update_callback: Function to call with progress updates.\n                Signature: (stage: str, done: int, total: int, label: str) -&gt; None\n        \"\"\"\n        self.update_callback = update_callback\n        self._last_progress_time: float = 0.0\n        self._last_progress_pct: dict[str, float] = {\n            \"download\": 0.0,\n            \"decrypt\": 0.0,\n            \"extract\": 0.0,\n        }\n        self._stage_start_time: dict[str, float] = {}\n        self._stage_last_done: dict[str, int] = {}\n\n    def update_progress(self, stage: str, done: int, total: int) -&gt; None:\n        \"\"\"Update progress for a specific stage.\n\n        Throttles updates to avoid overwhelming the UI. Updates are pushed when:\n        - Task completes (done &gt;= total)\n        - Progress changes by &gt;= 1%\n        - At least 100ms has elapsed since last update\n\n        Args:\n            stage: Stage name (\"download\", \"decrypt\", or \"extract\").\n            done: Bytes or files processed so far.\n            total: Total bytes or files for stage.\n        \"\"\"\n        # Throttle UI updates to avoid massive Tk event queue and slowdowns\n        now = time.monotonic()\n        last_time = self._last_progress_time\n        last_pct = self._last_progress_pct.get(stage, 0.0)\n\n        pct = done / total if total &gt; 0 else 0.0\n        pct_delta = pct - last_pct\n\n        # Conditions to push an update:\n        # - Completion\n        # - Significant visual change (&gt;= 1%)\n        # - Or at least every 100ms\n        should_update = done &gt;= total or pct_delta &gt;= 0.01 or (now - last_time) &gt;= 0.1\n\n        if not should_update:\n            return\n\n        # Record last update markers\n        self._last_progress_time = now\n        self._last_progress_pct[stage] = pct\n\n        # Initialize/reset per-stage timers if needed (new stage or restart)\n        last_done = self._stage_last_done.get(stage, -1)\n        if stage not in self._stage_start_time or done &lt; last_done:\n            self._stage_start_time[stage] = now\n        self._stage_last_done[stage] = done\n\n        mb_done = done / (1024 * 1024)\n        mb_total = total / (1024 * 1024)\n        elapsed = max(0.0, now - self._stage_start_time.get(stage, now))\n        speed_bps = (done / elapsed) if elapsed &gt; 0.0 else 0.0\n        speed_mbps = speed_bps / (1024 * 1024)\n\n        # Compute ETA based on current average speed\n        eta_secs = ((total - done) / speed_bps) if (speed_bps &gt; 0 and total &gt; 0) else None\n        eta_str = self._format_eta(eta_secs)\n        elapsed_str = self._format_duration(elapsed)\n\n        if stage == \"extract\":\n            # Extract stage uses file count, not bytes\n            prefix = \"Extracting\"\n            label = f\"{prefix}: {done} / {total} files \u2022 Elapsed {elapsed_str} \u2022 ETA {eta_str}\"\n        else:\n            prefix = \"Downloading\" if stage == \"download\" else \"Decrypting\"\n            if speed_mbps &gt; 0:\n                label = (\n                    f\"{prefix}: {mb_done:.1f} MB / {mb_total:.1f} MB \u2022 \"\n                    f\"{speed_mbps:.1f} MB/s \u2022 Elapsed {elapsed_str} \u2022 ETA {eta_str}\"\n                )\n            else:\n                label = f\"{prefix}: {mb_done:.1f} MB / {mb_total:.1f} MB \u2022 Elapsed {elapsed_str}\"\n\n        # Call the UI update callback\n        self.update_callback(stage, done, total, label)\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset all progress state for new operation.\"\"\"\n        self._last_progress_time = 0.0\n        self._last_progress_pct = {\n            \"download\": 0.0,\n            \"decrypt\": 0.0,\n            \"extract\": 0.0,\n        }\n        self._stage_start_time.clear()\n        self._stage_last_done.clear()\n\n    @staticmethod\n    def _format_eta(sec: float | None) -&gt; str:\n        \"\"\"Format ETA seconds as HH:MM:SS or MM:SS.\n\n        Args:\n            sec: Seconds remaining, or None if unknown.\n\n        Returns:\n            Formatted ETA string or \"--:--\" if unknown.\n        \"\"\"\n        if sec is None:\n            return \"--:--\"\n        sec_i = int(sec)\n        h, r = divmod(sec_i, 3600)\n        m, s = divmod(r, 60)\n        if h:\n            return f\"{h:d}:{m:02d}:{s:02d}\"\n        return f\"{m:d}:{s:02d}\"\n\n    @staticmethod\n    def _format_duration(sec: float) -&gt; str:\n        \"\"\"Format elapsed seconds as HH:MM:SS or MM:SS.\n\n        Args:\n            sec: Elapsed seconds.\n\n        Returns:\n            Formatted duration string.\n        \"\"\"\n        sec_i = int(sec)\n        h, r = divmod(sec_i, 3600)\n        m, s = divmod(r, 60)\n        if h:\n            return f\"{h:d}:{m:02d}:{s:02d}\"\n        return f\"{m:d}:{s:02d}\"\n</code></pre>"},{"location":"api/app.progress_tracker/#app.progress_tracker.ProgressTracker.update_progress","title":"update_progress","text":"Python<pre><code>update_progress(stage, done, total)\n</code></pre> <p>Update progress for a specific stage.</p> <p>Throttles updates to avoid overwhelming the UI. Updates are pushed when: - Task completes (done &gt;= total) - Progress changes by &gt;= 1% - At least 100ms has elapsed since last update</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>Stage name (\"download\", \"decrypt\", or \"extract\").</p> required <code>done</code> <code>int</code> <p>Bytes or files processed so far.</p> required <code>total</code> <code>int</code> <p>Total bytes or files for stage.</p> required Source code in <code>app/progress_tracker.py</code> Python<pre><code>def update_progress(self, stage: str, done: int, total: int) -&gt; None:\n    \"\"\"Update progress for a specific stage.\n\n    Throttles updates to avoid overwhelming the UI. Updates are pushed when:\n    - Task completes (done &gt;= total)\n    - Progress changes by &gt;= 1%\n    - At least 100ms has elapsed since last update\n\n    Args:\n        stage: Stage name (\"download\", \"decrypt\", or \"extract\").\n        done: Bytes or files processed so far.\n        total: Total bytes or files for stage.\n    \"\"\"\n    # Throttle UI updates to avoid massive Tk event queue and slowdowns\n    now = time.monotonic()\n    last_time = self._last_progress_time\n    last_pct = self._last_progress_pct.get(stage, 0.0)\n\n    pct = done / total if total &gt; 0 else 0.0\n    pct_delta = pct - last_pct\n\n    # Conditions to push an update:\n    # - Completion\n    # - Significant visual change (&gt;= 1%)\n    # - Or at least every 100ms\n    should_update = done &gt;= total or pct_delta &gt;= 0.01 or (now - last_time) &gt;= 0.1\n\n    if not should_update:\n        return\n\n    # Record last update markers\n    self._last_progress_time = now\n    self._last_progress_pct[stage] = pct\n\n    # Initialize/reset per-stage timers if needed (new stage or restart)\n    last_done = self._stage_last_done.get(stage, -1)\n    if stage not in self._stage_start_time or done &lt; last_done:\n        self._stage_start_time[stage] = now\n    self._stage_last_done[stage] = done\n\n    mb_done = done / (1024 * 1024)\n    mb_total = total / (1024 * 1024)\n    elapsed = max(0.0, now - self._stage_start_time.get(stage, now))\n    speed_bps = (done / elapsed) if elapsed &gt; 0.0 else 0.0\n    speed_mbps = speed_bps / (1024 * 1024)\n\n    # Compute ETA based on current average speed\n    eta_secs = ((total - done) / speed_bps) if (speed_bps &gt; 0 and total &gt; 0) else None\n    eta_str = self._format_eta(eta_secs)\n    elapsed_str = self._format_duration(elapsed)\n\n    if stage == \"extract\":\n        # Extract stage uses file count, not bytes\n        prefix = \"Extracting\"\n        label = f\"{prefix}: {done} / {total} files \u2022 Elapsed {elapsed_str} \u2022 ETA {eta_str}\"\n    else:\n        prefix = \"Downloading\" if stage == \"download\" else \"Decrypting\"\n        if speed_mbps &gt; 0:\n            label = (\n                f\"{prefix}: {mb_done:.1f} MB / {mb_total:.1f} MB \u2022 \"\n                f\"{speed_mbps:.1f} MB/s \u2022 Elapsed {elapsed_str} \u2022 ETA {eta_str}\"\n            )\n        else:\n            label = f\"{prefix}: {mb_done:.1f} MB / {mb_total:.1f} MB \u2022 Elapsed {elapsed_str}\"\n\n    # Call the UI update callback\n    self.update_callback(stage, done, total, label)\n</code></pre>"},{"location":"api/app.progress_tracker/#app.progress_tracker.ProgressTracker.reset","title":"reset","text":"Python<pre><code>reset()\n</code></pre> <p>Reset all progress state for new operation.</p> Source code in <code>app/progress_tracker.py</code> Python<pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset all progress state for new operation.\"\"\"\n    self._last_progress_time = 0.0\n    self._last_progress_pct = {\n        \"download\": 0.0,\n        \"decrypt\": 0.0,\n        \"extract\": 0.0,\n    }\n    self._stage_start_time.clear()\n    self._stage_last_done.clear()\n</code></pre>"},{"location":"api/app.ui_builder/","title":"app.ui_builder","text":""},{"location":"api/app.ui_builder/#app.ui_builder","title":"app.ui_builder","text":"<p>UI widget creation and layout for the GUI application.</p> <p>This module handles creation of all UI frames, widgets, and their layout configuration using customtkinter.</p>"},{"location":"api/app.ui_builder/#app.ui_builder.UIBuilder","title":"UIBuilder","text":"<p>Builds and configures all UI widgets for the application.</p> <p>Attributes:</p> Name Type Description <code>root</code> <p>Root window for widget creation.</p> <code>config</code> <p>Application configuration.</p> <code>logger</code> <p>Logger instance.</p> Source code in <code>app/ui_builder.py</code> Python<pre><code>class UIBuilder:\n    \"\"\"Builds and configures all UI widgets for the application.\n\n    Attributes:\n        root: Root window for widget creation.\n        config: Application configuration.\n        logger: Logger instance.\n    \"\"\"\n\n    def __init__(self, root: ctk.CTk, config: AppConfig):\n        \"\"\"Initialize UI builder.\n\n        Args:\n            root: Root CTk window.\n            config: Application configuration.\n        \"\"\"\n        self.root = root\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n\n    def create_main_widgets(self, stop_callback: Callable[[], None]) -&gt; dict:\n        \"\"\"Create and layout all main application widgets.\n\n        Args:\n            stop_callback: Callback function for stop button clicks.\n\n        Returns:\n            Dictionary containing all widget references.\n        \"\"\"\n        widgets = {}\n\n        # Main container with padding\n        main_frame = ctk.CTkFrame(self.root)\n        main_frame.pack(fill=\"both\", expand=True, padx=5, pady=5)\n\n        # Title\n        # title_label = ctk.CTkLabel(\n        #     main_frame,\n        #     text=\"Samsung Firmware Downloader\",\n        #     font=ctk.CTkFont(size=24, weight=\"bold\"),\n        # )\n        # title_label.pack(pady=(0, 20))\n\n        # Create all sub-frames\n        self._create_status_frame(main_frame, widgets)\n        self._create_device_info_frame(main_frame, widgets)\n        self._create_progress_frame(main_frame, widgets, stop_callback)\n        self._create_components_frame(main_frame, widgets)\n        self._create_settings_frame(main_frame, widgets)\n\n        return widgets\n\n    def _create_status_frame(self, parent, widgets: dict) -&gt; None:\n        \"\"\"Create status display frame.\n\n        Args:\n            parent: Parent widget.\n            widgets: Widget dictionary to populate.\n        \"\"\"\n        status_frame = ctk.CTkFrame(parent)\n        status_frame.pack(fill=\"x\", padx=5, pady=5)\n\n        ctk.CTkLabel(status_frame, text=\"Status:\", font=ctk.CTkFont(size=14, weight=\"bold\")).pack(\n            anchor=\"w\", padx=10, pady=(10, 5)\n        )\n\n        status_label = ctk.CTkLabel(\n            status_frame,\n            text=\"Stopped. Press 'Start Monitoring' to begin device detection\",\n            font=ctk.CTkFont(size=12),\n        )\n        status_label.pack(anchor=\"w\", padx=10, pady=(0, 10))\n        widgets[\"status_label\"] = status_label\n\n    def _create_device_info_frame(self, parent, widgets: dict) -&gt; None:\n        \"\"\"Create device information frame with entries.\n\n        Args:\n            parent: Parent widget.\n            widgets: Widget dictionary to populate.\n        \"\"\"\n        device_frame = ctk.CTkFrame(parent)\n        device_frame.pack(fill=\"x\", padx=5, pady=(0, 5))\n\n        ctk.CTkLabel(device_frame, text=\"Device Information:\", font=ctk.CTkFont(size=14, weight=\"bold\")).pack(\n            anchor=\"w\", padx=10, pady=(10, 5)\n        )\n\n        # Grid for entries\n        entries_frame = ctk.CTkFrame(device_frame)\n        entries_frame.pack(fill=\"x\", padx=10, pady=(0, 10))\n\n        def _make_full_row(row: int, label: str) -&gt; ctk.CTkEntry:\n            ctk.CTkLabel(entries_frame, text=label, font=ctk.CTkFont(size=12, weight=\"bold\")).grid(\n                row=row, column=0, sticky=\"w\", padx=4, pady=4\n            )\n            entry = ctk.CTkEntry(entries_frame, font=ctk.CTkFont(size=12))\n            entry.grid(row=row, column=1, columnspan=5, sticky=\"ew\", padx=(10, 4), pady=4)\n            entry.configure(state=\"disabled\")\n            return entry\n\n        def _make_col(row: int, col: int, label: str) -&gt; ctk.CTkEntry:\n            ctk.CTkLabel(entries_frame, text=label, font=ctk.CTkFont(size=12, weight=\"bold\")).grid(\n                row=row, column=col * 2, sticky=\"w\", pady=4, padx=(10, 0) if col &gt; 0 else 4\n            )\n            entry = ctk.CTkEntry(entries_frame, font=ctk.CTkFont(size=12))\n            entry.grid(row=row, column=col * 2 + 1, sticky=\"ew\", padx=(10, 4), pady=4)\n            entry.configure(state=\"disabled\")\n            return entry\n\n        # Configure columns for equal width\n        entries_frame.grid_columnconfigure(1, weight=1)\n        entries_frame.grid_columnconfigure(3, weight=1)\n        entries_frame.grid_columnconfigure(5, weight=1)\n\n        widgets[\"model_entry\"] = _make_full_row(0, \"Model\")\n        widgets[\"firmware_entry\"] = _make_full_row(1, \"Firmware\")\n        widgets[\"region_entry\"] = _make_col(2, 0, \"Region/CSC\")\n        widgets[\"aid_entry\"] = _make_col(2, 1, \"AID\")\n        widgets[\"cc_entry\"] = _make_col(2, 2, \"CC\")\n        widgets[\"imei_entry\"] = _make_full_row(3, \"IMEI\")\n\n    def _create_progress_frame(self, parent, widgets: dict, stop_callback) -&gt; None:\n        \"\"\"Create progress display frame.\n\n        Args:\n            parent: Parent widget.\n            widgets: Widget dictionary to populate.\n            stop_callback: Callback for stop button.\n        \"\"\"\n        progress_frame = ctk.CTkFrame(parent)\n        progress_frame.pack(fill=\"x\", padx=5, pady=(0, 5))\n\n        ctk.CTkLabel(progress_frame, text=\"Progress:\", font=ctk.CTkFont(size=14, weight=\"bold\")).pack(\n            anchor=\"w\", padx=10, pady=(10, 5)\n        )\n\n        # Container for progress bar and stop button\n        progress_bar_container = ctk.CTkFrame(progress_frame, fg_color=\"transparent\")\n        progress_bar_container.pack(fill=\"x\", padx=10, pady=(0, 10))\n        progress_bar_container.pack_forget()  # Hidden by default\n        widgets[\"progress_bar_container\"] = progress_bar_container\n\n        # Progress bar frame (left side, expandable)\n        progress_bar_frame = ctk.CTkFrame(progress_bar_container, fg_color=\"transparent\")\n        progress_bar_frame.pack(side=\"left\", fill=\"both\", expand=True, padx=(0, 10))\n\n        download_progress_bar = ctk.CTkProgressBar(progress_bar_frame)\n        download_progress_bar.pack(fill=\"x\", pady=(0, 2))\n        download_progress_bar.set(0)\n        widgets[\"download_progress_bar\"] = download_progress_bar\n\n        download_progress_label = ctk.CTkLabel(progress_bar_frame, text=\"\", font=ctk.CTkFont(size=11))\n        download_progress_label.pack(anchor=\"w\")\n        widgets[\"download_progress_label\"] = download_progress_label\n\n        # Stop button (right side, fixed width)\n        stop_button = ctk.CTkButton(\n            progress_bar_container,\n            text=\"Stop Task\",\n            font=ctk.CTkFont(size=12, weight=\"bold\"),\n            fg_color=\"#FF453A\",\n            hover_color=\"#E0342F\",\n            command=stop_callback,\n            width=100,\n            bg_color=\"transparent\",\n        )\n        stop_button.pack(side=\"right\")\n        widgets[\"stop_button\"] = stop_button\n\n        # Message label for highlighted text\n        progress_message = ctk.CTkLabel(\n            progress_frame,\n            text=\"Waiting for device\",\n            font=ctk.CTkFont(size=14, weight=\"bold\"),\n            fg_color=(\"#3B8ED0\", \"#1F6AA5\"),\n            corner_radius=8,\n            height=40,\n        )\n        progress_message.pack(fill=\"x\", padx=10, pady=(0, 10))\n        widgets[\"progress_message\"] = progress_message\n\n    def _create_components_frame(self, parent, widgets: dict) -&gt; None:\n        \"\"\"Create firmware components frame.\n\n        Args:\n            parent: Parent widget.\n            widgets: Widget dictionary to populate.\n        \"\"\"\n        components_frame = ctk.CTkFrame(parent)\n        components_frame.pack(fill=\"x\", padx=5, pady=(0, 5))\n\n        ctk.CTkLabel(components_frame, text=\"Firmware Components:\", font=ctk.CTkFont(size=14, weight=\"bold\")).pack(\n            anchor=\"w\", padx=10, pady=(10, 5)\n        )\n\n        # Grid for component entries\n        comp_entries_frame = ctk.CTkFrame(components_frame)\n        comp_entries_frame.pack(fill=\"x\", padx=10, pady=(0, 10))\n\n        def _make_comp_row(row: int, label: str, *, hidden: bool = False) -&gt; ctk.CTkEntry:\n            label_widget = ctk.CTkLabel(\n                comp_entries_frame,\n                text=label,\n                font=ctk.CTkFont(size=12, weight=\"bold\"),\n                cursor=\"hand2\" if not hidden else \"\",\n            )\n            label_widget.grid(row=row, column=0, sticky=\"w\", padx=4, pady=4)\n            entry = ctk.CTkEntry(comp_entries_frame, font=ctk.CTkFont(size=11))\n            entry.grid(row=row, column=1, sticky=\"ew\", padx=(10, 4), pady=4)\n            comp_entries_frame.grid_columnconfigure(1, weight=1)\n            entry.configure(state=\"disabled\")\n            original_fg = entry.cget(\"fg_color\")\n\n            # Make label clickable to copy entry value to clipboard\n            def _copy_to_clipboard(_e):\n                value = entry.get()\n                if value and value != \"-\":\n                    try:\n                        pyperclip.copy(value)\n                        self.logger.info(\"Copied %s path to clipboard: %s\", label, value)\n                        # Brief visual feedback\n                        entry.configure(fg_color=\"#2CC985\")\n                        self.root.after(1000, lambda: entry.configure(fg_color=original_fg))\n                    except (OSError, RuntimeError) as ex:\n                        self.logger.error(\"Failed to copy to clipboard: %s\", ex)\n\n            if not hidden:\n                label_widget.bind(\"&lt;Button-1&gt;\", _copy_to_clipboard)\n                entry.bind(\"&lt;Button-1&gt;\", _copy_to_clipboard)\n            else:\n                # Hide the widgets but keep them instantiated\n                label_widget.grid_remove()\n                entry.grid_remove()\n\n            return entry\n\n        widgets[\"ap_entry\"] = _make_comp_row(0, \"BL\")\n        widgets[\"bl_entry\"] = _make_comp_row(1, \"AP\")\n        widgets[\"cp_entry\"] = _make_comp_row(2, \"CP\")\n        widgets[\"csc_entry\"] = _make_comp_row(3, \"CSC\")\n        widgets[\"home_entry\"] = _make_comp_row(4, \"HOME\", hidden=True)\n\n    def _create_settings_frame(self, parent, widgets: dict) -&gt; None:\n        \"\"\"Create settings frame with checkboxes.\n\n        Args:\n            parent: Parent widget.\n            widgets: Widget dictionary to populate.\n        \"\"\"\n        settings_frame = ctk.CTkFrame(parent)\n        settings_frame.pack(fill=\"x\", padx=5, pady=(0, 5))\n\n        # Horizontal container\n        settings_container = ctk.CTkFrame(settings_frame, fg_color=\"transparent\")\n        settings_container.pack(fill=\"x\", padx=10, pady=10)\n\n        # Dry run checkbox\n        dryrun_checkbox = ctk.CTkCheckBox(\n            settings_container,\n            text=\"Dry run\",\n            font=ctk.CTkFont(size=12),\n        )\n        if not self.config.btn_dryrun:\n            dryrun_checkbox.configure(state=\"disabled\")\n        dryrun_checkbox.pack(side=\"left\", padx=(0, 20))\n        widgets[\"dryrun_checkbox\"] = dryrun_checkbox\n\n        # Auto FUS Mode checkbox\n        autofus_checkbox = ctk.CTkCheckBox(\n            settings_container,\n            text=\"Auto FUS Mode\",\n            font=ctk.CTkFont(size=12),\n        )\n        if self.config.auto_fusmode:\n            autofus_checkbox.select()\n            autofus_checkbox.configure(state=\"disabled\")\n        elif not self.config.btn_autofus:\n            autofus_checkbox.configure(state=\"disabled\")\n        autofus_checkbox.pack(side=\"left\", padx=(0, 20))\n        widgets[\"autofus_checkbox\"] = autofus_checkbox\n\n        # CSC Filter label\n        csc_label_text = f\"CSC Filter: {self.config.csc_filter}\" if self.config.csc_filter else \"CSC Filter: (none)\"\n        csc_filter_label = ctk.CTkLabel(\n            settings_container,\n            text=csc_label_text,\n            font=ctk.CTkFont(size=12),\n        )\n        csc_filter_label.pack(side=\"left\", padx=(0, 20))\n        widgets[\"csc_filter_label\"] = csc_filter_label\n\n    def create_splash_widgets(self) -&gt; dict:\n        \"\"\"Create splash screen widgets for startup cleanup.\n\n        Returns:\n            Dictionary containing splash widget references.\n        \"\"\"\n        widgets = {}\n\n        splash_frame = ctk.CTkFrame(self.root)\n        splash_frame.pack(fill=\"both\", expand=True, padx=40, pady=40)\n        widgets[\"splash_frame\"] = splash_frame\n\n        title = ctk.CTkLabel(\n            splash_frame,\n            text=\"Initializing Repository\",\n            font=ctk.CTkFont(size=26, weight=\"bold\"),\n        )\n        title.pack(pady=(0, 30))\n\n        cleanup_status = ctk.CTkLabel(\n            splash_frame,\n            text=\"Scanning firmware records...\",\n            font=ctk.CTkFont(size=14),\n            justify=\"left\",\n        )\n        cleanup_status.pack(fill=\"x\", pady=(0, 20))\n        widgets[\"cleanup_status\"] = cleanup_status\n\n        cleanup_progress = ctk.CTkProgressBar(splash_frame)\n        cleanup_progress.pack(fill=\"x\", pady=(0, 10))\n        cleanup_progress.set(0)\n        widgets[\"cleanup_progress\"] = cleanup_progress\n\n        cleanup_details = ctk.CTkLabel(\n            splash_frame,\n            text=\"\",\n            font=ctk.CTkFont(size=12),\n            justify=\"left\",\n        )\n        cleanup_details.pack(fill=\"x\", pady=(0, 10))\n        widgets[\"cleanup_details\"] = cleanup_details\n\n        return widgets\n</code></pre>"},{"location":"api/app.ui_builder/#app.ui_builder.UIBuilder.create_main_widgets","title":"create_main_widgets","text":"Python<pre><code>create_main_widgets(stop_callback)\n</code></pre> <p>Create and layout all main application widgets.</p> <p>Parameters:</p> Name Type Description Default <code>stop_callback</code> <code>Callable[[], None]</code> <p>Callback function for stop button clicks.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing all widget references.</p> Source code in <code>app/ui_builder.py</code> Python<pre><code>def create_main_widgets(self, stop_callback: Callable[[], None]) -&gt; dict:\n    \"\"\"Create and layout all main application widgets.\n\n    Args:\n        stop_callback: Callback function for stop button clicks.\n\n    Returns:\n        Dictionary containing all widget references.\n    \"\"\"\n    widgets = {}\n\n    # Main container with padding\n    main_frame = ctk.CTkFrame(self.root)\n    main_frame.pack(fill=\"both\", expand=True, padx=5, pady=5)\n\n    # Title\n    # title_label = ctk.CTkLabel(\n    #     main_frame,\n    #     text=\"Samsung Firmware Downloader\",\n    #     font=ctk.CTkFont(size=24, weight=\"bold\"),\n    # )\n    # title_label.pack(pady=(0, 20))\n\n    # Create all sub-frames\n    self._create_status_frame(main_frame, widgets)\n    self._create_device_info_frame(main_frame, widgets)\n    self._create_progress_frame(main_frame, widgets, stop_callback)\n    self._create_components_frame(main_frame, widgets)\n    self._create_settings_frame(main_frame, widgets)\n\n    return widgets\n</code></pre>"},{"location":"api/app.ui_builder/#app.ui_builder.UIBuilder.create_splash_widgets","title":"create_splash_widgets","text":"Python<pre><code>create_splash_widgets()\n</code></pre> <p>Create splash screen widgets for startup cleanup.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing splash widget references.</p> Source code in <code>app/ui_builder.py</code> Python<pre><code>def create_splash_widgets(self) -&gt; dict:\n    \"\"\"Create splash screen widgets for startup cleanup.\n\n    Returns:\n        Dictionary containing splash widget references.\n    \"\"\"\n    widgets = {}\n\n    splash_frame = ctk.CTkFrame(self.root)\n    splash_frame.pack(fill=\"both\", expand=True, padx=40, pady=40)\n    widgets[\"splash_frame\"] = splash_frame\n\n    title = ctk.CTkLabel(\n        splash_frame,\n        text=\"Initializing Repository\",\n        font=ctk.CTkFont(size=26, weight=\"bold\"),\n    )\n    title.pack(pady=(0, 30))\n\n    cleanup_status = ctk.CTkLabel(\n        splash_frame,\n        text=\"Scanning firmware records...\",\n        font=ctk.CTkFont(size=14),\n        justify=\"left\",\n    )\n    cleanup_status.pack(fill=\"x\", pady=(0, 20))\n    widgets[\"cleanup_status\"] = cleanup_status\n\n    cleanup_progress = ctk.CTkProgressBar(splash_frame)\n    cleanup_progress.pack(fill=\"x\", pady=(0, 10))\n    cleanup_progress.set(0)\n    widgets[\"cleanup_progress\"] = cleanup_progress\n\n    cleanup_details = ctk.CTkLabel(\n        splash_frame,\n        text=\"\",\n        font=ctk.CTkFont(size=12),\n        justify=\"left\",\n    )\n    cleanup_details.pack(fill=\"x\", pady=(0, 10))\n    widgets[\"cleanup_details\"] = cleanup_details\n\n    return widgets\n</code></pre>"},{"location":"api/app.ui_updater/","title":"app.ui_updater","text":""},{"location":"api/app.ui_updater/#app.ui_updater","title":"app.ui_updater","text":"<p>Thread-safe UI update helpers for the GUI application.</p> <p>This module provides helper functions for updating UI widgets from background threads using Tkinter's after() mechanism for thread safety.</p>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater","title":"UIUpdater","text":"<p>Manages thread-safe updates to UI widgets.</p> <p>All methods use the Tkinter after() mechanism to ensure updates happen on the main UI thread, avoiding race conditions.</p> <p>Attributes:</p> Name Type Description <code>root</code> <p>Root Tkinter window for scheduling updates.</p> <code>widgets</code> <p>Dictionary of widget references.</p> <code>logger</code> <p>Logger instance for operation logging.</p> Source code in <code>app/ui_updater.py</code> Python<pre><code>class UIUpdater:\n    \"\"\"Manages thread-safe updates to UI widgets.\n\n    All methods use the Tkinter after() mechanism to ensure updates\n    happen on the main UI thread, avoiding race conditions.\n\n    Attributes:\n        root: Root Tkinter window for scheduling updates.\n        widgets: Dictionary of widget references.\n        logger: Logger instance for operation logging.\n    \"\"\"\n\n    def __init__(self, root: \"Tk\", widgets: dict):\n        \"\"\"Initialize UI updater.\n\n        Args:\n            root: Root Tkinter window for after() scheduling.\n            widgets: Dictionary containing all widget references.\n        \"\"\"\n        self.root = root\n        self.widgets = widgets\n        self.logger = logging.getLogger(__name__)\n\n    def update_status(self, message: str) -&gt; None:\n        \"\"\"Update status label with thread-safe scheduling.\n\n        Args:\n            message: Status message to display.\n        \"\"\"\n        self.root.after(0, lambda: self.widgets[\"status_label\"].configure(text=message))\n\n    def update_device_fields(\n        self, model: str, firmware: str, region: str, imei: str, aid: str = \"-\", cc: str = \"-\"\n    ) -&gt; None:\n        \"\"\"Update device info entries (read-only display).\n\n        Args:\n            model: Device model.\n            firmware: Firmware version.\n            region: Region/CSC code.\n            imei: IMEI string.\n            aid: Application ID.\n            cc: Country Code.\n        \"\"\"\n\n        def _set(e: ctk.CTkEntry, text: str):\n            e.configure(state=\"normal\")\n            e.delete(0, \"end\")\n            e.insert(0, text)\n            e.configure(state=\"disabled\")\n\n        def _update():\n            _set(self.widgets[\"model_entry\"], model or \"-\")\n            _set(self.widgets[\"firmware_entry\"], firmware or \"-\")\n            _set(self.widgets[\"region_entry\"], region or \"-\")\n            _set(self.widgets[\"aid_entry\"], aid or \"-\")\n            _set(self.widgets[\"cc_entry\"], cc or \"-\")\n            _set(self.widgets[\"imei_entry\"], imei or \"-\")\n\n        self.root.after(0, _update)\n\n    def set_device_placeholders(self) -&gt; None:\n        \"\"\"Set placeholder text for device fields (no device detected).\"\"\"\n\n        def _set(e: ctk.CTkEntry, text: str):\n            e.configure(state=\"normal\")\n            e.delete(0, \"end\")\n            e.insert(0, text)\n            e.configure(state=\"disabled\")\n\n        def _update():\n            _set(self.widgets[\"model_entry\"], \"-\")\n            _set(self.widgets[\"firmware_entry\"], \"-\")\n            _set(self.widgets[\"region_entry\"], \"-\")\n            _set(self.widgets[\"aid_entry\"], \"-\")\n            _set(self.widgets[\"cc_entry\"], \"-\")\n            _set(self.widgets[\"imei_entry\"], \"-\")\n\n        self.root.after(0, _update)\n\n    def clear_component_entries(self) -&gt; None:\n        \"\"\"Clear all firmware component entries.\"\"\"\n\n        def _clear(e: ctk.CTkEntry):\n            e.configure(state=\"normal\")\n            e.delete(0, \"end\")\n            e.configure(state=\"disabled\")\n\n        def _update():\n            _clear(self.widgets[\"ap_entry\"])\n            _clear(self.widgets[\"bl_entry\"])\n            _clear(self.widgets[\"cp_entry\"])\n            _clear(self.widgets[\"csc_entry\"])\n            _clear(self.widgets[\"home_entry\"])\n\n        self.root.after(0, _update)\n\n    def populate_component_entries(self, unzip_dir: Path) -&gt; None:\n        \"\"\"Populate firmware component entries from unzipped directory.\n\n        Args:\n            unzip_dir: Directory containing unzipped firmware files.\n        \"\"\"\n\n        def _set(e: ctk.CTkEntry, text: str):\n            e.configure(state=\"normal\")\n            e.delete(0, \"end\")\n            e.insert(0, text)\n            e.configure(state=\"disabled\")\n\n        # Find files by prefix\n        components: dict[str, str | None] = {\n            \"AP\": None,\n            \"BL\": None,\n            \"CP\": None,\n            \"CSC\": None,\n            \"HOME\": None,\n        }\n        for file_path in unzip_dir.iterdir():\n            if file_path.is_file():\n                name = file_path.name\n                for prefix in components:\n                    if name.startswith(prefix):\n                        components[prefix] = str(file_path.resolve())\n                        break\n\n        def _update():\n            _set(self.widgets[\"ap_entry\"], components[\"AP\"] or \"-\")\n            _set(self.widgets[\"bl_entry\"], components[\"BL\"] or \"-\")\n            _set(self.widgets[\"cp_entry\"], components[\"CP\"] or \"-\")\n            _set(self.widgets[\"csc_entry\"], components[\"CSC\"] or \"-\")\n            _set(self.widgets[\"home_entry\"], components[\"HOME\"] or \"-\")\n\n        self.root.after(0, _update)\n\n    def update_progress_bar(self, stage: str, done: int, total: int, label: str) -&gt; None:\n        \"\"\"Update progress bar and label.\n\n        Args:\n            stage: Stage name (\"download\", \"decrypt\", or \"extract\").\n            done: Bytes or files processed.\n            total: Total bytes or files.\n            label: Formatted progress label text.\n        \"\"\"\n        pct = done / total if total &gt; 0 else 0.0\n        self.logger.debug(\"Progress update - stage: %s, %.1f%% (%d/%d)\", stage, pct * 100, done, total)\n\n        def _update():\n            self.widgets[\"progress_message\"].pack_forget()\n            if not self.widgets[\"progress_bar_container\"].winfo_ismapped():\n                self.widgets[\"progress_bar_container\"].pack(fill=\"x\", padx=10, pady=(0, 10))\n            self.widgets[\"download_progress_bar\"].set(pct)\n            self.widgets[\"download_progress_label\"].configure(text=label)\n\n        self.root.after(0, _update)\n\n    def update_progress_message(self, message: str, color: str = \"info\") -&gt; None:\n        \"\"\"Update progress message with color coding.\n\n        Args:\n            message: Message to display.\n            color: Color type - \"info\", \"success\", \"warning\", \"error\".\n        \"\"\"\n        colors = {\n            \"info\": (\"#3B8ED0\", \"#1F6AA5\"),\n            \"success\": (\"#2CC985\", \"#2FA572\"),\n            \"warning\": (\"#FF9500\", \"#E68600\"),\n            \"error\": (\"#FF453A\", \"#E0342F\"),\n        }\n        fg_color = colors.get(color, colors[\"info\"])\n\n        def _update():\n            self.widgets[\"progress_bar_container\"].pack_forget()\n            self.widgets[\"progress_message\"].pack(fill=\"x\", padx=10, pady=(0, 10))\n            self.widgets[\"progress_message\"].configure(text=message, fg_color=fg_color)\n\n        self.root.after(0, _update)\n\n    def update_stop_button_state(self, download_in_progress: bool, stop_task: bool) -&gt; None:\n        \"\"\"Update stop button enabled/disabled state.\n\n        Args:\n            download_in_progress: Whether download is active.\n            stop_task: Whether stop has been requested.\n        \"\"\"\n\n        def _update():\n            if download_in_progress and not stop_task:\n                self.widgets[\"stop_button\"].configure(state=\"normal\")\n            else:\n                self.widgets[\"stop_button\"].configure(state=\"disabled\")\n\n        self.root.after(0, _update)\n\n    def update_cleanup_status(self, status: str, progress: float, details: str) -&gt; None:\n        \"\"\"Update cleanup status during startup.\n\n        Args:\n            status: Status message.\n            progress: Progress value (0.0 to 1.0).\n            details: Detailed information.\n        \"\"\"\n\n        def _update():\n            if \"cleanup_status\" in self.widgets:\n                self.widgets[\"cleanup_status\"].configure(text=status)\n            if \"cleanup_progress\" in self.widgets:\n                self.widgets[\"cleanup_progress\"].set(progress)\n            if \"cleanup_details\" in self.widgets:\n                self.widgets[\"cleanup_details\"].configure(text=details)\n\n        self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.update_status","title":"update_status","text":"Python<pre><code>update_status(message)\n</code></pre> <p>Update status label with thread-safe scheduling.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Status message to display.</p> required Source code in <code>app/ui_updater.py</code> Python<pre><code>def update_status(self, message: str) -&gt; None:\n    \"\"\"Update status label with thread-safe scheduling.\n\n    Args:\n        message: Status message to display.\n    \"\"\"\n    self.root.after(0, lambda: self.widgets[\"status_label\"].configure(text=message))\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.update_device_fields","title":"update_device_fields","text":"Python<pre><code>update_device_fields(\n    model, firmware, region, imei, aid=\"-\", cc=\"-\"\n)\n</code></pre> <p>Update device info entries (read-only display).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model.</p> required <code>firmware</code> <code>str</code> <p>Firmware version.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>imei</code> <code>str</code> <p>IMEI string.</p> required <code>aid</code> <code>str</code> <p>Application ID.</p> <code>'-'</code> <code>cc</code> <code>str</code> <p>Country Code.</p> <code>'-'</code> Source code in <code>app/ui_updater.py</code> Python<pre><code>def update_device_fields(\n    self, model: str, firmware: str, region: str, imei: str, aid: str = \"-\", cc: str = \"-\"\n) -&gt; None:\n    \"\"\"Update device info entries (read-only display).\n\n    Args:\n        model: Device model.\n        firmware: Firmware version.\n        region: Region/CSC code.\n        imei: IMEI string.\n        aid: Application ID.\n        cc: Country Code.\n    \"\"\"\n\n    def _set(e: ctk.CTkEntry, text: str):\n        e.configure(state=\"normal\")\n        e.delete(0, \"end\")\n        e.insert(0, text)\n        e.configure(state=\"disabled\")\n\n    def _update():\n        _set(self.widgets[\"model_entry\"], model or \"-\")\n        _set(self.widgets[\"firmware_entry\"], firmware or \"-\")\n        _set(self.widgets[\"region_entry\"], region or \"-\")\n        _set(self.widgets[\"aid_entry\"], aid or \"-\")\n        _set(self.widgets[\"cc_entry\"], cc or \"-\")\n        _set(self.widgets[\"imei_entry\"], imei or \"-\")\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.set_device_placeholders","title":"set_device_placeholders","text":"Python<pre><code>set_device_placeholders()\n</code></pre> <p>Set placeholder text for device fields (no device detected).</p> Source code in <code>app/ui_updater.py</code> Python<pre><code>def set_device_placeholders(self) -&gt; None:\n    \"\"\"Set placeholder text for device fields (no device detected).\"\"\"\n\n    def _set(e: ctk.CTkEntry, text: str):\n        e.configure(state=\"normal\")\n        e.delete(0, \"end\")\n        e.insert(0, text)\n        e.configure(state=\"disabled\")\n\n    def _update():\n        _set(self.widgets[\"model_entry\"], \"-\")\n        _set(self.widgets[\"firmware_entry\"], \"-\")\n        _set(self.widgets[\"region_entry\"], \"-\")\n        _set(self.widgets[\"aid_entry\"], \"-\")\n        _set(self.widgets[\"cc_entry\"], \"-\")\n        _set(self.widgets[\"imei_entry\"], \"-\")\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.clear_component_entries","title":"clear_component_entries","text":"Python<pre><code>clear_component_entries()\n</code></pre> <p>Clear all firmware component entries.</p> Source code in <code>app/ui_updater.py</code> Python<pre><code>def clear_component_entries(self) -&gt; None:\n    \"\"\"Clear all firmware component entries.\"\"\"\n\n    def _clear(e: ctk.CTkEntry):\n        e.configure(state=\"normal\")\n        e.delete(0, \"end\")\n        e.configure(state=\"disabled\")\n\n    def _update():\n        _clear(self.widgets[\"ap_entry\"])\n        _clear(self.widgets[\"bl_entry\"])\n        _clear(self.widgets[\"cp_entry\"])\n        _clear(self.widgets[\"csc_entry\"])\n        _clear(self.widgets[\"home_entry\"])\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.populate_component_entries","title":"populate_component_entries","text":"Python<pre><code>populate_component_entries(unzip_dir)\n</code></pre> <p>Populate firmware component entries from unzipped directory.</p> <p>Parameters:</p> Name Type Description Default <code>unzip_dir</code> <code>Path</code> <p>Directory containing unzipped firmware files.</p> required Source code in <code>app/ui_updater.py</code> Python<pre><code>def populate_component_entries(self, unzip_dir: Path) -&gt; None:\n    \"\"\"Populate firmware component entries from unzipped directory.\n\n    Args:\n        unzip_dir: Directory containing unzipped firmware files.\n    \"\"\"\n\n    def _set(e: ctk.CTkEntry, text: str):\n        e.configure(state=\"normal\")\n        e.delete(0, \"end\")\n        e.insert(0, text)\n        e.configure(state=\"disabled\")\n\n    # Find files by prefix\n    components: dict[str, str | None] = {\n        \"AP\": None,\n        \"BL\": None,\n        \"CP\": None,\n        \"CSC\": None,\n        \"HOME\": None,\n    }\n    for file_path in unzip_dir.iterdir():\n        if file_path.is_file():\n            name = file_path.name\n            for prefix in components:\n                if name.startswith(prefix):\n                    components[prefix] = str(file_path.resolve())\n                    break\n\n    def _update():\n        _set(self.widgets[\"ap_entry\"], components[\"AP\"] or \"-\")\n        _set(self.widgets[\"bl_entry\"], components[\"BL\"] or \"-\")\n        _set(self.widgets[\"cp_entry\"], components[\"CP\"] or \"-\")\n        _set(self.widgets[\"csc_entry\"], components[\"CSC\"] or \"-\")\n        _set(self.widgets[\"home_entry\"], components[\"HOME\"] or \"-\")\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.update_progress_bar","title":"update_progress_bar","text":"Python<pre><code>update_progress_bar(stage, done, total, label)\n</code></pre> <p>Update progress bar and label.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>Stage name (\"download\", \"decrypt\", or \"extract\").</p> required <code>done</code> <code>int</code> <p>Bytes or files processed.</p> required <code>total</code> <code>int</code> <p>Total bytes or files.</p> required <code>label</code> <code>str</code> <p>Formatted progress label text.</p> required Source code in <code>app/ui_updater.py</code> Python<pre><code>def update_progress_bar(self, stage: str, done: int, total: int, label: str) -&gt; None:\n    \"\"\"Update progress bar and label.\n\n    Args:\n        stage: Stage name (\"download\", \"decrypt\", or \"extract\").\n        done: Bytes or files processed.\n        total: Total bytes or files.\n        label: Formatted progress label text.\n    \"\"\"\n    pct = done / total if total &gt; 0 else 0.0\n    self.logger.debug(\"Progress update - stage: %s, %.1f%% (%d/%d)\", stage, pct * 100, done, total)\n\n    def _update():\n        self.widgets[\"progress_message\"].pack_forget()\n        if not self.widgets[\"progress_bar_container\"].winfo_ismapped():\n            self.widgets[\"progress_bar_container\"].pack(fill=\"x\", padx=10, pady=(0, 10))\n        self.widgets[\"download_progress_bar\"].set(pct)\n        self.widgets[\"download_progress_label\"].configure(text=label)\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.update_progress_message","title":"update_progress_message","text":"Python<pre><code>update_progress_message(message, color='info')\n</code></pre> <p>Update progress message with color coding.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to display.</p> required <code>color</code> <code>str</code> <p>Color type - \"info\", \"success\", \"warning\", \"error\".</p> <code>'info'</code> Source code in <code>app/ui_updater.py</code> Python<pre><code>def update_progress_message(self, message: str, color: str = \"info\") -&gt; None:\n    \"\"\"Update progress message with color coding.\n\n    Args:\n        message: Message to display.\n        color: Color type - \"info\", \"success\", \"warning\", \"error\".\n    \"\"\"\n    colors = {\n        \"info\": (\"#3B8ED0\", \"#1F6AA5\"),\n        \"success\": (\"#2CC985\", \"#2FA572\"),\n        \"warning\": (\"#FF9500\", \"#E68600\"),\n        \"error\": (\"#FF453A\", \"#E0342F\"),\n    }\n    fg_color = colors.get(color, colors[\"info\"])\n\n    def _update():\n        self.widgets[\"progress_bar_container\"].pack_forget()\n        self.widgets[\"progress_message\"].pack(fill=\"x\", padx=10, pady=(0, 10))\n        self.widgets[\"progress_message\"].configure(text=message, fg_color=fg_color)\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.update_stop_button_state","title":"update_stop_button_state","text":"Python<pre><code>update_stop_button_state(download_in_progress, stop_task)\n</code></pre> <p>Update stop button enabled/disabled state.</p> <p>Parameters:</p> Name Type Description Default <code>download_in_progress</code> <code>bool</code> <p>Whether download is active.</p> required <code>stop_task</code> <code>bool</code> <p>Whether stop has been requested.</p> required Source code in <code>app/ui_updater.py</code> Python<pre><code>def update_stop_button_state(self, download_in_progress: bool, stop_task: bool) -&gt; None:\n    \"\"\"Update stop button enabled/disabled state.\n\n    Args:\n        download_in_progress: Whether download is active.\n        stop_task: Whether stop has been requested.\n    \"\"\"\n\n    def _update():\n        if download_in_progress and not stop_task:\n            self.widgets[\"stop_button\"].configure(state=\"normal\")\n        else:\n            self.widgets[\"stop_button\"].configure(state=\"disabled\")\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/app.ui_updater/#app.ui_updater.UIUpdater.update_cleanup_status","title":"update_cleanup_status","text":"Python<pre><code>update_cleanup_status(status, progress, details)\n</code></pre> <p>Update cleanup status during startup.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Status message.</p> required <code>progress</code> <code>float</code> <p>Progress value (0.0 to 1.0).</p> required <code>details</code> <code>str</code> <p>Detailed information.</p> required Source code in <code>app/ui_updater.py</code> Python<pre><code>def update_cleanup_status(self, status: str, progress: float, details: str) -&gt; None:\n    \"\"\"Update cleanup status during startup.\n\n    Args:\n        status: Status message.\n        progress: Progress value (0.0 to 1.0).\n        details: Detailed information.\n    \"\"\"\n\n    def _update():\n        if \"cleanup_status\" in self.widgets:\n            self.widgets[\"cleanup_status\"].configure(text=status)\n        if \"cleanup_progress\" in self.widgets:\n            self.widgets[\"cleanup_progress\"].set(progress)\n        if \"cleanup_details\" in self.widgets:\n            self.widgets[\"cleanup_details\"].configure(text=details)\n\n    self.root.after(0, _update)\n</code></pre>"},{"location":"api/device.detector/","title":"Device Detector","text":"<p>Samsung device detection via serial port enumeration.</p> <p>This module provides functions to detect Samsung devices connected in download mode (Odin mode) by enumerating serial ports for Samsung Mobile USB Modems.</p> <p>Uses pyserial's list_ports for cross-platform compatibility. Requires Samsung USB drivers installed on Windows.</p> <p>Based on SharpOdinClient implementation by Gsm Alphabet.</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.detector/#device.detector.DetectedDevice","title":"DetectedDevice","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Information about a detected Samsung device in download mode.</p> <p>Attributes:</p> Name Type Description <code>port_name</code> <code>str</code> <p>Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)</p> <code>device_name</code> <code>str</code> <p>Full device description from port enumeration</p> <code>manufacturer</code> <code>str</code> <p>Device manufacturer string (if available)</p> <code>product</code> <code>str</code> <p>Product description string (if available)</p> <code>vid</code> <code>Optional[str]</code> <p>USB Vendor ID (4-char hex string, if available)</p> <code>pid</code> <code>Optional[str]</code> <p>USB Product ID (4-char hex string, if available)</p> Source code in <code>device/detector.py</code> Python<pre><code>class DetectedDevice(NamedTuple):\n    \"\"\"Information about a detected Samsung device in download mode.\n\n    Attributes:\n        port_name: Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)\n        device_name: Full device description from port enumeration\n        manufacturer: Device manufacturer string (if available)\n        product: Product description string (if available)\n        vid: USB Vendor ID (4-char hex string, if available)\n        pid: USB Product ID (4-char hex string, if available)\n    \"\"\"\n\n    port_name: str\n    device_name: str\n    manufacturer: str\n    product: str\n    vid: Optional[str] = None\n    pid: Optional[str] = None\n</code></pre>"},{"location":"api/device.detector/#device.detector.detect_download_mode_devices","title":"detect_download_mode_devices","text":"Python<pre><code>detect_download_mode_devices()\n</code></pre> <p>Detect Samsung devices connected in download mode (Odin mode).</p> <p>Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their device description. This is different from MTP mode devices.</p> <p>Uses pyserial's list_ports to enumerate serial ports.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected download mode devices. Empty if no devices found.</p> Source code in <code>device/detector.py</code> Python<pre><code>def detect_download_mode_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect Samsung devices connected in download mode (Odin mode).\n\n    Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their\n    device description. This is different from MTP mode devices.\n\n    Uses pyserial's list_ports to enumerate serial ports.\n\n    Returns:\n        List of detected download mode devices. Empty if no devices found.\n    \"\"\"\n    devices = []\n\n    for port in list_ports.comports():\n        # Check device description for download mode signature\n        description = port.description or \"\"\n        manufacturer = port.manufacturer or \"\"\n        product = port.product or \"\"\n\n        # Download mode devices have specific signature\n        is_download_mode = \"samsung mobile usb modem\" in description.lower()\n\n        if is_download_mode and port.device:\n            # Extract VID/PID from hardware ID\n            hwid = port.hwid or \"\"\n            vid, pid = _extract_vid_pid(hwid)\n\n            devices.append(\n                DetectedDevice(\n                    port_name=port.device,\n                    device_name=description,\n                    manufacturer=manufacturer,\n                    product=product,\n                    vid=vid,\n                    pid=pid,\n                )\n            )\n\n    return devices\n</code></pre>"},{"location":"api/device.detector/#device.detector.detect_samsung_devices","title":"detect_samsung_devices","text":"Python<pre><code>detect_samsung_devices()\n</code></pre> <p>Detect all Samsung devices (alias for detect_download_mode_devices).</p> <p>This function is kept for backward compatibility but now detects download mode devices only.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected devices with port information. Empty if no devices found.</p> Source code in <code>device/detector.py</code> Python<pre><code>def detect_samsung_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect all Samsung devices (alias for detect_download_mode_devices).\n\n    This function is kept for backward compatibility but now detects\n    download mode devices only.\n\n    Returns:\n        List of detected devices with port information. Empty if no devices found.\n    \"\"\"\n    return detect_download_mode_devices()\n</code></pre>"},{"location":"api/device.detector/#device.detector.get_first_device","title":"get_first_device","text":"Python<pre><code>get_first_device()\n</code></pre> <p>Get the first detected Samsung device in download mode.</p> <p>Convenience function for single-device scenarios.</p> <p>Returns:</p> Type Description <code>DetectedDevice</code> <p>First detected device</p> <p>Raises:</p> Type Description <code>DeviceNotFoundError</code> <p>If no Samsung devices are connected in download mode</p> Source code in <code>device/detector.py</code> Python<pre><code>def get_first_device() -&gt; DetectedDevice:\n    \"\"\"Get the first detected Samsung device in download mode.\n\n    Convenience function for single-device scenarios.\n\n    Returns:\n        First detected device\n\n    Raises:\n        DeviceNotFoundError: If no Samsung devices are connected in download mode\n    \"\"\"\n    devices = detect_download_mode_devices()\n    if not devices:\n        raise DeviceNotFoundError(\n            \"No Samsung devices in download mode detected. \"\n            \"Ensure device is connected in download mode (Odin mode) \"\n            \"and Samsung USB drivers are installed (Windows). \"\n            \"To enter download mode: Power off device, then hold Volume Down + Home + Power.\"\n        )\n    return devices[0]\n</code></pre>"},{"location":"api/device.errors/","title":"Device Errors","text":"<p>Exception types for device operations.</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.errors/#device.errors.DeviceError","title":"DeviceError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for device-related errors.</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceError(Exception):\n    \"\"\"Base exception for device-related errors.\"\"\"\n</code></pre>"},{"location":"api/device.errors/#device.errors.DeviceNotFoundError","title":"DeviceNotFoundError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when no Samsung devices are detected in MTP mode.</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceNotFoundError(DeviceError):\n    \"\"\"Raised when no Samsung devices are detected in MTP mode.\"\"\"\n</code></pre>"},{"location":"api/device.errors/#device.errors.DeviceReadError","title":"DeviceReadError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when device information cannot be read via AT commands.</p> <p>This can occur due to: - Serial port communication failure - Device busy (returns BUSY response) - Malformed AT command response - Permission/driver issues</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceReadError(DeviceError):\n    \"\"\"Raised when device information cannot be read via AT commands.\n\n    This can occur due to:\n    - Serial port communication failure\n    - Device busy (returns BUSY response)\n    - Malformed AT command response\n    - Permission/driver issues\n    \"\"\"\n</code></pre>"},{"location":"api/device.errors/#device.errors.DeviceParseError","title":"DeviceParseError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when AT command response cannot be parsed.</p> <p>This indicates the device returned data but in an unexpected format.</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceParseError(DeviceError):\n    \"\"\"Raised when AT command response cannot be parsed.\n\n    This indicates the device returned data but in an unexpected format.\n    \"\"\"\n</code></pre>"},{"location":"api/device/","title":"Device Detection","text":"<p>Samsung device detection and information reading.</p> <p>This package provides functionality to detect Samsung devices in download mode (Odin mode) and read device information using the Odin binary protocol.</p> <p>Based on SharpOdinClient implementation by Gsm Alphabet (https://github.com/Alephgsm/SharpOdinClient)</p> <p>Platform Requirements: - Cross-platform support (Windows, Linux, macOS) - Samsung USB drivers installed (Windows) - Python package: pyserial - Device must be in download mode (Odin mode)</p> <p>Entering Download Mode:</p> <p>To put a Samsung device into download mode: 1. Power off the device completely 2. Press and hold: Volume Down + Home + Power buttons 3. When warning screen appears, press Volume Up to continue 4. Device should display \"Downloading...\" screen</p> <p>Installation:</p> <p>.. code-block:: bash</p> Text Only<pre><code>pip install pyserial\n</code></pre> <p>Usage:</p> <p>Auto-detect and read device info:</p> <p>.. code-block:: python</p> Text Only<pre><code>from device import read_device_info, is_odin_mode\n\ntry:\n    # Check if device is in Odin mode\n    from device import detect_download_mode_devices\n    devices = detect_download_mode_devices()\n\n    if devices:\n        port = devices[0].port_name\n        if is_odin_mode(port):\n            info = read_device_info(port)\n            print(f\"Model: {info.model}\")\n            print(f\"Firmware: {info.fwver}\")\n            print(f\"Sales Code: {info.sales}\")\nexcept Exception as ex:\n    print(f\"Error: {ex}\")\n</code></pre> <p>Manual device detection with VID/PID:</p> <p>.. code-block:: python</p> Text Only<pre><code>from device import detect_download_mode_devices\n\ndevices = detect_download_mode_devices()\nfor device in devices:\n    print(f\"Found: {device.device_name}\")\n    print(f\"  Port: {device.port_name}\")\n    print(f\"  VID: {device.vid}, PID: {device.pid}\")\n</code></pre> <p>Integration with nanosamfw:</p> <p>Use detected device information for firmware downloads:</p> <p>.. code-block:: python</p> Text Only<pre><code>from device import read_device_info\nfrom download import check_firmware, download_and_decrypt\n\n# Read from device in download mode\ndevice_info = read_device_info()\n\n# Use sales code as CSC for firmware download\nif device_info.model and device_info.sales:\n    firmware_info = check_firmware(\n        model=device_info.model,\n        csc=device_info.sales,\n        device_id=\"\"  # IMEI not available in download mode\n    )\n</code></pre> <p>Protocol Details:</p> <p>This package implements the Odin/LOKE protocol used by Samsung's Odin flash tool: - DVIF (0x44,0x56,0x49,0x46): Get device information - ODIN (0x4F,0x44,0x49,0x4E): Verify Odin mode (expects \"LOKE\" response) - Communication at 115200 baud with RTS/CTS flow control</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device/#device.DetectedDevice","title":"DetectedDevice","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Information about a detected Samsung device in download mode.</p> <p>Attributes:</p> Name Type Description <code>port_name</code> <code>str</code> <p>Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)</p> <code>device_name</code> <code>str</code> <p>Full device description from port enumeration</p> <code>manufacturer</code> <code>str</code> <p>Device manufacturer string (if available)</p> <code>product</code> <code>str</code> <p>Product description string (if available)</p> <code>vid</code> <code>Optional[str]</code> <p>USB Vendor ID (4-char hex string, if available)</p> <code>pid</code> <code>Optional[str]</code> <p>USB Product ID (4-char hex string, if available)</p> Source code in <code>device/detector.py</code> Python<pre><code>class DetectedDevice(NamedTuple):\n    \"\"\"Information about a detected Samsung device in download mode.\n\n    Attributes:\n        port_name: Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)\n        device_name: Full device description from port enumeration\n        manufacturer: Device manufacturer string (if available)\n        product: Product description string (if available)\n        vid: USB Vendor ID (4-char hex string, if available)\n        pid: USB Product ID (4-char hex string, if available)\n    \"\"\"\n\n    port_name: str\n    device_name: str\n    manufacturer: str\n    product: str\n    vid: Optional[str] = None\n    pid: Optional[str] = None\n</code></pre>"},{"location":"api/device/#device.DeviceError","title":"DeviceError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for device-related errors.</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceError(Exception):\n    \"\"\"Base exception for device-related errors.\"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceNotFoundError","title":"DeviceNotFoundError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when no Samsung devices are detected in MTP mode.</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceNotFoundError(DeviceError):\n    \"\"\"Raised when no Samsung devices are detected in MTP mode.\"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceParseError","title":"DeviceParseError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when AT command response cannot be parsed.</p> <p>This indicates the device returned data but in an unexpected format.</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceParseError(DeviceError):\n    \"\"\"Raised when AT command response cannot be parsed.\n\n    This indicates the device returned data but in an unexpected format.\n    \"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceReadError","title":"DeviceReadError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when device information cannot be read via AT commands.</p> <p>This can occur due to: - Serial port communication failure - Device busy (returns BUSY response) - Malformed AT command response - Permission/driver issues</p> Source code in <code>device/errors.py</code> Python<pre><code>class DeviceReadError(DeviceError):\n    \"\"\"Raised when device information cannot be read via AT commands.\n\n    This can occur due to:\n    - Serial port communication failure\n    - Device busy (returns BUSY response)\n    - Malformed AT command response\n    - Permission/driver issues\n    \"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceInfo","title":"DeviceInfo  <code>dataclass</code>","text":"<p>Samsung device information (DEPRECATED - kept for backward compatibility).</p> <p>.. deprecated::     This class was used with AT commands for MTP mode devices.     The package now uses Odin download mode protocol.     Use OdinDeviceInfo from device.protocol instead.</p> <p>All fields are extracted from the AT+DEVCONINFO response which follows the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product); SN(serial);IMEI(imei);UN(un).</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Device model code (e.g., SM-G991B)</p> <code>device_name</code> <code>str</code> <p>Device marketing name (typically same as model)</p> <code>pda_version</code> <code>str</code> <p>PDA firmware version</p> <code>csc_version</code> <code>str</code> <p>CSC (Country Specific Code) version</p> <code>modem_version</code> <code>str</code> <p>Modem/baseband firmware version</p> <code>region</code> <code>str</code> <p>3-character CSC region code</p> <code>serial_number</code> <code>str</code> <p>Device serial number</p> <code>imei</code> <code>str</code> <p>International Mobile Equipment Identity</p> <code>unique_number</code> <code>str</code> <p>Samsung unique number (UN)</p> Source code in <code>device/models.py</code> Python<pre><code>@dataclass(frozen=True)\nclass DeviceInfo:\n    \"\"\"Samsung device information (DEPRECATED - kept for backward compatibility).\n\n    .. deprecated::\n        This class was used with AT commands for MTP mode devices.\n        The package now uses Odin download mode protocol.\n        Use OdinDeviceInfo from device.protocol instead.\n\n    All fields are extracted from the AT+DEVCONINFO response which follows\n    the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product);\n    SN(serial);IMEI(imei);UN(un).\n\n    Attributes:\n        model: Device model code (e.g., SM-G991B)\n        device_name: Device marketing name (typically same as model)\n        pda_version: PDA firmware version\n        csc_version: CSC (Country Specific Code) version\n        modem_version: Modem/baseband firmware version\n        region: 3-character CSC region code\n        serial_number: Device serial number\n        imei: International Mobile Equipment Identity\n        unique_number: Samsung unique number (UN)\n    \"\"\"\n\n    model: str\n    device_name: str\n    pda_version: str\n    csc_version: str\n    modem_version: str\n    region: str\n    serial_number: str\n    imei: str\n    unique_number: str\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return human-readable device information.\"\"\"\n        return (\n            f\"{self.model} ({self.device_name})\\n\"\n            f\"  PDA: {self.pda_version}\\n\"\n            f\"  CSC: {self.csc_version} ({self.region})\\n\"\n            f\"  Modem: {self.modem_version}\\n\"\n            f\"  IMEI: {self.imei}\\n\"\n            f\"  S/N: {self.serial_number}\\n\"\n            f\"  UN: {self.unique_number}\"\n        )\n</code></pre>"},{"location":"api/device/#device.OdinCommand","title":"OdinCommand  <code>dataclass</code>","text":"<p>Odin/LOKE protocol command structure.</p> <p>This represents the 1024-byte command buffer used for all Odin protocol operations. The structure matches Samsung's binary protocol.</p> <p>Structure (little-endian):     - Cmd (4 bytes): Command code     - SeqCmd (4 bytes): Sequence/sub-command     - BinaryType (4 or 8 bytes): Binary type identifier     - SizeWritten (4 bytes): Size of data written     - Unknown (4 bytes): Reserved/unknown field     - DeviceId (4 bytes): Device type identifier     - Identifier (4 bytes): Partition identifier     - SessionEnd (4 bytes): Session end flag     - EfsClear (4 bytes): EFS clear flag     - BootUpdate (4 bytes): Boot update flag</p> Common command codes <ul> <li>0x64 (100): LOKE_Initialize</li> <li>0x65 (101): Read/Write PIT</li> <li>0x66 (102): Flash data</li> <li>0x67 (103): Reboot to normal mode</li> <li>0x69 (105): Additional initialization</li> </ul> Source code in <code>device/protocol.py</code> Python<pre><code>@dataclass\nclass OdinCommand:\n    \"\"\"Odin/LOKE protocol command structure.\n\n    This represents the 1024-byte command buffer used for all Odin protocol\n    operations. The structure matches Samsung's binary protocol.\n\n    Structure (little-endian):\n        - Cmd (4 bytes): Command code\n        - SeqCmd (4 bytes): Sequence/sub-command\n        - BinaryType (4 or 8 bytes): Binary type identifier\n        - SizeWritten (4 bytes): Size of data written\n        - Unknown (4 bytes): Reserved/unknown field\n        - DeviceId (4 bytes): Device type identifier\n        - Identifier (4 bytes): Partition identifier\n        - SessionEnd (4 bytes): Session end flag\n        - EfsClear (4 bytes): EFS clear flag\n        - BootUpdate (4 bytes): Boot update flag\n\n    Common command codes:\n        - 0x64 (100): LOKE_Initialize\n        - 0x65 (101): Read/Write PIT\n        - 0x66 (102): Flash data\n        - 0x67 (103): Reboot to normal mode\n        - 0x69 (105): Additional initialization\n    \"\"\"\n\n    cmd: int\n    seq_cmd: int = 0\n    binary_type: int = 0\n    size_written: int = 0\n    unknown: int = 0\n    device_id: int = 0\n    identifier: int = 0\n    session_end: int = 0\n    efs_clear: int = 0\n    boot_update: int = 0\n\n    def to_bytes(self) -&gt; bytes:\n        \"\"\"Serialize command to 1024-byte buffer.\n\n        Returns:\n            1024-byte buffer in Odin protocol format\n        \"\"\"\n        buffer = bytearray(1024)\n\n        # Pack header fields (little-endian)\n        struct.pack_into(\"&lt;I\", buffer, 0, self.cmd)\n        struct.pack_into(\"&lt;I\", buffer, 4, self.seq_cmd)\n\n        # BinaryType is 8 bytes for cmd 0x64 (100), else 4 bytes\n        if self.cmd == 100:\n            struct.pack_into(\"&lt;Q\", buffer, 8, self.binary_type)\n        else:\n            struct.pack_into(\"&lt;I\", buffer, 8, self.binary_type)\n            struct.pack_into(\"&lt;I\", buffer, 12, self.size_written)\n\n        struct.pack_into(\"&lt;I\", buffer, 16, self.unknown)\n        struct.pack_into(\"&lt;I\", buffer, 20, self.device_id)\n        struct.pack_into(\"&lt;I\", buffer, 24, self.identifier)\n        struct.pack_into(\"&lt;I\", buffer, 28, self.session_end)\n        struct.pack_into(\"&lt;I\", buffer, 32, self.efs_clear)\n        struct.pack_into(\"&lt;I\", buffer, 36, self.boot_update)\n\n        return bytes(buffer)\n\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; \"OdinCommand\":\n        \"\"\"Parse command from response buffer.\n\n        Args:\n            data: Response buffer (minimum 8 bytes)\n\n        Returns:\n            Parsed command\n\n        Raises:\n            ValueError: If data is too short\n        \"\"\"\n        if len(data) &lt; 8:\n            raise ValueError(f\"Response too short: {len(data)} bytes (need 8)\")\n\n        cmd = struct.unpack_from(\"&lt;I\", data, 0)[0]\n        seq_cmd = struct.unpack_from(\"&lt;I\", data, 4)[0]\n\n        return cls(cmd=cmd, seq_cmd=seq_cmd)\n</code></pre>"},{"location":"api/device/#device.OdinCommand.to_bytes","title":"to_bytes","text":"Python<pre><code>to_bytes()\n</code></pre> <p>Serialize command to 1024-byte buffer.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>1024-byte buffer in Odin protocol format</p> Source code in <code>device/protocol.py</code> Python<pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Serialize command to 1024-byte buffer.\n\n    Returns:\n        1024-byte buffer in Odin protocol format\n    \"\"\"\n    buffer = bytearray(1024)\n\n    # Pack header fields (little-endian)\n    struct.pack_into(\"&lt;I\", buffer, 0, self.cmd)\n    struct.pack_into(\"&lt;I\", buffer, 4, self.seq_cmd)\n\n    # BinaryType is 8 bytes for cmd 0x64 (100), else 4 bytes\n    if self.cmd == 100:\n        struct.pack_into(\"&lt;Q\", buffer, 8, self.binary_type)\n    else:\n        struct.pack_into(\"&lt;I\", buffer, 8, self.binary_type)\n        struct.pack_into(\"&lt;I\", buffer, 12, self.size_written)\n\n    struct.pack_into(\"&lt;I\", buffer, 16, self.unknown)\n    struct.pack_into(\"&lt;I\", buffer, 20, self.device_id)\n    struct.pack_into(\"&lt;I\", buffer, 24, self.identifier)\n    struct.pack_into(\"&lt;I\", buffer, 28, self.session_end)\n    struct.pack_into(\"&lt;I\", buffer, 32, self.efs_clear)\n    struct.pack_into(\"&lt;I\", buffer, 36, self.boot_update)\n\n    return bytes(buffer)\n</code></pre>"},{"location":"api/device/#device.OdinCommand.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"Python<pre><code>from_bytes(data)\n</code></pre> <p>Parse command from response buffer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Response buffer (minimum 8 bytes)</p> required <p>Returns:</p> Type Description <code>OdinCommand</code> <p>Parsed command</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data is too short</p> Source code in <code>device/protocol.py</code> Python<pre><code>@classmethod\ndef from_bytes(cls, data: bytes) -&gt; \"OdinCommand\":\n    \"\"\"Parse command from response buffer.\n\n    Args:\n        data: Response buffer (minimum 8 bytes)\n\n    Returns:\n        Parsed command\n\n    Raises:\n        ValueError: If data is too short\n    \"\"\"\n    if len(data) &lt; 8:\n        raise ValueError(f\"Response too short: {len(data)} bytes (need 8)\")\n\n    cmd = struct.unpack_from(\"&lt;I\", data, 0)[0]\n    seq_cmd = struct.unpack_from(\"&lt;I\", data, 4)[0]\n\n    return cls(cmd=cmd, seq_cmd=seq_cmd)\n</code></pre>"},{"location":"api/device/#device.OdinDeviceInfo","title":"OdinDeviceInfo  <code>dataclass</code>","text":"<p>Device information from Odin download mode (DVIF protocol).</p> <p>This is returned by sending DVIF command (0x44,0x56,0x49,0x46) to a device in download mode. Response format is semicolon-separated key=value pairs.</p> Example response <p>@capa=1;product=GT-I9300;model=GT-I9300;fwver=I9300XXEMK4;...#</p> <p>Attributes:</p> Name Type Description <code>capa</code> <code>Optional[str]</code> <p>Device capability number</p> <code>product</code> <code>Optional[str]</code> <p>Product identifier</p> <code>model</code> <code>Optional[str]</code> <p>Model number</p> <code>fwver</code> <code>Optional[str]</code> <p>Firmware version string</p> <code>vendor</code> <code>Optional[str]</code> <p>Vendor identifier</p> <code>sales</code> <code>Optional[str]</code> <p>Sales code (region)</p> <code>ver</code> <code>Optional[str]</code> <p>Build number</p> <code>did</code> <code>Optional[str]</code> <p>Device ID</p> <code>un</code> <code>Optional[str]</code> <p>Unique number</p> <code>tmu_temp</code> <code>Optional[str]</code> <p>TMU temperature sensor value</p> <code>prov</code> <code>Optional[str]</code> <p>Provision status</p> <code>raw_response</code> <code>str</code> <p>Original raw response from device</p> Source code in <code>device/protocol.py</code> Python<pre><code>@dataclass(frozen=True)\nclass OdinDeviceInfo:\n    \"\"\"Device information from Odin download mode (DVIF protocol).\n\n    This is returned by sending DVIF command (0x44,0x56,0x49,0x46) to a device\n    in download mode. Response format is semicolon-separated key=value pairs.\n\n    Example response:\n        @capa=1;product=GT-I9300;model=GT-I9300;fwver=I9300XXEMK4;...#\n\n    Attributes:\n        capa: Device capability number\n        product: Product identifier\n        model: Model number\n        fwver: Firmware version string\n        vendor: Vendor identifier\n        sales: Sales code (region)\n        ver: Build number\n        did: Device ID\n        un: Unique number\n        tmu_temp: TMU temperature sensor value\n        prov: Provision status\n        raw_response: Original raw response from device\n    \"\"\"\n\n    capa: Optional[str] = None\n    product: Optional[str] = None\n    model: Optional[str] = None\n    fwver: Optional[str] = None\n    vendor: Optional[str] = None\n    sales: Optional[str] = None\n    ver: Optional[str] = None\n    did: Optional[str] = None\n    un: Optional[str] = None\n    tmu_temp: Optional[str] = None\n    prov: Optional[str] = None\n    raw_response: str = \"\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return human-readable device information.\"\"\"\n        lines = []\n        if self.model:\n            lines.append(f\"Model: {self.model}\")\n        if self.product:\n            lines.append(f\"Product: {self.product}\")\n        if self.fwver:\n            lines.append(f\"Firmware: {self.fwver}\")\n        if self.sales:\n            lines.append(f\"Sales Code: {self.sales}\")\n        if self.un:\n            lines.append(f\"Unique ID: {self.un}\")\n        return \"\\n\".join(lines) if lines else \"No device info\"\n</code></pre>"},{"location":"api/device/#device.ATDeviceInfo","title":"ATDeviceInfo  <code>dataclass</code>","text":"<p>Device information from AT commands.</p> <p>Simplified device info structure for AT+DEVCONINFO responses. For more detailed information, use Odin protocol (OdinDeviceInfo).</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Device model code (e.g., SM-G991B)</p> <code>firmware_version</code> <code>str</code> <p>Full firmware version string (PDA/CSC/MODEM/BOOTLOADER)</p> <code>sales_code</code> <code>str</code> <p>3-character CSC/region code (e.g., XAA, DBT)</p> <code>imei</code> <code>str</code> <p>International Mobile Equipment Identity (15 digits)</p> <code>serial_number</code> <code>str</code> <p>Device serial number (SN field)</p> <code>lock_status</code> <code>str</code> <p>Device lock status (LOCK field)</p> Source code in <code>device/reader_at.py</code> Python<pre><code>@dataclass(frozen=True)\nclass ATDeviceInfo:\n    \"\"\"Device information from AT commands.\n\n    Simplified device info structure for AT+DEVCONINFO responses.\n    For more detailed information, use Odin protocol (OdinDeviceInfo).\n\n    Attributes:\n        model: Device model code (e.g., SM-G991B)\n        firmware_version: Full firmware version string (PDA/CSC/MODEM/BOOTLOADER)\n        sales_code: 3-character CSC/region code (e.g., XAA, DBT)\n        imei: International Mobile Equipment Identity (15 digits)\n        serial_number: Device serial number (SN field)\n        lock_status: Device lock status (LOCK field)\n    \"\"\"\n\n    model: str\n    firmware_version: str\n    sales_code: str\n    imei: str\n    serial_number: str = \"\"\n    lock_status: str = \"\"\n    aid: str = \"\"\n    cc: str = \"\"\n</code></pre>"},{"location":"api/device/#device.detect_download_mode_devices","title":"detect_download_mode_devices","text":"Python<pre><code>detect_download_mode_devices()\n</code></pre> <p>Detect Samsung devices connected in download mode (Odin mode).</p> <p>Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their device description. This is different from MTP mode devices.</p> <p>Uses pyserial's list_ports to enumerate serial ports.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected download mode devices. Empty if no devices found.</p> Source code in <code>device/detector.py</code> Python<pre><code>def detect_download_mode_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect Samsung devices connected in download mode (Odin mode).\n\n    Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their\n    device description. This is different from MTP mode devices.\n\n    Uses pyserial's list_ports to enumerate serial ports.\n\n    Returns:\n        List of detected download mode devices. Empty if no devices found.\n    \"\"\"\n    devices = []\n\n    for port in list_ports.comports():\n        # Check device description for download mode signature\n        description = port.description or \"\"\n        manufacturer = port.manufacturer or \"\"\n        product = port.product or \"\"\n\n        # Download mode devices have specific signature\n        is_download_mode = \"samsung mobile usb modem\" in description.lower()\n\n        if is_download_mode and port.device:\n            # Extract VID/PID from hardware ID\n            hwid = port.hwid or \"\"\n            vid, pid = _extract_vid_pid(hwid)\n\n            devices.append(\n                DetectedDevice(\n                    port_name=port.device,\n                    device_name=description,\n                    manufacturer=manufacturer,\n                    product=product,\n                    vid=vid,\n                    pid=pid,\n                )\n            )\n\n    return devices\n</code></pre>"},{"location":"api/device/#device.detect_samsung_devices","title":"detect_samsung_devices","text":"Python<pre><code>detect_samsung_devices()\n</code></pre> <p>Detect all Samsung devices (alias for detect_download_mode_devices).</p> <p>This function is kept for backward compatibility but now detects download mode devices only.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected devices with port information. Empty if no devices found.</p> Source code in <code>device/detector.py</code> Python<pre><code>def detect_samsung_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect all Samsung devices (alias for detect_download_mode_devices).\n\n    This function is kept for backward compatibility but now detects\n    download mode devices only.\n\n    Returns:\n        List of detected devices with port information. Empty if no devices found.\n    \"\"\"\n    return detect_download_mode_devices()\n</code></pre>"},{"location":"api/device/#device.get_first_device","title":"get_first_device","text":"Python<pre><code>get_first_device()\n</code></pre> <p>Get the first detected Samsung device in download mode.</p> <p>Convenience function for single-device scenarios.</p> <p>Returns:</p> Type Description <code>DetectedDevice</code> <p>First detected device</p> <p>Raises:</p> Type Description <code>DeviceNotFoundError</code> <p>If no Samsung devices are connected in download mode</p> Source code in <code>device/detector.py</code> Python<pre><code>def get_first_device() -&gt; DetectedDevice:\n    \"\"\"Get the first detected Samsung device in download mode.\n\n    Convenience function for single-device scenarios.\n\n    Returns:\n        First detected device\n\n    Raises:\n        DeviceNotFoundError: If no Samsung devices are connected in download mode\n    \"\"\"\n    devices = detect_download_mode_devices()\n    if not devices:\n        raise DeviceNotFoundError(\n            \"No Samsung devices in download mode detected. \"\n            \"Ensure device is connected in download mode (Odin mode) \"\n            \"and Samsung USB drivers are installed (Windows). \"\n            \"To enter download mode: Power off device, then hold Volume Down + Home + Power.\"\n        )\n    return devices[0]\n</code></pre>"},{"location":"api/device/#device.get_variant","title":"get_variant","text":"Python<pre><code>get_variant(response)\n</code></pre> <p>Extract protocol variant from LOKE response.</p> <p>The variant determines which initialization sequence to use.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>bytes</code> <p>8-byte response from LOKE_Initialize</p> required <p>Returns:</p> Type Description <code>int</code> <p>Protocol variant (2, 3, 4, or 5)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If response is invalid</p> Source code in <code>device/protocol.py</code> Python<pre><code>def get_variant(response: bytes) -&gt; int:\n    \"\"\"Extract protocol variant from LOKE response.\n\n    The variant determines which initialization sequence to use.\n\n    Args:\n        response: 8-byte response from LOKE_Initialize\n\n    Returns:\n        Protocol variant (2, 3, 4, or 5)\n\n    Raises:\n        ValueError: If response is invalid\n    \"\"\"\n    if len(response) &lt; 8:\n        raise ValueError(f\"Invalid response length: {len(response)}\")\n\n    # Variant is in bits 16-31 of second dword\n    value = struct.unpack_from(\"&lt;I\", response, 4)[0]\n    variant = (value &amp; 0xFFFF0000) &gt;&gt; 16\n    return variant\n</code></pre>"},{"location":"api/device/#device.parse_dvif_response","title":"parse_dvif_response","text":"Python<pre><code>parse_dvif_response(response)\n</code></pre> <p>Parse DVIF response into OdinDeviceInfo.</p> <p>The response format is: @key1=value1;key2=value2;...#</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>Raw DVIF response string</p> required <p>Returns:</p> Type Description <code>OdinDeviceInfo</code> <p>Parsed device information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If response format is invalid</p> Source code in <code>device/protocol.py</code> Python<pre><code>def parse_dvif_response(response: str) -&gt; OdinDeviceInfo:\n    \"\"\"Parse DVIF response into OdinDeviceInfo.\n\n    The response format is: @key1=value1;key2=value2;...#\n\n    Args:\n        response: Raw DVIF response string\n\n    Returns:\n        Parsed device information\n\n    Raises:\n        ValueError: If response format is invalid\n    \"\"\"\n    # Remove @ and # markers\n    cleaned = response.replace(\"#\", \"\").replace(\"@\", \"\")\n\n    if not cleaned:\n        raise ValueError(\"Empty DVIF response\")\n\n    # Parse key=value pairs\n    data = {}\n    for pair in cleaned.split(\";\"):\n        pair = pair.strip()\n        if not pair or \"=\" not in pair:\n            continue\n\n        key, value = pair.split(\"=\", 1)\n        key = key.strip().lower()\n        value = value.strip()\n\n        if key and value:\n            data[key] = value\n\n    return OdinDeviceInfo(\n        capa=data.get(\"capa\"),\n        product=data.get(\"product\"),\n        model=data.get(\"model\"),\n        fwver=data.get(\"fwver\"),\n        vendor=data.get(\"vendor\"),\n        sales=data.get(\"sales\"),\n        ver=data.get(\"ver\"),\n        did=data.get(\"did\"),\n        un=data.get(\"un\"),\n        tmu_temp=data.get(\"tmu_temp\"),\n        prov=data.get(\"prov\"),\n        raw_response=response,\n    )\n</code></pre>"},{"location":"api/device/#device.is_odin_mode","title":"is_odin_mode","text":"Python<pre><code>is_odin_mode(port_name, *, timeout=2.0)\n</code></pre> <p>Check if device is in Odin download mode.</p> <p>Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)</p> required <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if device responds with LOKE, False otherwise</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails</p> Source code in <code>device/reader.py</code> Python<pre><code>def is_odin_mode(\n    port_name: str,\n    *,\n    timeout: float = 2.0,\n) -&gt; bool:\n    \"\"\"Check if device is in Odin download mode.\n\n    Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)\n        timeout: Read timeout in seconds\n\n    Returns:\n        True if device responds with LOKE, False otherwise\n\n    Raises:\n        DeviceReadError: If serial communication fails\n    \"\"\"\n    try:\n        with serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,  # RTS/CTS hardware flow control\n        ) as port:\n            # Clear input buffer\n            port.reset_input_buffer()\n\n            # Send ODIN command\n            port.write(ODIN_COMMAND)\n            time.sleep(0.4)  # Wait for response\n\n            # Read response\n            bytes_waiting = port.in_waiting\n            if bytes_waiting &gt; 0:\n                response = port.read(bytes_waiting)\n                return LOKE_RESPONSE in response\n            return False\n\n    except serial.SerialException as ex:\n        raise DeviceReadError(\n            f\"Serial communication error on {port_name}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n</code></pre>"},{"location":"api/device/#device.read_device_info","title":"read_device_info","text":"Python<pre><code>read_device_info(\n    port_name=None, *, timeout=2.0, port_instance=None\n)\n</code></pre> <p>Read device information from Samsung device in download mode.</p> <p>Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode and parses the response.</p> <p>The device must be in download mode (Odin mode) for this to work. To enter download mode: Power off device, then hold Volume Down + Home + Power.</p> <p>IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened port via port_instance to keep the connection alive between operations.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>Optional[str]</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux). If None, auto-detects first device in download mode. Ignored if port_instance provided.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <code>port_instance</code> <code>Optional[Serial]</code> <p>Optional pre-opened serial port. If provided, port will NOT be closed.</p> <code>None</code> <p>Returns:</p> Type Description <code>OdinDeviceInfo</code> <p>Device information from Odin protocol</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails or device not in Odin mode</p> <code>ValueError</code> <p>If response cannot be parsed</p> <code>DeviceNotFoundError</code> <p>If auto-detection fails</p> Source code in <code>device/reader.py</code> Python<pre><code>def read_device_info(\n    port_name: Optional[str] = None,\n    *,\n    timeout: float = 2.0,\n    port_instance: Optional[serial.Serial] = None,\n) -&gt; OdinDeviceInfo:\n    \"\"\"Read device information from Samsung device in download mode.\n\n    Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode\n    and parses the response.\n\n    The device must be in download mode (Odin mode) for this to work.\n    To enter download mode: Power off device, then hold Volume Down + Home + Power.\n\n    IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened\n    port via port_instance to keep the connection alive between operations.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux).\n            If None, auto-detects first device in download mode. Ignored if port_instance provided.\n        timeout: Read timeout in seconds\n        port_instance: Optional pre-opened serial port. If provided, port will NOT be closed.\n\n    Returns:\n        Device information from Odin protocol\n\n    Raises:\n        DeviceReadError: If serial communication fails or device not in Odin mode\n        ValueError: If response cannot be parsed\n        DeviceNotFoundError: If auto-detection fails\n    \"\"\"\n    # Use provided port or auto-detect/open new one\n    if port_instance is not None:\n        port = port_instance\n        should_close = False\n    else:\n        # Auto-detect device if port not specified\n        if port_name is None:\n            device = get_first_device()\n            port_name = device.port_name\n\n        port = serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,\n        )\n        # Disable DTR and RTS after opening (may reset device if done before)\n        port.dtr = False\n        port.rts = False\n        should_close = True\n\n    try:\n        # Clear input buffer\n        port.reset_input_buffer()\n\n        # Send DVIF command\n        port.write(DVIF_COMMAND)\n        time.sleep(0.4)  # Wait for device response\n\n        # Read response\n        bytes_waiting = port.in_waiting\n        if bytes_waiting &gt; 0:\n            raw_response = port.read(bytes_waiting)\n            response = raw_response.decode(\"utf-8\", errors=\"replace\")\n        else:\n            response = \"\"\n\n        if not response:\n            port_desc = port_name if port_name else port.port\n            raise DeviceReadError(\n                f\"No response from device on {port_desc}. \"\n                \"Ensure device is in download mode (Odin mode). \"\n                \"To enter download mode: Power off device, \"\n                \"then hold Volume Down + Home + Power.\"\n            )\n\n        # Parse DVIF response\n        return parse_dvif_response(response)\n\n    except serial.SerialException as ex:\n        port_desc = port_name if port_name else port.port\n        raise DeviceReadError(\n            f\"Serial communication error on {port_desc}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n    finally:\n        # Only close if we created the port\n        if should_close and port.is_open:\n            port.close()\n</code></pre>"},{"location":"api/device/#device.read_device_info_at","title":"read_device_info_at","text":"Python<pre><code>read_device_info_at(port_name=None, *, timeout=2.0)\n</code></pre> <p>Read device information from Samsung device using AT commands.</p> <p>Sends AT+DEVCONINFO command to device and parses the response.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>Optional[str]</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux). If None, auto-detects first device.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ATDeviceInfo</code> <p>Device information from AT command response</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails or AT command returns no data</p> <code>DeviceNotFoundError</code> <p>If auto-detection fails</p> Source code in <code>device/reader_at.py</code> Python<pre><code>def read_device_info_at(\n    port_name: Optional[str] = None,\n    *,\n    timeout: float = 2.0,\n) -&gt; ATDeviceInfo:\n    \"\"\"Read device information from Samsung device using AT commands.\n\n    Sends AT+DEVCONINFO command to device and parses the response.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux).\n            If None, auto-detects first device.\n        timeout: Read timeout in seconds\n\n    Returns:\n        Device information from AT command response\n\n    Raises:\n        DeviceReadError: If serial communication fails or AT command returns no data\n        DeviceNotFoundError: If auto-detection fails\n    \"\"\"\n    # Auto-detect device if port not specified\n    if port_name is None:\n        device = get_first_device()\n        port_name = device.port_name\n\n    try:\n        with serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n        ) as port:\n            # Clear buffers\n            port.reset_input_buffer()\n            port.reset_output_buffer()\n\n            # Send AT command to get device info\n            command = b\"AT+DEVCONINFO\\r\\n\"\n            port.write(command)\n            time.sleep(0.3)  # Wait for response\n\n            # Read response\n            response = \"\"\n            while port.in_waiting &gt; 0:\n                chunk = port.read(port.in_waiting)\n                response += chunk.decode(\"utf-8\", errors=\"replace\")\n                time.sleep(0.1)\n\n            if not response or \"OK\" not in response:\n                raise DeviceReadError(\n                    f\"No valid AT response from device on {port_name}. \"\n                    \"Device may not support AT commands or is in wrong mode.\"\n                )\n\n            # Parse response\n            return _parse_at_response(response, port_name)\n\n    except serial.SerialException as ex:\n        raise DeviceReadError(\n            f\"Serial communication error on {port_name}: {ex}. \" \"Verify device is connected and drivers are installed.\"\n        ) from ex\n</code></pre>"},{"location":"api/device.models/","title":"Device Models","text":"<p>Data models for Samsung device information.</p> <p>This module defines the data structures for device information.</p> <p>.. deprecated::     DeviceInfo (AT command format) is deprecated. The package now uses     Odin download mode protocol. Use OdinDeviceInfo from device.protocol instead.</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.models/#device.models.DeviceInfo","title":"DeviceInfo  <code>dataclass</code>","text":"<p>Samsung device information (DEPRECATED - kept for backward compatibility).</p> <p>.. deprecated::     This class was used with AT commands for MTP mode devices.     The package now uses Odin download mode protocol.     Use OdinDeviceInfo from device.protocol instead.</p> <p>All fields are extracted from the AT+DEVCONINFO response which follows the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product); SN(serial);IMEI(imei);UN(un).</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Device model code (e.g., SM-G991B)</p> <code>device_name</code> <code>str</code> <p>Device marketing name (typically same as model)</p> <code>pda_version</code> <code>str</code> <p>PDA firmware version</p> <code>csc_version</code> <code>str</code> <p>CSC (Country Specific Code) version</p> <code>modem_version</code> <code>str</code> <p>Modem/baseband firmware version</p> <code>region</code> <code>str</code> <p>3-character CSC region code</p> <code>serial_number</code> <code>str</code> <p>Device serial number</p> <code>imei</code> <code>str</code> <p>International Mobile Equipment Identity</p> <code>unique_number</code> <code>str</code> <p>Samsung unique number (UN)</p> Source code in <code>device/models.py</code> Python<pre><code>@dataclass(frozen=True)\nclass DeviceInfo:\n    \"\"\"Samsung device information (DEPRECATED - kept for backward compatibility).\n\n    .. deprecated::\n        This class was used with AT commands for MTP mode devices.\n        The package now uses Odin download mode protocol.\n        Use OdinDeviceInfo from device.protocol instead.\n\n    All fields are extracted from the AT+DEVCONINFO response which follows\n    the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product);\n    SN(serial);IMEI(imei);UN(un).\n\n    Attributes:\n        model: Device model code (e.g., SM-G991B)\n        device_name: Device marketing name (typically same as model)\n        pda_version: PDA firmware version\n        csc_version: CSC (Country Specific Code) version\n        modem_version: Modem/baseband firmware version\n        region: 3-character CSC region code\n        serial_number: Device serial number\n        imei: International Mobile Equipment Identity\n        unique_number: Samsung unique number (UN)\n    \"\"\"\n\n    model: str\n    device_name: str\n    pda_version: str\n    csc_version: str\n    modem_version: str\n    region: str\n    serial_number: str\n    imei: str\n    unique_number: str\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return human-readable device information.\"\"\"\n        return (\n            f\"{self.model} ({self.device_name})\\n\"\n            f\"  PDA: {self.pda_version}\\n\"\n            f\"  CSC: {self.csc_version} ({self.region})\\n\"\n            f\"  Modem: {self.modem_version}\\n\"\n            f\"  IMEI: {self.imei}\\n\"\n            f\"  S/N: {self.serial_number}\\n\"\n            f\"  UN: {self.unique_number}\"\n        )\n</code></pre>"},{"location":"api/device.reader/","title":"Device Reader","text":"<p>Read device information via Odin protocol over serial port.</p> <p>This module communicates with Samsung devices in download mode (Odin mode) using the DVIF (0x44,0x56,0x49,0x46) byte protocol to retrieve firmware version, model, and device info.</p> <p>Based on SharpOdinClient implementation by Gsm Alphabet.</p> <p>Protocol: Odin/LOKE binary protocol Requires: pyserial, Samsung USB drivers (Windows), device in download mode</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.reader/#device.reader.is_odin_mode","title":"is_odin_mode","text":"Python<pre><code>is_odin_mode(port_name, *, timeout=2.0)\n</code></pre> <p>Check if device is in Odin download mode.</p> <p>Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)</p> required <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if device responds with LOKE, False otherwise</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails</p> Source code in <code>device/reader.py</code> Python<pre><code>def is_odin_mode(\n    port_name: str,\n    *,\n    timeout: float = 2.0,\n) -&gt; bool:\n    \"\"\"Check if device is in Odin download mode.\n\n    Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)\n        timeout: Read timeout in seconds\n\n    Returns:\n        True if device responds with LOKE, False otherwise\n\n    Raises:\n        DeviceReadError: If serial communication fails\n    \"\"\"\n    try:\n        with serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,  # RTS/CTS hardware flow control\n        ) as port:\n            # Clear input buffer\n            port.reset_input_buffer()\n\n            # Send ODIN command\n            port.write(ODIN_COMMAND)\n            time.sleep(0.4)  # Wait for response\n\n            # Read response\n            bytes_waiting = port.in_waiting\n            if bytes_waiting &gt; 0:\n                response = port.read(bytes_waiting)\n                return LOKE_RESPONSE in response\n            return False\n\n    except serial.SerialException as ex:\n        raise DeviceReadError(\n            f\"Serial communication error on {port_name}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n</code></pre>"},{"location":"api/device.reader/#device.reader.read_device_info","title":"read_device_info","text":"Python<pre><code>read_device_info(\n    port_name=None, *, timeout=2.0, port_instance=None\n)\n</code></pre> <p>Read device information from Samsung device in download mode.</p> <p>Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode and parses the response.</p> <p>The device must be in download mode (Odin mode) for this to work. To enter download mode: Power off device, then hold Volume Down + Home + Power.</p> <p>IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened port via port_instance to keep the connection alive between operations.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>Optional[str]</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux). If None, auto-detects first device in download mode. Ignored if port_instance provided.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <code>port_instance</code> <code>Optional[Serial]</code> <p>Optional pre-opened serial port. If provided, port will NOT be closed.</p> <code>None</code> <p>Returns:</p> Type Description <code>OdinDeviceInfo</code> <p>Device information from Odin protocol</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails or device not in Odin mode</p> <code>ValueError</code> <p>If response cannot be parsed</p> <code>DeviceNotFoundError</code> <p>If auto-detection fails</p> Source code in <code>device/reader.py</code> Python<pre><code>def read_device_info(\n    port_name: Optional[str] = None,\n    *,\n    timeout: float = 2.0,\n    port_instance: Optional[serial.Serial] = None,\n) -&gt; OdinDeviceInfo:\n    \"\"\"Read device information from Samsung device in download mode.\n\n    Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode\n    and parses the response.\n\n    The device must be in download mode (Odin mode) for this to work.\n    To enter download mode: Power off device, then hold Volume Down + Home + Power.\n\n    IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened\n    port via port_instance to keep the connection alive between operations.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux).\n            If None, auto-detects first device in download mode. Ignored if port_instance provided.\n        timeout: Read timeout in seconds\n        port_instance: Optional pre-opened serial port. If provided, port will NOT be closed.\n\n    Returns:\n        Device information from Odin protocol\n\n    Raises:\n        DeviceReadError: If serial communication fails or device not in Odin mode\n        ValueError: If response cannot be parsed\n        DeviceNotFoundError: If auto-detection fails\n    \"\"\"\n    # Use provided port or auto-detect/open new one\n    if port_instance is not None:\n        port = port_instance\n        should_close = False\n    else:\n        # Auto-detect device if port not specified\n        if port_name is None:\n            device = get_first_device()\n            port_name = device.port_name\n\n        port = serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,\n        )\n        # Disable DTR and RTS after opening (may reset device if done before)\n        port.dtr = False\n        port.rts = False\n        should_close = True\n\n    try:\n        # Clear input buffer\n        port.reset_input_buffer()\n\n        # Send DVIF command\n        port.write(DVIF_COMMAND)\n        time.sleep(0.4)  # Wait for device response\n\n        # Read response\n        bytes_waiting = port.in_waiting\n        if bytes_waiting &gt; 0:\n            raw_response = port.read(bytes_waiting)\n            response = raw_response.decode(\"utf-8\", errors=\"replace\")\n        else:\n            response = \"\"\n\n        if not response:\n            port_desc = port_name if port_name else port.port\n            raise DeviceReadError(\n                f\"No response from device on {port_desc}. \"\n                \"Ensure device is in download mode (Odin mode). \"\n                \"To enter download mode: Power off device, \"\n                \"then hold Volume Down + Home + Power.\"\n            )\n\n        # Parse DVIF response\n        return parse_dvif_response(response)\n\n    except serial.SerialException as ex:\n        port_desc = port_name if port_name else port.port\n        raise DeviceReadError(\n            f\"Serial communication error on {port_desc}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n    finally:\n        # Only close if we created the port\n        if should_close and port.is_open:\n            port.close()\n</code></pre>"},{"location":"api/download.config/","title":"Package API <code>download.config</code>","text":""},{"location":"api/download.config/#download.config","title":"download.config","text":"<p>Download module configuration.</p> <p>This module provides configuration for download paths and directories used throughout the download module.</p>"},{"location":"api/download.config/#download.config.PATHS","title":"PATHS  <code>module-attribute</code>","text":"Python<pre><code>PATHS = _resolve_paths()\n</code></pre> <p>Global paths configuration instance.</p> <p>This constant provides access to all configured paths used by the download module.</p>"},{"location":"api/download.config/#download.config.Paths","title":"Paths  <code>dataclass</code>","text":"<p>Configuration paths for download operations.</p> <p>This dataclass holds all filesystem paths used by the download module, including the data directory, database path, firmware repository, and decrypted firmware output directory.</p> <p>Attributes:</p> Name Type Description <code>data_dir</code> <code>Path</code> <p>Root directory for application data storage.</p> <code>db_path</code> <code>Path</code> <p>Path to the SQLite database file.</p> <code>firmware_dir</code> <code>Path</code> <p>Directory where encrypted firmware files (.enc4) are stored.</p> <code>decrypted_dir</code> <code>Path</code> <p>Directory where decrypted firmware files are stored.</p> Source code in <code>download/config.py</code> Python<pre><code>@dataclass(frozen=True)\nclass Paths:\n    \"\"\"Configuration paths for download operations.\n\n    This dataclass holds all filesystem paths used by the download module,\n    including the data directory, database path, firmware repository, and\n    decrypted firmware output directory.\n\n    Attributes:\n        data_dir: Root directory for application data storage.\n        db_path: Path to the SQLite database file.\n        firmware_dir: Directory where encrypted firmware files (.enc4) are stored.\n        decrypted_dir: Directory where decrypted firmware files are stored.\n    \"\"\"\n\n    data_dir: Path\n    db_path: Path\n    firmware_dir: Path\n    decrypted_dir: Path\n</code></pre>"},{"location":"api/download.db/","title":"Package API <code>download.db</code>","text":""},{"location":"api/download.db/#download.db","title":"download.db","text":"<p>Database connection and schema management.</p> <p>This module provides database connection utilities, schema initialization, and database health/repair operations for the firmware download system.</p>"},{"location":"api/download.db/#download.db.get_db_path","title":"get_db_path","text":"Python<pre><code>get_db_path()\n</code></pre> <p>Get the path to the SQLite database file.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Absolute path to the database file.</p> Source code in <code>download/db.py</code> Python<pre><code>def get_db_path() -&gt; Path:\n    \"\"\"Get the path to the SQLite database file.\n\n    Returns:\n        Path: Absolute path to the database file.\n    \"\"\"\n    return PATHS.db_path\n</code></pre>"},{"location":"api/download.db/#download.db.connect","title":"connect","text":"Python<pre><code>connect()\n</code></pre> <p>Open a SQLite connection with optimized PRAGMAs.</p> <p>Creates the data directory if it doesn't exist and establishes a database connection with WAL mode, reasonable timeouts, and other performance settings. One connection per thread/process is recommended.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>sqlite3.Connection: Configured database connection with Row factory enabled.</p> Note <p>The connection uses autocommit mode (isolation_level=None), so transactions must be managed explicitly with BEGIN/COMMIT/ROLLBACK.</p> Source code in <code>download/db.py</code> Python<pre><code>def connect() -&gt; sqlite3.Connection:\n    \"\"\"Open a SQLite connection with optimized PRAGMAs.\n\n    Creates the data directory if it doesn't exist and establishes a database\n    connection with WAL mode, reasonable timeouts, and other performance settings.\n    One connection per thread/process is recommended.\n\n    Returns:\n        sqlite3.Connection: Configured database connection with Row factory enabled.\n\n    Note:\n        The connection uses autocommit mode (isolation_level=None), so transactions\n        must be managed explicitly with BEGIN/COMMIT/ROLLBACK.\n    \"\"\"\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    conn = sqlite3.connect(\n        PATHS.db_path,\n        timeout=10.0,\n        isolation_level=None,\n        check_same_thread=False,\n    )\n    conn.row_factory = sqlite3.Row\n    _apply_pragmas(conn)\n    return conn\n</code></pre>"},{"location":"api/download.db/#download.db.init_db","title":"init_db","text":"Python<pre><code>init_db()\n</code></pre> <p>Initialize the database schema.</p> <p>Creates the data directory and database tables if they don't exist. Note: executescript() implicitly commits, so no manual transaction control needed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If schema creation fails</p> Source code in <code>download/db.py</code> Python<pre><code>def init_db() -&gt; None:\n    \"\"\"Initialize the database schema.\n\n    Creates the data directory and database tables if they don't exist.\n    Note: executescript() implicitly commits, so no manual transaction control needed.\n\n    Raises:\n        Exception: If schema creation fails\n    \"\"\"\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    with connect() as conn:\n        conn.executescript(SCHEMA_SQL)\n</code></pre>"},{"location":"api/download.db/#download.db.is_healthy","title":"is_healthy","text":"Python<pre><code>is_healthy()\n</code></pre> <p>Check database integrity.</p> <p>Runs SQLite's integrity_check pragma to verify the database is not corrupted.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if database passes integrity check, False otherwise.</p> Source code in <code>download/db.py</code> Python<pre><code>def is_healthy() -&gt; bool:\n    \"\"\"Check database integrity.\n\n    Runs SQLite's integrity_check pragma to verify the database is not corrupted.\n\n    Returns:\n        bool: True if database passes integrity check, False otherwise.\n    \"\"\"\n    try:\n        with sqlite3.connect(PATHS.db_path) as conn:\n            cur = conn.cursor()\n            cur.execute(\"PRAGMA integrity_check(1);\")\n            row = cur.fetchone()\n            cur.close()\n            return row is not None and row[0] == \"ok\"\n    except sqlite3.DatabaseError:\n        return False\n</code></pre>"},{"location":"api/download.db/#download.db.repair_db","title":"repair_db","text":"Python<pre><code>repair_db()\n</code></pre> <p>Attempt to repair a corrupted SQLite database.</p> <p>If the database fails the integrity check, this function performs a dump to a temporary SQL file, deletes the corrupted database, and restores from the dump into a new database file.</p> The process <ol> <li>Check if database is healthy (returns immediately if healthy)</li> <li>Dump database to temporary SQL file</li> <li>Delete the corrupted database file</li> <li>Restore from the SQL dump</li> <li>Clean up temporary dump file</li> </ol> Source code in <code>download/db.py</code> Python<pre><code>def repair_db() -&gt; None:\n    \"\"\"Attempt to repair a corrupted SQLite database.\n\n    If the database fails the integrity check, this function performs a dump\n    to a temporary SQL file, deletes the corrupted database, and restores\n    from the dump into a new database file.\n\n    The process:\n        1. Check if database is healthy (returns immediately if healthy)\n        2. Dump database to temporary SQL file\n        3. Delete the corrupted database file\n        4. Restore from the SQL dump\n        5. Clean up temporary dump file\n    \"\"\"\n    if is_healthy():\n        return\n\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    temp_dump_path = PATHS.data_dir / \"temp_dump.sql\"\n    _dump_db(temp_dump_path)\n\n    try:\n        PATHS.db_path.unlink()\n    except FileNotFoundError:\n        pass\n\n    _restore_db(temp_dump_path)\n\n    try:\n        temp_dump_path.unlink()\n    except FileNotFoundError:\n        pass\n</code></pre>"},{"location":"api/download.firmware_repository/","title":"Firmware Repository","text":""},{"location":"api/download.firmware_repository/#download.firmware_repository","title":"download.firmware_repository","text":"<p>Repository layer for firmware management.</p> <p>This module provides the data access layer for managing firmware files in the repository database using the repository pattern.</p>"},{"location":"api/download.firmware_repository/#download.firmware_repository.FirmwareRecord","title":"FirmwareRecord  <code>dataclass</code>","text":"<p>Firmware repository record.</p> <p>Represents a firmware entry with all metadata from FUS inform response and local file paths.</p> <p>Attributes:</p> Name Type Description <code>version_code</code> <code>str</code> <p>Firmware version identifier (format: AAA/BBB/CCC/DDD).</p> <code>filename</code> <code>str</code> <p>Binary firmware filename from FUS server.</p> <code>path</code> <code>str</code> <p>Server model path from FUS inform response.</p> <code>size_bytes</code> <code>int</code> <p>File size in bytes.</p> <code>logic_value_factory</code> <code>str</code> <p>Logic value for ENC4 decryption key derivation.</p> <code>latest_fw_version</code> <code>str</code> <p>Latest firmware version from inform response.</p> <code>encrypted_file_path</code> <code>str</code> <p>Absolute path to encrypted (.enc4) file on disk.</p> <code>decrypted_file_path</code> <code>str | None</code> <p>Absolute path to decrypted file, or None if not decrypted.</p> Source code in <code>download/firmware_repository.py</code> Python<pre><code>@dataclass\nclass FirmwareRecord:\n    \"\"\"Firmware repository record.\n\n    Represents a firmware entry with all metadata from FUS inform response\n    and local file paths.\n\n    Attributes:\n        version_code: Firmware version identifier (format: AAA/BBB/CCC/DDD).\n        filename: Binary firmware filename from FUS server.\n        path: Server model path from FUS inform response.\n        size_bytes: File size in bytes.\n        logic_value_factory: Logic value for ENC4 decryption key derivation.\n        latest_fw_version: Latest firmware version from inform response.\n        encrypted_file_path: Absolute path to encrypted (.enc4) file on disk.\n        decrypted_file_path: Absolute path to decrypted file, or None if not decrypted.\n    \"\"\"\n\n    version_code: str\n    filename: str\n    path: str\n    size_bytes: int\n    logic_value_factory: str\n    latest_fw_version: str\n    encrypted_file_path: str\n    decrypted_file_path: str | None\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.upsert_firmware","title":"upsert_firmware","text":"Python<pre><code>upsert_firmware(rec)\n</code></pre> <p>Insert or update a firmware record.</p> <p>Creates a new firmware record or updates an existing one if a record with the same version_code already exists. The operation is performed within a transaction.</p> <p>Parameters:</p> Name Type Description Default <code>rec</code> <code>FirmwareRecord</code> <p>Firmware record to insert or update.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the database operation fails, the exception is re-raised after rolling back the transaction.</p> Source code in <code>download/firmware_repository.py</code> Python<pre><code>def upsert_firmware(rec: FirmwareRecord) -&gt; None:\n    \"\"\"Insert or update a firmware record.\n\n    Creates a new firmware record or updates an existing one if a record with\n    the same version_code already exists. The operation is performed within\n    a transaction.\n\n    Args:\n        rec: Firmware record to insert or update.\n\n    Raises:\n        Exception: If the database operation fails, the exception is re-raised\n            after rolling back the transaction.\n    \"\"\"\n    sql = \"\"\"\n    INSERT INTO firmware (version_code, filename, path, size_bytes,\n                          logic_value_factory, latest_fw_version,\n                          encrypted_file_path, decrypted_file_path)\n    VALUES (:version_code, :filename, :path, :size_bytes,\n            :logic_value_factory, :latest_fw_version,\n            :encrypted_file_path, :decrypted_file_path)\n    ON CONFLICT(version_code) DO UPDATE SET\n        filename=excluded.filename,\n        path=excluded.path,\n        size_bytes=excluded.size_bytes,\n        logic_value_factory=excluded.logic_value_factory,\n        latest_fw_version=excluded.latest_fw_version,\n        encrypted_file_path=excluded.encrypted_file_path,\n        decrypted_file_path=excluded.decrypted_file_path;\n    \"\"\"\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.execute(sql, rec.__dict__)\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.find_firmware","title":"find_firmware","text":"Python<pre><code>find_firmware(version_code)\n</code></pre> <p>Find a specific firmware record by version code.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier to search for.</p> required <p>Returns:</p> Type Description <code>Optional[FirmwareRecord]</code> <p>FirmwareRecord if found, None otherwise.</p> Source code in <code>download/firmware_repository.py</code> Python<pre><code>def find_firmware(version_code: str) -&gt; Optional[FirmwareRecord]:\n    \"\"\"Find a specific firmware record by version code.\n\n    Args:\n        version_code: Firmware version identifier to search for.\n\n    Returns:\n        FirmwareRecord if found, None otherwise.\n    \"\"\"\n    sql = \"\"\"\n    SELECT version_code, filename, path, size_bytes,\n           logic_value_factory, latest_fw_version,\n           encrypted_file_path, decrypted_file_path\n    FROM firmware\n    WHERE version_code=?;\n    \"\"\"\n    with connect() as conn:\n        row = conn.execute(sql, (version_code,)).fetchone()\n        if not row:\n            return None\n        return FirmwareRecord(\n            version_code=row[0],\n            filename=row[1],\n            path=row[2],\n            size_bytes=row[3],\n            logic_value_factory=row[4],\n            latest_fw_version=row[5],\n            encrypted_file_path=row[6],\n            decrypted_file_path=row[7],\n        )\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.list_firmware","title":"list_firmware","text":"Python<pre><code>list_firmware(limit=None)\n</code></pre> <p>List all firmware records.</p> <p>Yields firmware records ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to return, or None for all.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>FirmwareRecord</code> <code>Iterable[FirmwareRecord]</code> <p>Each firmware entry in the repository.</p> Source code in <code>download/firmware_repository.py</code> Python<pre><code>def list_firmware(limit: Optional[int] = None) -&gt; Iterable[FirmwareRecord]:\n    \"\"\"List all firmware records.\n\n    Yields firmware records ordered by creation date (newest first).\n\n    Args:\n        limit: Maximum number of records to return, or None for all.\n\n    Yields:\n        FirmwareRecord: Each firmware entry in the repository.\n    \"\"\"\n    sql = \"\"\"\n    SELECT version_code, filename, path, size_bytes,\n           logic_value_factory, latest_fw_version,\n           encrypted_file_path, decrypted_file_path\n    FROM firmware\n    ORDER BY created_at DESC\n    \"\"\"\n    if limit:\n        sql += f\" LIMIT {int(limit)}\"\n    sql += \";\"\n\n    with connect() as conn:\n        for row in conn.execute(sql):\n            yield FirmwareRecord(\n                version_code=row[0],\n                filename=row[1],\n                path=row[2],\n                size_bytes=row[3],\n                logic_value_factory=row[4],\n                latest_fw_version=row[5],\n                encrypted_file_path=row[6],\n                decrypted_file_path=row[7],\n            )\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.update_decrypted_path","title":"update_decrypted_path","text":"Python<pre><code>update_decrypted_path(version_code, decrypted_path)\n</code></pre> <p>Update the decrypted file path for a firmware record.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier.</p> required <code>decrypted_path</code> <code>str</code> <p>Absolute path to the decrypted file.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the database operation fails.</p> Source code in <code>download/firmware_repository.py</code> Python<pre><code>def update_decrypted_path(version_code: str, decrypted_path: str) -&gt; None:\n    \"\"\"Update the decrypted file path for a firmware record.\n\n    Args:\n        version_code: Firmware version identifier.\n        decrypted_path: Absolute path to the decrypted file.\n\n    Raises:\n        Exception: If the database operation fails.\n    \"\"\"\n    sql = \"\"\"\n    UPDATE firmware\n    SET decrypted_file_path=?\n    WHERE version_code=?;\n    \"\"\"\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.execute(sql, (decrypted_path, version_code))\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.delete_firmware","title":"delete_firmware","text":"Python<pre><code>delete_firmware(version_code)\n</code></pre> <p>Delete a firmware record by version code.</p> <p>Removes the firmware row from the repository. This does not delete any files on disk; callers should remove associated files before invoking.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier to delete.</p> required Source code in <code>download/firmware_repository.py</code> Python<pre><code>def delete_firmware(version_code: str) -&gt; None:\n    \"\"\"Delete a firmware record by version code.\n\n    Removes the firmware row from the repository. This does not delete any\n    files on disk; callers should remove associated files before invoking.\n\n    Args:\n        version_code: Firmware version identifier to delete.\n    \"\"\"\n    sql = \"DELETE FROM firmware WHERE version_code=?;\"\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.execute(sql, (version_code,))\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.imei_repository/","title":"Package API <code>download.imei_repository</code>","text":""},{"location":"api/download.imei_repository/#download.imei_repository","title":"download.imei_repository","text":"<p>Repository layer for IMEI event logging.</p> <p>This module provides data access functions for tracking IMEI-based firmware queries and upgrade operations. Events are logged with FUS status and upgrade status for traceability.</p>"},{"location":"api/download.imei_repository/#download.imei_repository.IMEIEvent","title":"IMEIEvent  <code>dataclass</code>","text":"<p>IMEI event record.</p> <p>Represents a logged IMEI-based firmware query or upgrade operation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Database record ID, or None for new records.</p> <code>session_id</code> <code>str</code> <p>Application session identifier (changes per app launch).</p> <code>imei</code> <code>str</code> <p>Device IMEI number.</p> <code>model</code> <code>str</code> <p>Device model identifier.</p> <code>csc</code> <code>str</code> <p>Country Specific Code.</p> <code>aid</code> <code>str | None</code> <p>Application ID, or None.</p> <code>cc</code> <code>str | None</code> <p>Country Code, or None.</p> <code>version_code</code> <code>str</code> <p>Actual device firmware version (PDA/CSC/MODEM/BOOTLOADER format from AT).</p> <code>fota_version</code> <code>str | None</code> <p>FOTA/FUS firmware version (AAA/BBB/CCC/DDD format), or None.</p> <code>serial_number</code> <code>str | None</code> <p>Device serial number (SN from AT), or None.</p> <code>lock_status</code> <code>str | None</code> <p>Device lock status (LOCK from AT), or None.</p> <code>status_fus</code> <code>str</code> <p>FUS query status (ok, error, denied, unauthorized, throttled, unknown).</p> <code>status_upgrade</code> <code>str</code> <p>Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown).</p> <code>created_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of event creation, or None.</p> <code>updated_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of last update, or None.</p> <code>upgrade_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of upgrade operation, or None.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>@dataclass\nclass IMEIEvent:\n    \"\"\"IMEI event record.\n\n    Represents a logged IMEI-based firmware query or upgrade operation.\n\n    Attributes:\n        id: Database record ID, or None for new records.\n        session_id: Application session identifier (changes per app launch).\n        imei: Device IMEI number.\n        model: Device model identifier.\n        csc: Country Specific Code.\n        aid: Application ID, or None.\n        cc: Country Code, or None.\n        version_code: Actual device firmware version (PDA/CSC/MODEM/BOOTLOADER format from AT).\n        fota_version: FOTA/FUS firmware version (AAA/BBB/CCC/DDD format), or None.\n        serial_number: Device serial number (SN from AT), or None.\n        lock_status: Device lock status (LOCK from AT), or None.\n        status_fus: FUS query status (ok, error, denied, unauthorized, throttled, unknown).\n        status_upgrade: Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown).\n        created_at: ISO 8601 UTC timestamp of event creation, or None.\n        updated_at: ISO 8601 UTC timestamp of last update, or None.\n        upgrade_at: ISO 8601 UTC timestamp of upgrade operation, or None.\n    \"\"\"\n\n    id: int | None\n    session_id: str\n    imei: str\n    model: str\n    csc: str\n    version_code: str\n    fota_version: str | None = None\n    serial_number: str | None = None\n    lock_status: str | None = None\n    aid: str | None = None\n    cc: str | None = None\n    status_fus: str = \"unknown\"  # ok/error/denied/unauthorized/throttled/unknown\n    status_upgrade: str = \"unknown\"  # queued/in_progress/ok/failed/skipped/unknown\n    created_at: str | None = None  # ISO-8601 UTC\n    updated_at: str | None = None  # ISO-8601 UTC\n    upgrade_at: str | None = None  # ISO-8601 UTC\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.upsert_imei_event","title":"upsert_imei_event","text":"Python<pre><code>upsert_imei_event(\n    *,\n    session_id,\n    imei,\n    model,\n    csc,\n    version_code,\n    fota_version=None,\n    serial_number=None,\n    lock_status=None,\n    aid=None,\n    cc=None,\n    status_fus=\"unknown\",\n    status_upgrade=\"unknown\",\n    upgrade_at=None\n)\n</code></pre> <p>Insert or update IMEI event record for current session.</p> <p>Creates a new IMEI event log entry, or updates the existing one if a record with the same session_id and imei already exists. This ensures one record per device per application session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Application session identifier (generated at app launch).</p> required <code>imei</code> <code>str</code> <p>Device IMEI number.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>aid</code> <code>str | None</code> <p>Optional Application ID.</p> <code>None</code> <code>cc</code> <code>str | None</code> <p>Optional Country Code.</p> <code>None</code> <code>version_code</code> <code>str</code> <p>Actual device firmware version (PDA/CSC/MODEM/BOOTLOADER format).</p> required <code>fota_version</code> <code>str | None</code> <p>Optional FOTA/FUS firmware version (AAA/BBB/CCC/DDD format).</p> <code>None</code> <code>serial_number</code> <code>str | None</code> <p>Optional device serial number (SN from AT).</p> <code>None</code> <code>lock_status</code> <code>str | None</code> <p>Optional device lock status (LOCK from AT).</p> <code>None</code> <code>status_fus</code> <code>str</code> <p>FUS query status. Defaults to \"unknown\".</p> <code>'unknown'</code> <code>status_upgrade</code> <code>str</code> <p>Upgrade operation status. Defaults to \"unknown\".</p> <code>'unknown'</code> <code>upgrade_at</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp of upgrade operation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Database ID of the inserted or updated record.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def upsert_imei_event(\n    *,\n    session_id: str,\n    imei: str,\n    model: str,\n    csc: str,\n    version_code: str,\n    fota_version: str | None = None,\n    serial_number: str | None = None,\n    lock_status: str | None = None,\n    aid: str | None = None,\n    cc: str | None = None,\n    status_fus: str = \"unknown\",\n    status_upgrade: str = \"unknown\",\n    upgrade_at: str | None = None,\n) -&gt; int:\n    \"\"\"Insert or update IMEI event record for current session.\n\n    Creates a new IMEI event log entry, or updates the existing one if a record\n    with the same session_id and imei already exists. This ensures one record\n    per device per application session.\n\n    Args:\n        session_id: Application session identifier (generated at app launch).\n        imei: Device IMEI number.\n        model: Device model identifier.\n        csc: Country Specific Code.\n        aid: Optional Application ID.\n        cc: Optional Country Code.\n        version_code: Actual device firmware version (PDA/CSC/MODEM/BOOTLOADER format).\n        fota_version: Optional FOTA/FUS firmware version (AAA/BBB/CCC/DDD format).\n        serial_number: Optional device serial number (SN from AT).\n        lock_status: Optional device lock status (LOCK from AT).\n        status_fus: FUS query status. Defaults to \"unknown\".\n        status_upgrade: Upgrade operation status. Defaults to \"unknown\".\n        upgrade_at: Optional ISO 8601 UTC timestamp of upgrade operation.\n\n    Returns:\n        int: Database ID of the inserted or updated record.\n    \"\"\"\n    sql = \"\"\"\n    INSERT INTO imei_log\n        (session_id, imei, model, csc, version_code, fota_version, serial_number, lock_status, aid, cc,\n         status_fus, status_upgrade, created_at, updated_at, upgrade_at)\n    VALUES\n        (:session_id, :imei, :model, :csc, :version_code, :fota_version, :serial_number, :lock_status, :aid, :cc,\n         :status_fus, :status_upgrade, :created_at, :updated_at, :upgrade_at)\n    ON CONFLICT(session_id, imei) DO UPDATE SET\n        model=excluded.model,\n        csc=excluded.csc,\n        version_code=excluded.version_code,\n        fota_version=excluded.fota_version,\n        serial_number=excluded.serial_number,\n        lock_status=excluded.lock_status,\n        aid=excluded.aid,\n        cc=excluded.cc,\n        status_fus=excluded.status_fus,\n        status_upgrade=excluded.status_upgrade,\n        updated_at=excluded.updated_at,\n        upgrade_at=excluded.upgrade_at;\n    \"\"\"\n    now = _iso_now()\n    params = {\n        \"session_id\": session_id,\n        \"imei\": imei,\n        \"model\": model,\n        \"csc\": csc,\n        \"version_code\": version_code,\n        \"fota_version\": fota_version,\n        \"serial_number\": serial_number,\n        \"lock_status\": lock_status,\n        \"aid\": aid,\n        \"cc\": cc,\n        \"status_fus\": status_fus,\n        \"status_upgrade\": status_upgrade,\n        \"created_at\": now,\n        \"updated_at\": now,\n        \"upgrade_at\": upgrade_at,\n    }\n    with connect() as conn:\n        cur = conn.execute(sql, params)\n        return int(cur.lastrowid)  # type: ignore\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.add_imei_event","title":"add_imei_event","text":"Python<pre><code>add_imei_event(\n    *,\n    imei,\n    model,\n    csc,\n    version_code,\n    fota_version=None,\n    serial_number=None,\n    lock_status=None,\n    aid=None,\n    cc=None,\n    status_fus=\"unknown\",\n    status_upgrade=\"unknown\",\n    upgrade_at=None,\n    session_id=\"legacy\"\n)\n</code></pre> <p>Legacy function - use upsert_imei_event instead.</p> <p>Kept for backward compatibility. New code should use upsert_imei_event.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def add_imei_event(\n    *,\n    imei: str,\n    model: str,\n    csc: str,\n    version_code: str,\n    fota_version: str | None = None,\n    serial_number: str | None = None,\n    lock_status: str | None = None,\n    aid: str | None = None,\n    cc: str | None = None,\n    status_fus: str = \"unknown\",\n    status_upgrade: str = \"unknown\",\n    upgrade_at: str | None = None,\n    session_id: str = \"legacy\",\n) -&gt; int:\n    \"\"\"Legacy function - use upsert_imei_event instead.\n\n    Kept for backward compatibility. New code should use upsert_imei_event.\n    \"\"\"\n    return upsert_imei_event(\n        session_id=session_id,\n        imei=imei,\n        model=model,\n        csc=csc,\n        version_code=version_code,\n        fota_version=fota_version,\n        serial_number=serial_number,\n        lock_status=lock_status,\n        status_fus=status_fus,\n        status_upgrade=status_upgrade,\n        upgrade_at=upgrade_at,\n        aid=aid,\n        cc=cc,\n    )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.set_upgrade_status","title":"set_upgrade_status","text":"Python<pre><code>set_upgrade_status(id_, status_upgrade, upgrade_at=None)\n</code></pre> <p>Update the upgrade status for an existing event.</p> <p>Updates the upgrade status and timestamp for a previously logged IMEI event.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>Database ID of the event to update.</p> required <code>status_upgrade</code> <code>str</code> <p>New upgrade status (e.g., ok, failed, skipped).</p> required <code>upgrade_at</code> <code>Optional[str]</code> <p>Optional ISO 8601 UTC timestamp. If None, current time is used.</p> <code>None</code> Source code in <code>download/imei_repository.py</code> Python<pre><code>def set_upgrade_status(id_: int, status_upgrade: str, upgrade_at: Optional[str] = None) -&gt; None:\n    \"\"\"Update the upgrade status for an existing event.\n\n    Updates the upgrade status and timestamp for a previously logged IMEI event.\n\n    Args:\n        id_: Database ID of the event to update.\n        status_upgrade: New upgrade status (e.g., ok, failed, skipped).\n        upgrade_at: Optional ISO 8601 UTC timestamp. If None, current time is used.\n    \"\"\"\n    if upgrade_at is None:\n        upgrade_at = _iso_now()\n    sql = \"\"\"\n    UPDATE imei_log\n       SET status_upgrade = :status_upgrade,\n           upgrade_at = :upgrade_at\n     WHERE id = :id\n    \"\"\"\n    with connect() as conn:\n        conn.execute(sql, {\"status_upgrade\": status_upgrade, \"upgrade_at\": upgrade_at, \"id\": id_})\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_by_imei","title":"list_by_imei","text":"Python<pre><code>list_by_imei(imei, *, limit=200, offset=0)\n</code></pre> <p>List IMEI events for a specific IMEI number.</p> <p>Retrieves event records for a given IMEI, ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>Device IMEI number to search for.</p> required <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 200.</p> <code>200</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the IMEI, ordered by created_at descending.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def list_by_imei(imei: str, *, limit: int = 200, offset: int = 0) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events for a specific IMEI number.\n\n    Retrieves event records for a given IMEI, ordered by creation date (newest first).\n\n    Args:\n        imei: Device IMEI number to search for.\n        limit: Maximum number of records to return. Defaults to 200.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the IMEI, ordered by created_at descending.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE imei = ?\n     ORDER BY created_at DESC\n     LIMIT ? OFFSET ?;\n    \"\"\"\n    with connect() as conn:\n        for row in conn.execute(sql, (imei, limit, offset)):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                session_id=row[\"session_id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                fota_version=row.get(\"fota_version\"),\n                serial_number=row.get(\"serial_number\"),\n                lock_status=row.get(\"lock_status\"),\n                aid=row.get(\"aid\"),\n                cc=row.get(\"cc\"),\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_by_model_csc","title":"list_by_model_csc","text":"Python<pre><code>list_by_model_csc(\n    model,\n    csc,\n    *,\n    since=None,\n    until=None,\n    limit=200,\n    offset=0\n)\n</code></pre> <p>List IMEI events for a specific model and CSC combination.</p> <p>Retrieves event records filtered by model and CSC, with optional date range filtering. Results are ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum created_at filter.</p> <code>None</code> <code>until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum created_at filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 200.</p> <code>200</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the filters, ordered by created_at descending.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def list_by_model_csc(\n    model: str,\n    csc: str,\n    *,\n    since: str | None = None,\n    until: str | None = None,\n    limit: int = 200,\n    offset: int = 0,\n) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events for a specific model and CSC combination.\n\n    Retrieves event records filtered by model and CSC, with optional date range\n    filtering. Results are ordered by creation date (newest first).\n\n    Args:\n        model: Device model identifier.\n        csc: Country Specific Code.\n        since: Optional ISO 8601 UTC timestamp for minimum created_at filter.\n        until: Optional ISO 8601 UTC timestamp for maximum created_at filter.\n        limit: Maximum number of records to return. Defaults to 200.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the filters, ordered by created_at descending.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE model = :model AND csc = :csc\n       AND (:since IS NULL OR created_at &gt;= :since)\n       AND (:until IS NULL OR created_at &lt;= :until)\n     ORDER BY created_at DESC\n     LIMIT :limit OFFSET :offset;\n    \"\"\"\n    with connect() as conn:\n        for row in conn.execute(\n            sql,\n            {\n                \"model\": model,\n                \"csc\": csc,\n                \"since\": since,\n                \"until\": until,\n                \"limit\": limit,\n                \"offset\": offset,\n            },\n        ):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                session_id=row[\"session_id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                fota_version=row.get(\"fota_version\"),\n                serial_number=row.get(\"serial_number\"),\n                lock_status=row.get(\"lock_status\"),\n                aid=row.get(\"aid\"),\n                cc=row.get(\"cc\"),\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_between_dates","title":"list_between_dates","text":"Python<pre><code>list_between_dates(\n    *,\n    created_since=None,\n    created_until=None,\n    upgrade_since=None,\n    upgrade_until=None,\n    limit=500,\n    offset=0\n)\n</code></pre> <p>List IMEI events filtered by creation and/or upgrade date ranges.</p> <p>Retrieves event records with flexible date range filtering on both creation and upgrade timestamps. All filters are optional and can be combined.</p> <p>Parameters:</p> Name Type Description Default <code>created_since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum created_at filter.</p> <code>None</code> <code>created_until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum created_at filter.</p> <code>None</code> <code>upgrade_since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum upgrade_at filter.</p> <code>None</code> <code>upgrade_until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum upgrade_at filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 500.</p> <code>500</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the date filters, ordered by created_at descending.</p> Note <p>Upgrade date filters only match records where upgrade_at is not NULL.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def list_between_dates(\n    *,\n    created_since: str | None = None,\n    created_until: str | None = None,\n    upgrade_since: str | None = None,\n    upgrade_until: str | None = None,\n    limit: int = 500,\n    offset: int = 0,\n) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events filtered by creation and/or upgrade date ranges.\n\n    Retrieves event records with flexible date range filtering on both creation\n    and upgrade timestamps. All filters are optional and can be combined.\n\n    Args:\n        created_since: Optional ISO 8601 UTC timestamp for minimum created_at filter.\n        created_until: Optional ISO 8601 UTC timestamp for maximum created_at filter.\n        upgrade_since: Optional ISO 8601 UTC timestamp for minimum upgrade_at filter.\n        upgrade_until: Optional ISO 8601 UTC timestamp for maximum upgrade_at filter.\n        limit: Maximum number of records to return. Defaults to 500.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the date filters, ordered by created_at descending.\n\n    Note:\n        Upgrade date filters only match records where upgrade_at is not NULL.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE (:cs IS NULL OR created_at &gt;= :cs)\n       AND (:cu IS NULL OR created_at &lt;= :cu)\n       AND (:us IS NULL OR (upgrade_at IS NOT NULL AND upgrade_at &gt;= :us))\n       AND (:uu IS NULL OR (upgrade_at IS NOT NULL AND upgrade_at &lt;= :uu))\n     ORDER BY created_at DESC\n     LIMIT :limit OFFSET :offset;\n    \"\"\"\n    params = {\n        \"cs\": created_since,\n        \"cu\": created_until,\n        \"us\": upgrade_since,\n        \"uu\": upgrade_until,\n        \"limit\": limit,\n        \"offset\": offset,\n    }\n    with connect() as conn:\n        for row in conn.execute(sql, params):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                session_id=row[\"session_id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                fota_version=row.get(\"fota_version\"),\n                serial_number=row.get(\"serial_number\"),\n                lock_status=row.get(\"lock_status\"),\n                aid=row.get(\"aid\"),\n                cc=row.get(\"cc\"),\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.last_status_by_imei","title":"last_status_by_imei","text":"Python<pre><code>last_status_by_imei(imei)\n</code></pre> <p>Get the most recent IMEI event for a specific IMEI number.</p> <p>Retrieves the latest event record (by creation date) for the given IMEI.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>Device IMEI number to search for.</p> required <p>Returns:</p> Type Description <code>IMEIEvent | None</code> <p>IMEIEvent if found, None if no events exist for this IMEI.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def last_status_by_imei(imei: str) -&gt; IMEIEvent | None:\n    \"\"\"Get the most recent IMEI event for a specific IMEI number.\n\n    Retrieves the latest event record (by creation date) for the given IMEI.\n\n    Args:\n        imei: Device IMEI number to search for.\n\n    Returns:\n        IMEIEvent if found, None if no events exist for this IMEI.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE imei = ?\n     ORDER BY created_at DESC\n     LIMIT 1;\n    \"\"\"\n    with connect() as conn:\n        row = conn.execute(sql, (imei,)).fetchone()\n        if not row:\n            return None\n        return IMEIEvent(\n            id=row[\"id\"],\n            session_id=row[\"session_id\"],\n            imei=row[\"imei\"],\n            model=row[\"model\"],\n            csc=row[\"csc\"],\n            version_code=row[\"version_code\"],\n            fota_version=row.get(\"fota_version\"),\n            serial_number=row.get(\"serial_number\"),\n            lock_status=row.get(\"lock_status\"),\n            aid=row.get(\"aid\"),\n            cc=row.get(\"cc\"),\n            status_fus=row[\"status_fus\"],\n            status_upgrade=row[\"status_upgrade\"],\n            created_at=row[\"created_at\"],\n            updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n            upgrade_at=row[\"upgrade_at\"],\n        )\n</code></pre>"},{"location":"api/download.service/","title":"Package API <code>download.service</code>","text":""},{"location":"api/download.service/#download.service","title":"download.service","text":"<p>Firmware download and management service.</p> <p>This module provides high-level firmware management functionality including FOTA version checking, firmware download with repository management, and decryption services.</p>"},{"location":"api/download.service/#download.service.get_session_id","title":"get_session_id","text":"Python<pre><code>get_session_id()\n</code></pre> <p>Get the current application session ID.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>UUID string identifying this application session.</p> Source code in <code>download/service.py</code> Python<pre><code>def get_session_id() -&gt; str:\n    \"\"\"Get the current application session ID.\n\n    Returns:\n        str: UUID string identifying this application session.\n    \"\"\"\n    return _SESSION_ID\n</code></pre>"},{"location":"api/download.service/#download.service.check_and_prepare_firmware","title":"check_and_prepare_firmware","text":"Python<pre><code>check_and_prepare_firmware(\n    model,\n    csc,\n    device_id,\n    current_firmware,\n    *,\n    serial_number=None,\n    lock_status=None,\n    aid=None,\n    cc=None\n)\n</code></pre> <p>Check latest firmware via FOTA and determine if cached in repository.</p> <p>Always queries Samsung FOTA for latest version. Logs to imei_log with status_fus=\"unknown\" (no FUS query yet). Then checks firmware table to see if that version is already downloaded.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier (e.g., SM-G998B).</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or serial number.</p> required <code>current_firmware</code> <code>str</code> <p>Current device firmware version (for logging/comparison).</p> required <p>Returns:</p> Type Description <code>(latest_version, is_cached)</code> <p>Latest version from FOTA and whether it exists in local repository.</p> <p>Raises:</p> Type Description <code>FOTAError</code> <p>If FOTA query fails.</p> Example <p>latest, cached = check_and_prepare_firmware(     \"SM-A146P\", \"EUX\", \"352976245060954\", \"A146PXXS6CXK3/...\" ) if cached:     print(f\"Version {latest} already downloaded\")</p> Source code in <code>download/service.py</code> Python<pre><code>def check_and_prepare_firmware(\n    model: str,\n    csc: str,\n    device_id: str,\n    current_firmware: str,\n    *,\n    serial_number: Optional[str] = None,\n    lock_status: Optional[str] = None,\n    aid: Optional[str] = None,\n    cc: Optional[str] = None,\n) -&gt; tuple[str, bool]:\n    \"\"\"Check latest firmware via FOTA and determine if cached in repository.\n\n    Always queries Samsung FOTA for latest version. Logs to imei_log with\n    status_fus=\"unknown\" (no FUS query yet). Then checks firmware table\n    to see if that version is already downloaded.\n\n    Args:\n        model: Device model identifier (e.g., SM-G998B).\n        csc: Country Specific Code.\n        device_id: Device IMEI or serial number.\n        current_firmware: Current device firmware version (for logging/comparison).\n\n    Returns:\n        (latest_version, is_cached): Latest version from FOTA and whether\n            it exists in local repository.\n\n    Raises:\n        FOTAError: If FOTA query fails.\n\n    Example:\n        latest, cached = check_and_prepare_firmware(\n            \"SM-A146P\", \"EUX\", \"352976245060954\", \"A146PXXS6CXK3/...\"\n        )\n        if cached:\n            print(f\"Version {latest} already downloaded\")\n    \"\"\"\n    # 1. Log device detection with current firmware (status_fus=\"unknown\")\n    upsert_imei_event(\n        session_id=_SESSION_ID,\n        imei=device_id,\n        model=model,\n        csc=csc,\n        version_code=current_firmware,\n        serial_number=serial_number,\n        lock_status=lock_status,\n        aid=aid,\n        cc=cc,\n        status_fus=\"unknown\",  # FUS download not attempted yet\n        status_upgrade=\"unknown\",  # Firmware flashing not implemented\n    )\n\n    # 2. Query FOTA for latest version and update record with fota_version\n    version = get_latest_version(model, csc)\n    version_norm = normalize_vercode(version)\n\n    upsert_imei_event(\n        session_id=_SESSION_ID,\n        imei=device_id,\n        model=model,\n        csc=csc,\n        version_code=current_firmware,\n        fota_version=version_norm,\n        serial_number=serial_number,\n        lock_status=lock_status,\n        aid=aid,\n        cc=cc,\n        status_fus=\"unknown\",  # FUS download not attempted yet\n        status_upgrade=\"unknown\",  # Firmware flashing not implemented\n    )\n\n    # 3. Check if this specific version exists in repository\n    cached = find_firmware(version_norm)\n    is_cached = cached is not None and Path(cached.encrypted_file_path).exists()\n\n    return version_norm, is_cached\n</code></pre>"},{"location":"api/download.service/#download.service.get_or_download_firmware","title":"get_or_download_firmware","text":"Python<pre><code>get_or_download_firmware(\n    version_code,\n    model,\n    csc,\n    device_id,\n    *,\n    resume=True,\n    progress_cb=None,\n    stop_check=None\n)\n</code></pre> <p>Get firmware from repository or download if not present.</p> <p>Checks if the firmware already exists in the repository. If not, downloads it from Samsung FUS servers and stores metadata in the database.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier (4-part format).</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or serial number.</p> required <code>resume</code> <code>bool</code> <p>If True, resume from partial download if .part file exists.</p> <code>True</code> <code>progress_cb</code> <code>Optional[Callable[[int, int], None]]</code> <p>Optional callback function(bytes_downloaded, total_bytes).</p> <code>None</code> <code>stop_check</code> <code>Optional[Callable[[], bool]]</code> <p>Optional callable that returns True if task should stop.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FirmwareRecord</code> <code>FirmwareRecord</code> <p>Repository record with encrypted file path and metadata.</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If FUS inform request fails.</p> <code>DownloadError</code> <p>If download fails or size verification fails.</p> <code>RuntimeError</code> <p>If task was stopped via stop_check.</p> Example <p>firmware = get_or_download_firmware(     \"A146PXXS6CXK3/A146POXM6CXK3/...\",     \"SM-A146P\",     \"EUX\",     \"352976245060954\" ) print(f\"Encrypted file: {firmware.encrypted_file_path}\")</p> Source code in <code>download/service.py</code> Python<pre><code>def get_or_download_firmware(\n    version_code: str,\n    model: str,\n    csc: str,\n    device_id: str,\n    *,\n    resume: bool = True,\n    progress_cb: Optional[Callable[[int, int], None]] = None,\n    stop_check: Optional[Callable[[], bool]] = None,\n) -&gt; FirmwareRecord:\n    \"\"\"Get firmware from repository or download if not present.\n\n    Checks if the firmware already exists in the repository. If not, downloads\n    it from Samsung FUS servers and stores metadata in the database.\n\n    Args:\n        version_code: Firmware version identifier (4-part format).\n        model: Device model identifier.\n        csc: Country Specific Code.\n        device_id: Device IMEI or serial number.\n        resume: If True, resume from partial download if .part file exists.\n        progress_cb: Optional callback function(bytes_downloaded, total_bytes).\n        stop_check: Optional callable that returns True if task should stop.\n\n    Returns:\n        FirmwareRecord: Repository record with encrypted file path and metadata.\n\n    Raises:\n        InformError: If FUS inform request fails.\n        DownloadError: If download fails or size verification fails.\n        RuntimeError: If task was stopped via stop_check.\n\n    Example:\n        firmware = get_or_download_firmware(\n            \"A146PXXS6CXK3/A146POXM6CXK3/...\",\n            \"SM-A146P\",\n            \"EUX\",\n            \"352976245060954\"\n        )\n        print(f\"Encrypted file: {firmware.encrypted_file_path}\")\n    \"\"\"\n    # Check if already in repository\n    existing = find_firmware(version_code)\n    if existing and Path(existing.encrypted_file_path).exists():\n        return existing\n\n    # Download from FUS\n    version_norm = normalize_vercode(version_code)\n    client = FUSClient()\n\n    # 1. INFORM - get firmware metadata\n    inform_payload = build_binary_inform(version_norm, model, csc, device_id, client.nonce)\n    inform_root = client.inform(inform_payload)\n    info = parse_inform(inform_root)\n\n    # 2. INIT - authorize download\n    init_payload = build_binary_init(info.filename, client.nonce)\n    client.init(init_payload)\n\n    # 3. DOWNLOAD - stream to disk\n    PATHS.firmware_dir.mkdir(parents=True, exist_ok=True)\n    enc_path = PATHS.firmware_dir / info.filename\n    part_path = enc_path.with_suffix(enc_path.suffix + \".part\")\n\n    start = part_path.stat().st_size if (resume and part_path.exists()) else 0\n    remote = info.path + info.filename\n    resp = client.stream(remote, start=start)\n\n    mode = \"ab\" if start &gt; 0 else \"wb\"\n    written = start\n    with open(part_path, mode) as f:\n        for chunk in resp.iter_content(chunk_size=1024 * 1024):\n            # Check if task should stop\n            if stop_check and stop_check():\n                raise RuntimeError(\"Download task stopped by user\")\n            if not chunk:\n                continue\n            f.write(chunk)\n            written += len(chunk)\n            if progress_cb:\n                progress_cb(written, info.size_bytes)\n\n    if written != info.size_bytes:\n        raise DownloadError(f\"Size mismatch: got {written}, expected {info.size_bytes}\")\n\n    # Atomic finalize\n    part_path.replace(enc_path)\n\n    # 4. PERSIST to repository\n    rec = FirmwareRecord(\n        version_code=version_norm,\n        filename=info.filename,\n        path=info.path,\n        size_bytes=info.size_bytes,\n        logic_value_factory=info.logic_value_factory,\n        latest_fw_version=info.latest_fw_version,\n        encrypted_file_path=str(enc_path.resolve()),\n        decrypted_file_path=None,\n    )\n    upsert_firmware(rec)\n\n    return rec\n</code></pre>"},{"location":"api/download.service/#download.service.decrypt_firmware","title":"decrypt_firmware","text":"Python<pre><code>decrypt_firmware(\n    version_code,\n    output_path=None,\n    *,\n    progress_cb=None,\n    stop_check=None\n)\n</code></pre> <p>Decrypt firmware from repository.</p> <p>Decrypts a firmware file that exists in the repository. The decrypted file is saved to the configured decrypted directory or a custom path.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier to decrypt.</p> required <code>output_path</code> <code>Optional[str]</code> <p>Optional custom output path. If None, uses PATHS.decrypted_dir/. <code>None</code> <code>progress_cb</code> <code>Optional[Callable[[int, int], None]]</code> <p>Optional callback function(bytes_processed, total_bytes).</p> <code>None</code> <code>stop_check</code> <code>Optional[Callable[[], bool]]</code> <p>Optional callable that returns True if task should stop.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Absolute path to the decrypted file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If firmware not found in repository.</p> <code>FileNotFoundError</code> <p>If encrypted file doesn't exist on disk.</p> <code>DecryptError</code> <p>If decryption fails.</p> <code>RuntimeError</code> <p>If task was stopped via stop_check.</p> Example <p>decrypted = decrypt_firmware(\"A146PXXS6CXK3/...\") print(f\"Decrypted to: {decrypted}\")</p> Source code in <code>download/service.py</code> Python<pre><code>def decrypt_firmware(\n    version_code: str,\n    output_path: Optional[str] = None,\n    *,\n    progress_cb: Optional[Callable[[int, int], None]] = None,\n    stop_check: Optional[Callable[[], bool]] = None,\n) -&gt; str:\n    \"\"\"Decrypt firmware from repository.\n\n    Decrypts a firmware file that exists in the repository. The decrypted\n    file is saved to the configured decrypted directory or a custom path.\n\n    Args:\n        version_code: Firmware version identifier to decrypt.\n        output_path: Optional custom output path. If None, uses\n            PATHS.decrypted_dir/&lt;filename_without_enc4&gt;.\n        progress_cb: Optional callback function(bytes_processed, total_bytes).\n        stop_check: Optional callable that returns True if task should stop.\n\n    Returns:\n        Absolute path to the decrypted file.\n\n    Raises:\n        ValueError: If firmware not found in repository.\n        FileNotFoundError: If encrypted file doesn't exist on disk.\n        DecryptError: If decryption fails.\n        RuntimeError: If task was stopped via stop_check.\n\n    Example:\n        decrypted = decrypt_firmware(\"A146PXXS6CXK3/...\")\n        print(f\"Decrypted to: {decrypted}\")\n    \"\"\"\n    # Get firmware from repository\n    firmware = find_firmware(version_code)\n    if not firmware:\n        raise ValueError(f\"Firmware {version_code} not found in repository\")\n\n    enc_path = Path(firmware.encrypted_file_path)\n    if not enc_path.exists():\n        raise FileNotFoundError(f\"Encrypted file not found: {enc_path}\")\n\n    # Check if task should stop before starting\n    if stop_check and stop_check():\n        raise RuntimeError(\"Decryption task stopped by user\")\n\n    # Determine output path\n    if output_path:\n        dec_path = Path(output_path)\n    else:\n        PATHS.decrypted_dir.mkdir(parents=True, exist_ok=True)\n        dec_path = PATHS.decrypted_dir / enc_path.stem\n\n    # Decrypt using logic value from repository\n    key = get_v4_key_from_logic(firmware.latest_fw_version, firmware.logic_value_factory)\n    decrypt_file(\n        str(enc_path),\n        str(dec_path),\n        key=key,\n        progress_cb=progress_cb,\n        stop_check=stop_check,\n    )\n\n    # Update repository with decrypted path\n    update_decrypted_path(version_code, str(dec_path.resolve()))\n\n    return str(dec_path.resolve())\n</code></pre>"},{"location":"api/download.service/#download.service.download_and_decrypt","title":"download_and_decrypt","text":"Python<pre><code>download_and_decrypt(\n    model,\n    csc,\n    device_id,\n    current_firmware,\n    version=None,\n    *,\n    output_path=None,\n    resume=True,\n    progress_cb=None,\n    stop_check=None\n)\n</code></pre> <p>Complete workflow: check FOTA, download, and decrypt firmware.</p> <p>Performs the full workflow: 1. Query FOTA for latest version and check repository cache 2. Download encrypted firmware if not cached (with resume support) 3. Decrypt firmware to output directory 4. Update imei_log with FUS download status</p> <p>A single optional <code>progress_cb</code> is invoked for both stages with:     progress_cb(stage, done_bytes, total_bytes) where <code>stage</code> is one of <code>\"download\"</code> or <code>\"decrypt\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code (region).</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or serial/blank for download mode.</p> required <code>current_firmware</code> <code>str</code> <p>Current device firmware version.</p> required <code>version</code> <code>Optional[str]</code> <p>Specific version to fetch; if None latest from FOTA is used.</p> <code>None</code> <code>output_path</code> <code>Optional[str]</code> <p>Optional explicit decrypted output path.</p> <code>None</code> <code>resume</code> <code>bool</code> <p>Resume partial downloads when True.</p> <code>True</code> <code>progress_cb</code> <code>Optional[Callable[[str, int, int], None]]</code> <p>Unified callback for both stages.</p> <code>None</code> <code>stop_check</code> <code>Optional[Callable[[], bool]]</code> <p>Optional callable that returns True if task should stop.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[FirmwareRecord, str]</code> <p>(FirmwareRecord, decrypted_file_path)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If task was stopped via stop_check.</p> Source code in <code>download/service.py</code> Python<pre><code>def download_and_decrypt(\n    model: str,\n    csc: str,\n    device_id: str,\n    current_firmware: str,\n    version: Optional[str] = None,\n    *,\n    output_path: Optional[str] = None,\n    resume: bool = True,\n    progress_cb: Optional[Callable[[str, int, int], None]] = None,\n    stop_check: Optional[Callable[[], bool]] = None,\n) -&gt; tuple[FirmwareRecord, str]:\n    \"\"\"Complete workflow: check FOTA, download, and decrypt firmware.\n\n    Performs the full workflow:\n    1. Query FOTA for latest version and check repository cache\n    2. Download encrypted firmware if not cached (with resume support)\n    3. Decrypt firmware to output directory\n    4. Update imei_log with FUS download status\n\n    A single optional ``progress_cb`` is invoked for both stages with:\n        progress_cb(stage, done_bytes, total_bytes)\n    where ``stage`` is one of ``\"download\"`` or ``\"decrypt\"``.\n\n    Args:\n        model: Device model identifier.\n        csc: Country Specific Code (region).\n        device_id: Device IMEI or serial/blank for download mode.\n        current_firmware: Current device firmware version.\n        version: Specific version to fetch; if None latest from FOTA is used.\n        output_path: Optional explicit decrypted output path.\n        resume: Resume partial downloads when True.\n        progress_cb: Unified callback for both stages.\n        stop_check: Optional callable that returns True if task should stop.\n\n    Returns:\n        (FirmwareRecord, decrypted_file_path)\n\n    Raises:\n        RuntimeError: If task was stopped via stop_check.\n    \"\"\"\n    # 1. Resolve version and check cache\n    if not version:\n        version, _is_cached = check_and_prepare_firmware(model, csc, device_id, current_firmware)\n    else:\n        version = normalize_vercode(version)\n\n    # Check if task should stop before starting\n    if stop_check and stop_check():\n        raise RuntimeError(\"Download task stopped by user\")\n\n    # 2. Download to repository\n    def _dl_cb(done: int, total: int):\n        if progress_cb:\n            progress_cb(\"download\", done, total)\n\n    try:\n        firmware = get_or_download_firmware(\n            version,\n            model,\n            csc,\n            device_id,\n            resume=resume,\n            progress_cb=_dl_cb if progress_cb else None,\n            stop_check=stop_check,\n        )\n    except FUSError:\n        # Update imei_log with error status before re-raising\n        # Catches InformError and all its subtypes (BadStatus, MissingStatus, etc.)\n        upsert_imei_event(\n            session_id=_SESSION_ID,\n            imei=device_id,\n            model=model,\n            csc=csc,\n            version_code=current_firmware,\n            fota_version=version,\n            status_fus=\"error\",\n            status_upgrade=\"unknown\",\n        )\n        raise\n\n    # Update log with successful firmware retrieval (whether downloaded or cached)\n    # This updates the existing session record created by check_and_prepare_firmware\n    upsert_imei_event(\n        session_id=_SESSION_ID,\n        imei=device_id,\n        model=model,\n        csc=csc,\n        version_code=current_firmware,\n        fota_version=version,\n        status_fus=\"ok\",  # Firmware obtained successfully\n        status_upgrade=\"unknown\",  # Firmware flashing not implemented\n    )\n\n    # 3. Decrypt\n    def _dec_cb(done: int, total: int):\n        if progress_cb:\n            progress_cb(\"decrypt\", done, total)\n\n    decrypted_path = decrypt_firmware(\n        version,\n        output_path,\n        progress_cb=_dec_cb if progress_cb else None,\n        stop_check=stop_check,\n    )\n\n    return firmware, decrypted_path\n</code></pre>"},{"location":"api/download.service/#download.service.cleanup_repository","title":"cleanup_repository","text":"Python<pre><code>cleanup_repository(progress_cb=None)\n</code></pre> <p>Clean repository inconsistencies.</p> <p>Verifies each firmware record's encrypted file exists. If missing:     * Deletes decrypted file if present.     * Deletes database record.</p> <p>Parameters:</p> Name Type Description Default <code>progress_cb</code> <code>Optional[Callable[[int, int, int, int, int], None]]</code> <p>Optional callback invoked as progress_cb(processed, total, missing_encrypted, records_deleted, decrypted_deleted)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Summary statistics dict with keys: total_records, missing_encrypted, decrypted_deleted, records_deleted</p> Source code in <code>download/service.py</code> Python<pre><code>def cleanup_repository(\n    progress_cb: Optional[Callable[[int, int, int, int, int], None]] = None,\n) -&gt; Dict[str, int]:\n    \"\"\"Clean repository inconsistencies.\n\n    Verifies each firmware record's encrypted file exists. If missing:\n        * Deletes decrypted file if present.\n        * Deletes database record.\n\n    Args:\n        progress_cb: Optional callback invoked as\n            progress_cb(processed, total, missing_encrypted, records_deleted, decrypted_deleted)\n\n    Returns:\n        Summary statistics dict with keys:\n            total_records, missing_encrypted, decrypted_deleted, records_deleted\n    \"\"\"\n    stats = {\n        \"total_records\": 0,\n        \"missing_encrypted\": 0,\n        \"decrypted_deleted\": 0,\n        \"records_deleted\": 0,\n    }\n\n    records = list(list_firmware())\n    total = len(records)\n    for idx, rec in enumerate(records, start=1):\n        stats[\"total_records\"] += 1\n        enc_path = Path(rec.encrypted_file_path)\n        if not enc_path.is_file():\n            stats[\"missing_encrypted\"] += 1\n            # remove decrypted file if exists\n            if rec.decrypted_file_path:\n                dec_path = Path(rec.decrypted_file_path)\n                try:\n                    if dec_path.exists():\n                        dec_path.unlink()\n                        stats[\"decrypted_deleted\"] += 1\n                except OSError:\n                    # Ignore errors deleting decrypted file (e.g., file missing, permission denied)\n                    pass\n            delete_firmware(rec.version_code)\n            stats[\"records_deleted\"] += 1\n\n        if progress_cb:\n            progress_cb(\n                idx,\n                total,\n                stats[\"missing_encrypted\"],\n                stats[\"records_deleted\"],\n                stats[\"decrypted_deleted\"],\n            )\n\n    return stats\n</code></pre>"},{"location":"api/fus.client/","title":"Package API <code>fus.client</code>","text":""},{"location":"api/fus.client/#fus.client","title":"fus.client","text":"<p>Samsung Firmware Update Service (FUS) client implementation.</p> <p>Provides the core FUSClient class for communicating with Samsung's firmware servers using the FUS protocol including inform, init, and download operations.</p>"},{"location":"api/fus.client/#fus.client.FUSClient","title":"FUSClient","text":"<p>Samsung Firmware Update Service (FUS) client implementation.</p> <p>Handles core FUS protocol operations including NONCE rotation, signature generation, and session management.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>FUSConfig</code> <p>FUS configuration settings. Defaults to DEFAULT_CONFIG.</p> <code>DEFAULT_CONFIG</code> <code>session</code> <code>Optional[Session]</code> <p>Optional requests.Session for connection reuse.</p> <code>None</code> Source code in <code>fus/client.py</code> Python<pre><code>class FUSClient:\n    \"\"\"\n    Samsung Firmware Update Service (FUS) client implementation.\n\n    Handles core FUS protocol operations including NONCE rotation,\n    signature generation, and session management.\n\n    Args:\n        cfg: FUS configuration settings. Defaults to DEFAULT_CONFIG.\n        session: Optional requests.Session for connection reuse.\n    \"\"\"\n\n    def __init__(self, cfg: FUSConfig = DEFAULT_CONFIG, session: Optional[requests.Session] = None):\n        self.cfg = cfg\n        self.sess = session or requests.Session()\n        self._auth = \"\"\n        self._sessid = \"\"\n        self._enc_nonce = \"\"\n        self.nonce = \"\"\n        # bootstrap: r\u00e9cup\u00e9rer un NONCE\n        self._makereq(\"NF_DownloadGenerateNonce.do\")\n\n    def _headers(self, with_server_nonce: bool = False) -&gt; dict:\n        \"\"\"\n        Build request headers including Authorization and User-Agent.\n\n        Args:\n            with_server_nonce: Whether to include encrypted NONCE in Authorization.\n\n        Returns:\n            dict: Headers dictionary for FUS requests.\n        \"\"\"\n        nonce = self._enc_nonce if with_server_nonce else \"\"\n        authv = (\n            f'FUS nonce=\"{nonce}\", signature=\"{self._auth}\", nc=\"\", type=\"\", realm=\"\", newauth=\"1\"'\n        )\n        return {\"Authorization\": authv, \"User-Agent\": self.cfg.user_agent}\n\n    def _makereq(self, path: str, data: bytes | str = b\"\") -&gt; str:\n        \"\"\"\n        Make an authenticated request to FUS server with NONCE rotation.\n\n        Args:\n            path: API endpoint path.\n            data: Request payload (XML or bytes).\n\n        Returns:\n            str: Response text from server.\n\n        Raises:\n            requests.exceptions.HTTPError: On non-200 response.\n        \"\"\"\n        url = f\"{self.cfg.base_url}/{path}\"\n        r = self.sess.post(\n            url,\n            data=data,\n            headers=self._headers(),\n            timeout=self.cfg.request_timeout,\n            cookies={\"JSESSIONID\": self._sessid},\n        )\n        # rotation de nonce + signature\n        if \"NONCE\" in r.headers:\n            self._enc_nonce = r.headers[\"NONCE\"]\n            self.nonce = decrypt_nonce(self._enc_nonce)\n            self._auth = make_signature(self.nonce)\n        if \"JSESSIONID\" in r.cookies:\n            self._sessid = r.cookies[\"JSESSIONID\"]\n        r.raise_for_status()\n        return r.text\n\n    def inform(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Send inform request to get firmware information.\n\n        Args:\n            payload: XML payload containing device and firmware details.\n\n        Returns:\n            ET.Element: Parsed XML response containing firmware metadata.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n        return ET.fromstring(xml)\n\n    def init(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Initialize binary download session.\n\n        Args:\n            payload: XML payload with download request details.\n\n        Returns:\n            ET.Element: Parsed XML response with download authorization.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n        return ET.fromstring(xml)\n\n    def stream(self, filename: str, start: int = 0) -&gt; requests.Response:\n        \"\"\"\n        Stream firmware download from cloud server.\n\n        Args:\n            filename: Remote firmware file path.\n            start: Byte offset for resume capability.\n\n        Returns:\n            requests.Response: Streaming response object.\n\n        Raises:\n            DownloadError: On download initialization failure.\n        \"\"\"\n        # cloud download (transmits client-side encrypted NONCE)\n        url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n        headers = self._headers(with_server_nonce=True)\n        if start &gt; 0:\n            headers[\"Range\"] = f\"bytes={start}-\"\n        r = self.sess.get(\n            url,\n            params=\"file=\" + filename,\n            headers=headers,\n            stream=True,\n            timeout=self.cfg.request_timeout,\n        )\n        if not r.ok:\n            raise DownloadError.HTTPError(r.status_code, filename)\n        return r\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.inform","title":"inform","text":"Python<pre><code>inform(payload)\n</code></pre> <p>Send inform request to get firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload containing device and firmware details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response containing firmware metadata.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus/client.py</code> Python<pre><code>def inform(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Send inform request to get firmware information.\n\n    Args:\n        payload: XML payload containing device and firmware details.\n\n    Returns:\n        ET.Element: Parsed XML response containing firmware metadata.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.init","title":"init","text":"Python<pre><code>init(payload)\n</code></pre> <p>Initialize binary download session.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload with download request details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response with download authorization.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus/client.py</code> Python<pre><code>def init(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Initialize binary download session.\n\n    Args:\n        payload: XML payload with download request details.\n\n    Returns:\n        ET.Element: Parsed XML response with download authorization.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.stream","title":"stream","text":"Python<pre><code>stream(filename, start=0)\n</code></pre> <p>Stream firmware download from cloud server.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Remote firmware file path.</p> required <code>start</code> <code>int</code> <p>Byte offset for resume capability.</p> <code>0</code> <p>Returns:</p> Type Description <code>Response</code> <p>requests.Response: Streaming response object.</p> <p>Raises:</p> Type Description <code>DownloadError</code> <p>On download initialization failure.</p> Source code in <code>fus/client.py</code> Python<pre><code>def stream(self, filename: str, start: int = 0) -&gt; requests.Response:\n    \"\"\"\n    Stream firmware download from cloud server.\n\n    Args:\n        filename: Remote firmware file path.\n        start: Byte offset for resume capability.\n\n    Returns:\n        requests.Response: Streaming response object.\n\n    Raises:\n        DownloadError: On download initialization failure.\n    \"\"\"\n    # cloud download (transmits client-side encrypted NONCE)\n    url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n    headers = self._headers(with_server_nonce=True)\n    if start &gt; 0:\n        headers[\"Range\"] = f\"bytes={start}-\"\n    r = self.sess.get(\n        url,\n        params=\"file=\" + filename,\n        headers=headers,\n        stream=True,\n        timeout=self.cfg.request_timeout,\n    )\n    if not r.ok:\n        raise DownloadError.HTTPError(r.status_code, filename)\n    return r\n</code></pre>"},{"location":"api/fus.config/","title":"Package API <code>fus.config</code>","text":""},{"location":"api/fus.config/#fus.config","title":"fus.config","text":"<p>FUS configuration helpers.</p> <p>This module defines the FUSConfig dataclass which centralizes default endpoints and HTTP settings used by the FUS client.</p>"},{"location":"api/fus.config/#fus.config.FUSConfig","title":"FUSConfig  <code>dataclass</code>","text":"<p>Configuration for the Firmware Update Service (FUS) client.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for FUS control endpoints. Some clients/tools may use a different host.</p> <code>'https://neofussvr.sslcs.cdngc.net'</code> <code>cloud_url</code> <code>str</code> <p>Primary cloud URL used for firmware downloads.</p> <code>'http://cloud-neofussvr.samsungmobile.com'</code> <code>old_cloud_url</code> <code>str</code> <p>Legacy cloud URL kept for compatibility.</p> <code>'http://cloud-fussvr.sslcs.cdngc.net'</code> <code>user_agent</code> <code>str</code> <p>User-Agent header used for HTTP requests.</p> <code>'Kies2.0_FUS'</code> <code>request_timeout</code> <code>int</code> <p>Default timeout in seconds for HTTP requests.</p> <code>60</code> Source code in <code>fus/config.py</code> Python<pre><code>@dataclass(frozen=True)\nclass FUSConfig:\n    \"\"\"\n    Configuration for the Firmware Update Service (FUS) client.\n\n    Args:\n        base_url: Base URL for FUS control endpoints. Some clients/tools may use a different host.\n        cloud_url: Primary cloud URL used for firmware downloads.\n        old_cloud_url: Legacy cloud URL kept for compatibility.\n        user_agent: User-Agent header used for HTTP requests.\n        request_timeout: Default timeout in seconds for HTTP requests.\n    \"\"\"\n\n    # Endpoints (some clients/tools may use a different cloud host)\n    base_url: str = \"https://neofussvr.sslcs.cdngc.net\"\n    cloud_url: str = \"http://cloud-neofussvr.samsungmobile.com\"\n    old_cloud_url: str = \"http://cloud-fussvr.sslcs.cdngc.net\"\n    # Default User-Agent and timeout for HTTP requests\n    user_agent: str = \"Kies2.0_FUS\"\n    request_timeout: int = 60  # seconds\n</code></pre>"},{"location":"api/fus.crypto/","title":"Package API <code>fus.crypto</code>","text":""},{"location":"api/fus.crypto/#fus.crypto","title":"fus.crypto","text":"<p>FUS crypto helpers: AES CBC utilities, padding, key derivation and logic checks.</p> <p>Provides small helpers used by the FUS client and decryption routines.</p>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_pad","title":"pkcs_pad","text":"Python<pre><code>pkcs_pad(data)\n</code></pre> <p>Apply PKCS#7 padding to reach a 16-byte boundary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw bytes to pad.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Padded bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def pkcs_pad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Apply PKCS#7 padding to reach a 16-byte boundary.\n\n    Args:\n        data: Raw bytes to pad.\n\n    Returns:\n        Padded bytes.\n    \"\"\"\n    pad_len = 16 - (len(data) % 16)\n    return data + bytes([pad_len]) * pad_len\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_unpad","title":"pkcs_unpad","text":"Python<pre><code>pkcs_unpad(data)\n</code></pre> <p>Remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Padded bytes.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Original unpadded bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def pkcs_unpad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Remove PKCS#7 padding.\n\n    Args:\n        data: Padded bytes.\n\n    Returns:\n        Original unpadded bytes.\n    \"\"\"\n    return data[: -data[-1]]\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_encrypt","title":"aes_cbc_encrypt","text":"Python<pre><code>aes_cbc_encrypt(inp, key)\n</code></pre> <p>Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Plaintext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key (16/24/32 bytes).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Ciphertext bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def aes_cbc_encrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.\n\n    Args:\n        inp: Plaintext bytes.\n        key: AES key (16/24/32 bytes).\n\n    Returns:\n        Ciphertext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return cipher.encrypt(pkcs_pad(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_decrypt","title":"aes_cbc_decrypt","text":"Python<pre><code>aes_cbc_decrypt(inp, key)\n</code></pre> <p>Decrypt AES-CBC ciphertext and remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Ciphertext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key used to encrypt.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Plaintext bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def aes_cbc_decrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt AES-CBC ciphertext and remove PKCS#7 padding.\n\n    Args:\n        inp: Ciphertext bytes.\n        key: AES key used to encrypt.\n\n    Returns:\n        Plaintext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return pkcs_unpad(cipher.decrypt(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.derive_key","title":"derive_key","text":"Python<pre><code>derive_key(nonce)\n</code></pre> <p>Build a key from a 16-character server nonce.</p> <p>The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars, concatenated with KEY_2, returned as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>16-character nonce string.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Derived key bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def derive_key(nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a key from a 16-character server nonce.\n\n    The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars,\n    concatenated with KEY_2, returned as bytes.\n\n    Args:\n        nonce: 16-character nonce string.\n\n    Returns:\n        Derived key bytes.\n    \"\"\"\n    k = \"\".join(KEY_1[ord(nonce[i]) % 16] for i in range(16))\n    k += KEY_2\n    return k.encode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.make_signature","title":"make_signature","text":"Python<pre><code>make_signature(nonce)\n</code></pre> <p>Compute the base64-encoded signature for a nonce.</p> <p>The signature is base64(AES-CBC(nonce, derive_key(nonce))).</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>Plaintext nonce.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base64-encoded signature string.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def make_signature(nonce: str) -&gt; str:\n    \"\"\"\n    Compute the base64-encoded signature for a nonce.\n\n    The signature is base64(AES-CBC(nonce, derive_key(nonce))).\n\n    Args:\n        nonce: Plaintext nonce.\n\n    Returns:\n        Base64-encoded signature string.\n    \"\"\"\n    raw = aes_cbc_encrypt(nonce.encode(), derive_key(nonce))\n    return base64.b64encode(raw).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.decrypt_nonce","title":"decrypt_nonce","text":"Python<pre><code>decrypt_nonce(enc_nonce)\n</code></pre> <p>Decrypt a server NONCE header.</p> <p>Parameters:</p> Name Type Description Default <code>enc_nonce</code> <code>str</code> <p>Base64-encoded ciphertext from server.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Decrypted plaintext nonce.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates base64 and AES decode errors if input is malformed.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def decrypt_nonce(enc_nonce: str) -&gt; str:\n    \"\"\"\n    Decrypt a server NONCE header.\n\n    Args:\n        enc_nonce: Base64-encoded ciphertext from server.\n\n    Returns:\n        Decrypted plaintext nonce.\n\n    Raises:\n        Exception: Propagates base64 and AES decode errors if input is malformed.\n    \"\"\"\n    data = base64.b64decode(enc_nonce)\n    return aes_cbc_decrypt(data, KEY_1.encode()).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.logic_check","title":"logic_check","text":"Python<pre><code>logic_check(inp, nonce)\n</code></pre> <p>Compute the FUS logic-check value.</p> <p>Picks characters from <code>inp</code> using the low 4 bits of each character in <code>nonce</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Input string (must be at least 16 characters).</p> required <code>nonce</code> <code>str</code> <p>Server nonce string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Computed logic-check string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>inp</code> is shorter than 16 characters.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def logic_check(inp: str, nonce: str) -&gt; str:\n    \"\"\"\n    Compute the FUS logic-check value.\n\n    Picks characters from `inp` using the low 4 bits of each character in `nonce`.\n\n    Args:\n        inp: Input string (must be at least 16 characters).\n        nonce: Server nonce string.\n\n    Returns:\n        Computed logic-check string.\n\n    Raises:\n        ValueError: If `inp` is shorter than 16 characters.\n    \"\"\"\n    if len(inp) &lt; 16:\n        raise ValueError(\"logic_check input too short\")\n    return \"\".join(inp[ord(c) &amp; 0xF] for c in nonce)\n</code></pre>"},{"location":"api/fus.csclist/","title":"Package API <code>fus.csclist</code>","text":""},{"location":"api/fus.csclist/#fus.csclist","title":"fus.csclist","text":"<p>CSC mapping for Samsung firmware regions.</p> <p>This module provides CSC_DICT, a dictionary that maps 3-letter Samsung CSC codes to their corresponding country or region names. It is used by the CLI and GUI components to display or validate CSC/region information.</p> <p>Attributes:</p> Name Type Description <code>CSC_DICT</code> <code>dict</code> <p>Mapping of 3-letter CSC codes to region/country names.</p>"},{"location":"api/fus.decrypt/","title":"Package API <code>fus.decrypt</code>","text":""},{"location":"api/fus.decrypt/#fus.decrypt","title":"fus.decrypt","text":"<p>FUS decryption helpers.</p> <p>Provides functions to derive ENC2/ENC4 keys and to decrypt streaming firmware blobs.</p> <p>Functions: - get_v2_key: derive MD5-based ENC2 key. - get_v4_key_from_logic: derive ENC4 key from firmware version and logic value. - get_v4_key: retrieve logic value via FUS inform and derive ENC4 key. - decrypt_file: decrypt a file encrypting in 16-byte AES blocks.</p>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v2_key","title":"get_v2_key","text":"Python<pre><code>get_v2_key(version, model, region, _device_id)\n</code></pre> <p>Derive ENC2 key (V2) using MD5.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>_device_id</code> <code>str</code> <p>Unused for V2 (kept for API parity).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>MD5 digest bytes of the string \"region:model:version\".</p> Source code in <code>fus/decrypt.py</code> Python<pre><code>def get_v2_key(version: str, model: str, region: str, _device_id: str) -&gt; bytes:\n    \"\"\"\n    Derive ENC2 key (V2) using MD5.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        _device_id: Unused for V2 (kept for API parity).\n\n    Returns:\n        MD5 digest bytes of the string \"region:model:version\".\n    \"\"\"\n    deckey = f\"{region}:{model}:{version}\"\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v4_key_from_logic","title":"get_v4_key_from_logic","text":"Python<pre><code>get_v4_key_from_logic(fw_version, logic_value)\n</code></pre> <p>Derive ENC4 key (V4) from firmware version and logic value.</p> <p>Use this when you already have the logic value from a previous inform call.</p> <p>Parameters:</p> Name Type Description Default <code>fw_version</code> <code>str</code> <p>Latest firmware version string from inform response.</p> required <code>logic_value</code> <code>str</code> <p>Logic value factory string from inform response.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>MD5 digest bytes derived from the logic-check value.</p> Source code in <code>fus/decrypt.py</code> Python<pre><code>def get_v4_key_from_logic(fw_version: str, logic_value: str) -&gt; bytes:\n    \"\"\"\n    Derive ENC4 key (V4) from firmware version and logic value.\n\n    Use this when you already have the logic value from a previous inform call.\n\n    Args:\n        fw_version: Latest firmware version string from inform response.\n        logic_value: Logic value factory string from inform response.\n\n    Returns:\n        MD5 digest bytes derived from the logic-check value.\n    \"\"\"\n    deckey = logic_check(fw_version, logic_value)\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v4_key","title":"get_v4_key","text":"Python<pre><code>get_v4_key(version, model, region, device_id, client=None)\n</code></pre> <p>Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>device_id</code> <code>str</code> <p>IMEI or Serial required by Samsung for ENC4.</p> required <code>client</code> <code>FUSClient | None</code> <p>Optional FUSClient instance to use (a new one is created if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>MD5 digest bytes derived from the logic-check value, or None on failure.</p> <p>Raises:</p> Type Description <code>DecryptError</code> <p>If device_id is not provided.</p> <code>InformError</code> <p>If the inform response lacks expected fields.</p> Source code in <code>fus/decrypt.py</code> Python<pre><code>def get_v4_key(\n    version: str, model: str, region: str, device_id: str, client: FUSClient | None = None\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        device_id: IMEI or Serial required by Samsung for ENC4.\n        client: Optional FUSClient instance to use (a new one is created if None).\n\n    Returns:\n        MD5 digest bytes derived from the logic-check value, or None on failure.\n\n    Raises:\n        DecryptError: If device_id is not provided.\n        InformError: If the inform response lacks expected fields.\n    \"\"\"\n    if not device_id:\n        raise DecryptError.DeviceIdRequired()\n    client = client or FUSClient()\n    ver = normalize_vercode(version)\n    resp = client.inform(build_binary_inform(ver, model, region, device_id, client.nonce))\n    try:\n        fwver = resp.find(\"./FUSBody/Results/LATEST_FW_VERSION/Data\").text  # type: ignore\n        logicval = resp.find(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\").text  # type: ignore\n    except Exception as exc:\n        raise InformError.DecryptionKeyError(model, region, device_id) from exc\n    return get_v4_key_from_logic(fwver, logicval)  # type: ignore\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.decrypt_file","title":"decrypt_file","text":"Python<pre><code>decrypt_file(\n    enc_path,\n    out_path,\n    *,\n    key,\n    progress_cb=None,\n    stop_check=None\n)\n</code></pre> <p>Decrypt an encrypted firmware file to disk.</p> <p>Parameters:</p> Name Type Description Default <code>enc_path</code> <code>str</code> <p>Path to the encrypted input file.</p> required <code>out_path</code> <code>str</code> <p>Path to write the decrypted output file.</p> required <code>key</code> <code>bytes</code> <p>AES key used for decryption.</p> required <code>progress_cb</code> <code>Optional[Callable[[int, int], None]]</code> <p>Optional progress callback(progress_bytes, total_bytes).</p> <code>None</code> <code>stop_check</code> <code>Optional[Callable[[], bool]]</code> <p>Optional callable that returns True if task should stop.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If task was stopped via stop_check.</p> Source code in <code>fus/decrypt.py</code> Python<pre><code>def decrypt_file(\n    enc_path: str,\n    out_path: str,\n    *,\n    key: bytes,\n    progress_cb: Optional[Callable[[int, int], None]] = None,\n    stop_check: Optional[Callable[[], bool]] = None,\n) -&gt; None:\n    \"\"\"\n    Decrypt an encrypted firmware file to disk.\n\n    Args:\n        enc_path: Path to the encrypted input file.\n        out_path: Path to write the decrypted output file.\n        key: AES key used for decryption.\n        progress_cb: Optional progress callback(progress_bytes, total_bytes).\n        stop_check: Optional callable that returns True if task should stop.\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If task was stopped via stop_check.\n    \"\"\"\n    size = os.stat(enc_path).st_size\n    with open(enc_path, \"rb\") as fin, open(out_path, \"wb\") as fout:\n        _decrypt_progress(fin, fout, key, size, progress_cb=progress_cb, stop_check=stop_check)\n</code></pre>"},{"location":"api/fus.deviceid/","title":"Package API <code>fus.deviceid</code>","text":""},{"location":"api/fus.deviceid/#fus.deviceid","title":"fus.deviceid","text":"<p>Device identifier helpers for FUS interactions.</p> <p>Provides IMEI Luhn checksum computation, TAC-based IMEI autofill, and validation helpers for serial numbers and IMEIs.</p> <p>Functions: - luhn_checksum: compute Luhn check digit for a 14-digit IMEI core. - autofill_imei: complete a TAC to a full 15-digit IMEI (random fill + Luhn). - validate_serial: basic alphanumeric serial validation. - validate_imei: full 15-digit IMEI validation using Luhn. - is_device_id_required: policy for when a device id is required by commands.</p>"},{"location":"api/fus.deviceid/#fus.deviceid.luhn_checksum","title":"luhn_checksum","text":"Python<pre><code>luhn_checksum(imei_without_cd)\n</code></pre> <p>Compute the Luhn check digit for the provided IMEI core.</p> <p>Parameters:</p> Name Type Description Default <code>imei_without_cd</code> <code>str</code> <p>IMEI digits excluding the check digit (typically 14 digits).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The single-digit Luhn checksum as an int.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def luhn_checksum(imei_without_cd: str) -&gt; int:\n    \"\"\"\n    Compute the Luhn check digit for the provided IMEI core.\n\n    Args:\n        imei_without_cd: IMEI digits excluding the check digit (typically 14 digits).\n\n    Returns:\n        The single-digit Luhn checksum as an int.\n    \"\"\"\n    s, tmp = 0, imei_without_cd + \"0\"\n    parity = len(tmp) % 2\n    for idx, ch in enumerate(tmp):\n        d = int(ch)\n        if idx % 2 == parity:\n            d *= 2\n            if d &gt; 9:\n                d -= 9\n        s += d\n    return (10 - (s % 10)) % 10\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.autofill_imei","title":"autofill_imei","text":"Python<pre><code>autofill_imei(tac)\n</code></pre> <p>Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.</p> <p>Parameters:</p> Name Type Description Default <code>tac</code> <code>str</code> <p>TAC prefix (must be numeric and at least 8 digits).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A 15-digit IMEI string.</p> <p>Raises:</p> Type Description <code>DeviceIdError</code> <p>If TAC is not numeric or shorter than 8 digits.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def autofill_imei(tac: str) -&gt; str:\n    \"\"\"\n    Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.\n\n    Args:\n        tac: TAC prefix (must be numeric and at least 8 digits).\n\n    Returns:\n        A 15-digit IMEI string.\n\n    Raises:\n        DeviceIdError: If TAC is not numeric or shorter than 8 digits.\n    \"\"\"\n    if not tac.isdecimal() or len(tac) &lt; 8:\n        raise DeviceIdError.InvalidTAC(tac)\n    if len(tac) &gt;= 15:\n        return tac[:15]\n    missing = 14 - len(tac)\n    rnd = f\"{random.randint(0, 10**missing - 1):0{missing}d}\"\n    core = tac + rnd\n    return core + str(luhn_checksum(core))\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_serial","title":"validate_serial","text":"Python<pre><code>validate_serial(serial)\n</code></pre> <p>Validate a device serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str</code> <p>Serial string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if serial is non-empty, alphanumeric and length between 1 and 35.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def validate_serial(serial: str) -&gt; bool:\n    \"\"\"\n    Validate a device serial number.\n\n    Args:\n        serial: Serial string to validate.\n\n    Returns:\n        True if serial is non-empty, alphanumeric and length between 1 and 35.\n    \"\"\"\n    return bool(serial) and (1 &lt;= len(serial) &lt;= 35) and serial.isalnum()\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_imei","title":"validate_imei","text":"Python<pre><code>validate_imei(imei)\n</code></pre> <p>Validate a full 15-digit IMEI using the Luhn checksum.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>IMEI string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def validate_imei(imei: str) -&gt; bool:\n    \"\"\"\n    Validate a full 15-digit IMEI using the Luhn checksum.\n\n    Args:\n        imei: IMEI string to validate.\n\n    Returns:\n        True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.\n    \"\"\"\n    if not imei or not imei.isdecimal():\n        return False\n    if len(imei) != 15:\n        return False\n    try:\n        check_digit = int(imei[14])\n    except ValueError:\n        return False\n    return luhn_checksum(imei[:14]) == check_digit\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.is_device_id_required","title":"is_device_id_required","text":"Python<pre><code>is_device_id_required(command, enc_ver)\n</code></pre> <p>Policy deciding whether a device id is required for an operation.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name (e.g. \"download\", \"decrypt\").</p> required <code>enc_ver</code> <code>int | None</code> <p>Encryption version (None if unknown).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the command requires a device id (download always, decrypt only for ENC4).</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def is_device_id_required(command: str, enc_ver: int | None) -&gt; bool:\n    \"\"\"\n    Policy deciding whether a device id is required for an operation.\n\n    Args:\n        command: Command name (e.g. \"download\", \"decrypt\").\n        enc_ver: Encryption version (None if unknown).\n\n    Returns:\n        True if the command requires a device id (download always, decrypt only for ENC4).\n    \"\"\"\n    return command == \"download\" or (command == \"decrypt\" and enc_ver == 4)\n</code></pre>"},{"location":"api/fus.errors/","title":"Package API <code>fus.errors</code>","text":""},{"location":"api/fus.errors/#fus.errors","title":"fus.errors","text":"<p>FUS package error definitions.</p> <p>This module defines custom exceptions used across the FUS package. In particular, DeviceIdError is raised by the device identifier utilities (e.g. IMEI/TAC validation and autofill) when provided input is invalid.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>Base class for FUS-related errors.</p> <code>AuthError</code> <p>Raised for authentication failures in FUS operations.</p> <code>InformError</code> <p>Raised for protocol or information errors in FUS communication.</p> <code>DownloadError</code> <p>Raised when a firmware download fails or is incomplete.</p> <code>DecryptError</code> <p>Raised when firmware decryption fails.</p> <code>DeviceIdError</code> <p>Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.</p> <code>FOTAError</code> <p>Base class for FOTA endpoint errors.</p> <code>FOTAParsingError</code> <p>Raised when FOTA XML response parsing fails.</p>"},{"location":"api/fus.errors/#fus.errors.FUSError","title":"FUSError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for FUS-related errors with optional predefined messages.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class FUSError(Exception):\n    \"\"\"Base class for FUS-related errors with optional predefined messages.\"\"\"\n\n    # Error subtypes with built-in messages\n    class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n        \"\"\"No firmware available for the specified model/region.\"\"\"\n\n        def __init__(self, model: str = \"\", region: str = \"\"):\n            msg = \"No latest firmware available\"\n            if model or region:\n                msg += f\" for {model}/{region}\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FUSError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.AuthError","title":"AuthError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised for authentication failures in FUS operations.</p> <p>Typical causes include invalid or expired NONCE, signature mismatch, or blocked client credentials when contacting Samsung FUS endpoints.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class AuthError(FUSError):\n    \"\"\"Raised for authentication failures in FUS operations.\n\n    Typical causes include invalid or expired NONCE, signature mismatch,\n    or blocked client credentials when contacting Samsung FUS endpoints.\n    \"\"\"\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.AuthError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError","title":"InformError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised for protocol or information errors in FUS communication.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class InformError(FUSError):\n    \"\"\"Raised for protocol or information errors in FUS communication.\"\"\"\n\n    # Error subtypes with built-in messages\n    class MissingStatus(FUSError):\n        \"\"\"Missing Status field in inform response.\"\"\"\n\n        def __init__(self):\n            super().__init__(\"Missing Status field in inform response\")\n\n    class BadStatus(FUSError):\n        \"\"\"Non-200 status code in inform response.\"\"\"\n\n        def __init__(self, status: int):\n            super().__init__(f\"DownloadBinaryInform returned {status}\")\n\n    class MissingField(FUSError):\n        \"\"\"Required field missing from inform response.\"\"\"\n\n        def __init__(self, field_name: str):\n            super().__init__(f\"Missing {field_name} in inform response\")\n\n    class DecryptionKeyError(FUSError):\n        \"\"\"Could not obtain decryption key from inform response.\"\"\"\n\n        def __init__(self, model: str = \"\", region: str = \"\", device_id: str = \"\"):\n            msg = \"Could not obtain decryption key\"\n            details = []\n            if model:\n                details.append(f\"model={model}\")\n            if region:\n                details.append(f\"region={region}\")\n            if device_id:\n                details.append(f\"device_id={device_id[:4]}***\")\n            if details:\n                msg += f\" ({', '.join(details)})\"\n            msg += \"; check model/region/device_id\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.MissingStatus","title":"MissingStatus","text":"<p>               Bases: <code>FUSError</code></p> <p>Missing Status field in inform response.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class MissingStatus(FUSError):\n    \"\"\"Missing Status field in inform response.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"Missing Status field in inform response\")\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.MissingStatus.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.BadStatus","title":"BadStatus","text":"<p>               Bases: <code>FUSError</code></p> <p>Non-200 status code in inform response.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class BadStatus(FUSError):\n    \"\"\"Non-200 status code in inform response.\"\"\"\n\n    def __init__(self, status: int):\n        super().__init__(f\"DownloadBinaryInform returned {status}\")\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.BadStatus.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.MissingField","title":"MissingField","text":"<p>               Bases: <code>FUSError</code></p> <p>Required field missing from inform response.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class MissingField(FUSError):\n    \"\"\"Required field missing from inform response.\"\"\"\n\n    def __init__(self, field_name: str):\n        super().__init__(f\"Missing {field_name} in inform response\")\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.MissingField.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.DecryptionKeyError","title":"DecryptionKeyError","text":"<p>               Bases: <code>FUSError</code></p> <p>Could not obtain decryption key from inform response.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class DecryptionKeyError(FUSError):\n    \"\"\"Could not obtain decryption key from inform response.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\", device_id: str = \"\"):\n        msg = \"Could not obtain decryption key\"\n        details = []\n        if model:\n            details.append(f\"model={model}\")\n        if region:\n            details.append(f\"region={region}\")\n        if device_id:\n            details.append(f\"device_id={device_id[:4]}***\")\n        if details:\n            msg += f\" ({', '.join(details)})\"\n        msg += \"; check model/region/device_id\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.DecryptionKeyError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DownloadError","title":"DownloadError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised when a firmware download fails or is incomplete.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class DownloadError(FUSError):\n    \"\"\"Raised when a firmware download fails or is incomplete.\"\"\"\n\n    # Error subtypes with built-in messages\n    class HTTPError(FUSError):\n        \"\"\"HTTP error during download.\"\"\"\n\n        def __init__(self, status_code: int, url: str = \"\"):\n            msg = f\"HTTP {status_code} on download\"\n            if url:\n                msg += f\": {url}\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DownloadError.HTTPError","title":"HTTPError","text":"<p>               Bases: <code>FUSError</code></p> <p>HTTP error during download.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class HTTPError(FUSError):\n    \"\"\"HTTP error during download.\"\"\"\n\n    def __init__(self, status_code: int, url: str = \"\"):\n        msg = f\"HTTP {status_code} on download\"\n        if url:\n            msg += f\": {url}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DownloadError.HTTPError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DownloadError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError","title":"DecryptError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised when firmware decryption fails.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class DecryptError(FUSError):\n    \"\"\"Raised when firmware decryption fails.\"\"\"\n\n    # Error subtypes with built-in messages\n    class DeviceIdRequired(FUSError):\n        \"\"\"Device ID required for ENC4 decryption.\"\"\"\n\n        def __init__(self):\n            super().__init__(\"Device ID (IMEI or Serial) required for ENC4 key (Samsung requirement)\")\n\n    class InvalidBlockSize(FUSError):\n        \"\"\"Invalid encrypted file block size.\"\"\"\n\n        def __init__(self, size: int = 0):\n            msg = \"Invalid input block size (not multiple of 16)\"\n            if size:\n                msg += f\": {size} bytes\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.DeviceIdRequired","title":"DeviceIdRequired","text":"<p>               Bases: <code>FUSError</code></p> <p>Device ID required for ENC4 decryption.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class DeviceIdRequired(FUSError):\n    \"\"\"Device ID required for ENC4 decryption.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"Device ID (IMEI or Serial) required for ENC4 key (Samsung requirement)\")\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.DeviceIdRequired.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.InvalidBlockSize","title":"InvalidBlockSize","text":"<p>               Bases: <code>FUSError</code></p> <p>Invalid encrypted file block size.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class InvalidBlockSize(FUSError):\n    \"\"\"Invalid encrypted file block size.\"\"\"\n\n    def __init__(self, size: int = 0):\n        msg = \"Invalid input block size (not multiple of 16)\"\n        if size:\n            msg += f\": {size} bytes\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.InvalidBlockSize.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DeviceIdError","title":"DeviceIdError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class DeviceIdError(FUSError):\n    \"\"\"Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.\"\"\"\n\n    # Error subtypes with built-in messages\n    class InvalidTAC(FUSError):\n        \"\"\"TAC validation failed.\"\"\"\n\n        def __init__(self, tac: str = \"\"):\n            msg = \"TAC must have at least 8 digits\"\n            if tac:\n                msg += f\" (got: {tac})\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DeviceIdError.InvalidTAC","title":"InvalidTAC","text":"<p>               Bases: <code>FUSError</code></p> <p>TAC validation failed.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class InvalidTAC(FUSError):\n    \"\"\"TAC validation failed.\"\"\"\n\n    def __init__(self, tac: str = \"\"):\n        msg = \"TAC must have at least 8 digits\"\n        if tac:\n            msg += f\" (got: {tac})\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DeviceIdError.InvalidTAC.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DeviceIdError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class NoFirmware(Exception):  # Keep as Exception for backward compatibility\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAError","title":"FOTAError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for FOTA endpoint errors with optional predefined messages.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class FOTAError(Exception):\n    \"\"\"Base class for FOTA endpoint errors with optional predefined messages.\"\"\"\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAModelOrRegionNotFound","title":"FOTAModelOrRegionNotFound","text":"<p>               Bases: <code>FOTAError</code></p> <p>Model or region not found (HTTP 403).</p> Source code in <code>fus/errors.py</code> Python<pre><code>class FOTAModelOrRegionNotFound(FOTAError):\n    \"\"\"Model or region not found (HTTP 403).\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"Model or region not found (403)\"\n        if model or region:\n            msg += f\": {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTANoFirmware","title":"FOTANoFirmware","text":"<p>               Bases: <code>FOTAError</code></p> <p>No firmware available in FOTA response.</p> Source code in <code>fus/errors.py</code> Python<pre><code>class FOTANoFirmware(FOTAError):\n    \"\"\"No firmware available in FOTA response.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAParsingError","title":"FOTAParsingError","text":"<p>               Bases: <code>FOTAError</code></p> <p>Raised when FOTA XML response parsing fails.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The XML field that failed to parse.</p> <code>''</code> <code>model</code> <code>str</code> <p>Optional device model for context.</p> <code>''</code> <code>region</code> <code>str</code> <p>Optional region code for context.</p> <code>''</code> Source code in <code>fus/errors.py</code> Python<pre><code>class FOTAParsingError(FOTAError):\n    \"\"\"Raised when FOTA XML response parsing fails.\n\n    Args:\n        field: The XML field that failed to parse.\n        model: Optional device model for context.\n        region: Optional region code for context.\n    \"\"\"\n\n    def __init__(self, field: str = \"\", model: str = \"\", region: str = \"\"):\n        msg = \"Failed to parse FOTA response\"\n        if field:\n            msg += f\": missing or invalid '{field}' field\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.firmware/","title":"Package API <code>fus.firmware</code>","text":""},{"location":"api/fus.firmware/#fus.firmware","title":"fus.firmware","text":"<p>Firmware parsing and FOTA helpers for Samsung FUS.</p> <p>Provides utilities to normalize firmware version codes, parse PDA strings into meaningful fields (bootloader type, year, month, iteration), format human-readable info and fetch the latest firmware version from the FOTA endpoint.</p> <p>Functions: - normalize_vercode: Normalize a version code to a 4-part representation. - _read_firmware: Extract structured fields from a PDA/firmware string. - read_firmware_info: Return parsed firmware fields as a dictionary. - format_firmware_info: Produce a human-readable summary. - get_latest_version: Query the FOTA service for the latest version.</p>"},{"location":"api/fus.firmware/#fus.firmware.normalize_vercode","title":"normalize_vercode","text":"Python<pre><code>normalize_vercode(vercode)\n</code></pre> <p>Normalize a 3- or 4-part firmware version code to exactly 4 parts.</p> <p>Parameters:</p> Name Type Description Default <code>vercode</code> <code>str</code> <p>Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A normalized 4-part version string separated by '/'.</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def normalize_vercode(vercode: str) -&gt; str:\n    \"\"\"\n    Normalize a 3- or 4-part firmware version code to exactly 4 parts.\n\n    Args:\n        vercode: Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".\n\n    Returns:\n        A normalized 4-part version string separated by '/'.\n    \"\"\"\n    parts = vercode.split(\"/\")\n    if len(parts) == 3:\n        parts.append(parts[0])\n    if parts[2] == \"\":\n        parts[2] = parts[0]\n    return \"/\".join(parts)\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.read_firmware_info","title":"read_firmware_info","text":"Python<pre><code>read_firmware_info(firmware)\n</code></pre> <p>Return parsed firmware information as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: - \"bl\": bootloader type or None - \"date\": formatted \"YYYY.MM\" string - \"it\": iteration string \"major.minor\"</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def read_firmware_info(firmware: str) -&gt; dict:\n    \"\"\"\n    Return parsed firmware information as a dictionary.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        Dictionary with keys:\n            - \"bl\": bootloader type or None\n            - \"date\": formatted \"YYYY.MM\" string\n            - \"it\": iteration string \"major.minor\"\n    \"\"\"\n    ff = _read_firmware(firmware)\n    return {\"bl\": ff[0], \"date\": f\"{ff[2]}.{ff[3]+1:02d}\", \"it\": f\"{ff[1]}.{ff[4]}\"}\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.format_firmware_info","title":"format_firmware_info","text":"Python<pre><code>format_firmware_info(firmware)\n</code></pre> <p>Produce a human-readable summary of firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A multi-line string with normalized firmware, bootloader (if any),</p> <code>str</code> <p>date (YYYY.MM) and version iteration. If parsing fails, returns an</p> <code>str</code> <p>explanatory message containing the original input.</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def format_firmware_info(firmware: str) -&gt; str:\n    \"\"\"\n    Produce a human-readable summary of firmware information.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        A multi-line string with normalized firmware, bootloader (if any),\n        date (YYYY.MM) and version iteration. If parsing fails, returns an\n        explanatory message containing the original input.\n    \"\"\"\n    try:\n        info = read_firmware_info(firmware)\n        norm_fw = normalize_vercode(firmware)\n\n        result = f\"Firmware: {norm_fw}\\n\"\n        if info[\"bl\"]:\n            result += f\"Bootloader type: {info['bl']}\\n\"\n        result += f\"Date: {info['date']} (YYYY.MM)\\n\"\n        result += f\"Version iteration: {info['it']}\"\n\n        return result\n    except ValueError as ex:\n        raise FOTAParsingError(field=\"firmware\") from ex\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.get_latest_version","title":"get_latest_version","text":"Python<pre><code>get_latest_version(model, region)\n</code></pre> <p>Query the FOTA endpoint and return the latest firmware version code.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier (e.g. \"SM-G900F\").</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized version code string.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>If the endpoint returns 403 or other domain-specific errors.</p> <code>HTTPError</code> <p>For other non-success HTTP responses.</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def get_latest_version(model: str, region: str) -&gt; str:\n    \"\"\"\n    Query the FOTA endpoint and return the latest firmware version code.\n\n    Args:\n        model: Device model identifier (e.g. \"SM-G900F\").\n        region: CSC/region code.\n\n    Returns:\n        Normalized version code string.\n\n    Raises:\n        FUSError: If the endpoint returns 403 or other domain-specific errors.\n        requests.exceptions.HTTPError: For other non-success HTTP responses.\n    \"\"\"\n    # Use the request_timeout from DEFAULT_CONFIG (FUSConfig), fallback to 30 if not present.\n    if hasattr(DEFAULT_CONFIG, \"request_timeout\"):\n        timeout = DEFAULT_CONFIG.request_timeout\n    else:\n        timeout = 30\n    req = requests.get(\n        \"https://fota-cloud-dn.ospserver.net/firmware/\" + region + \"/\" + model + \"/version.xml\",\n        headers={'User-Agent': 'curl/7.87.0'},\n        timeout=timeout,\n    )\n    if req.status_code == 403:\n        raise FOTAModelOrRegionNotFound(model, region)\n    req.raise_for_status()\n    root = ET.fromstring(req.text)\n    latest = root.find(\"./firmware/version/latest\").text  # type: ignore\n    if latest is None:\n        raise FOTANoFirmware(model, region)\n    return normalize_vercode(latest)\n</code></pre>"},{"location":"api/fus.messages/","title":"Package API <code>fus.messages</code>","text":""},{"location":"api/fus.messages/#fus.messages","title":"fus.messages","text":"<p>FUS XML message builders.</p> <p>Provides helpers to construct XML payloads used by the FUS protocol (inform/init). These builders return raw XML bytes ready to be posted to the FUS endpoints.</p>"},{"location":"api/fus.messages/#fus.messages.build_binary_inform","title":"build_binary_inform","text":"Python<pre><code>build_binary_inform(fwv, model, region, device_id, nonce)\n</code></pre> <p>Build a BinaryInform request payload.</p> <p>Parameters:</p> Name Type Description Default <code>fwv</code> <code>str</code> <p>Firmware version code.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or Serial number.</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus/messages.py</code> Python<pre><code>def build_binary_inform(fwv: str, model: str, region: str, device_id: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInform request payload.\n\n    Args:\n        fwv: Firmware version code.\n        model: Device model identifier.\n        region: CSC/region code.\n        device_id: Device IMEI or Serial number.\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    params = {\n        \"ACCESS_MODE\": 2,\n        \"BINARY_NATURE\": 1,\n        \"CLIENT_PRODUCT\": \"Smart Switch\",\n        \"CLIENT_VERSION\": \"4.3.23123_1\",\n        \"DEVICE_IMEI_PUSH\": device_id,\n        \"DEVICE_FW_VERSION\": fwv,\n        \"DEVICE_LOCAL_CODE\": region,\n        \"DEVICE_MODEL_NAME\": model,\n        \"LOGIC_CHECK\": logic_check(fwv, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.messages/#fus.messages.build_binary_init","title":"build_binary_init","text":"Python<pre><code>build_binary_init(filename, nonce)\n</code></pre> <p>Build a BinaryInitForMass request payload.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Firmware file name (including extension).</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus/messages.py</code> Python<pre><code>def build_binary_init(filename: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInitForMass request payload.\n\n    Args:\n        filename: Firmware file name (including extension).\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    checkinp = filename.split(\".\")[0][-16:]\n    params = {\n        \"BINARY_FILE_NAME\": filename,\n        \"LOGIC_CHECK\": logic_check(checkinp, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.responses/","title":"Package API <code>fus.responses</code>","text":""},{"location":"api/fus.responses/#fus.responses","title":"fus.responses","text":"<p>FUS inform response parsing helpers.</p> <p>Provides a dataclass and parser to extract firmware-related metadata from a FUS BinaryInform XML response.</p> <p>Functions: - parse_inform: parse BinaryInform response into an InformInfo dataclass.</p>"},{"location":"api/fus.responses/#fus.responses.InformInfo","title":"InformInfo  <code>dataclass</code>","text":"<p>FUS BinaryInform response data.</p> <p>Dataclass holding parsed metadata from a Samsung FUS BinaryInform XML response. All fields are guaranteed to be present when status is 200.</p> <p>Attributes:</p> Name Type Description <code>latest_fw_version</code> <code>str</code> <p>Latest firmware version string.</p> <code>logic_value_factory</code> <code>str</code> <p>Logic value for ENC4 decryption key derivation.</p> <code>filename</code> <code>str</code> <p>Binary firmware filename on the server.</p> <code>path</code> <code>str</code> <p>Server model path.</p> <code>size_bytes</code> <code>int</code> <p>Firmware file size in bytes.</p> Source code in <code>fus/responses.py</code> Python<pre><code>@dataclass(frozen=True)\nclass InformInfo:\n    \"\"\"FUS BinaryInform response data.\n\n    Dataclass holding parsed metadata from a Samsung FUS BinaryInform XML response.\n    All fields are guaranteed to be present when status is 200.\n\n    Attributes:\n        latest_fw_version: Latest firmware version string.\n        logic_value_factory: Logic value for ENC4 decryption key derivation.\n        filename: Binary firmware filename on the server.\n        path: Server model path.\n        size_bytes: Firmware file size in bytes.\n    \"\"\"\n\n    latest_fw_version: str\n    logic_value_factory: str\n    filename: str\n    path: str\n    size_bytes: int\n</code></pre>"},{"location":"api/fus.responses/#fus.responses.parse_inform","title":"parse_inform","text":"Python<pre><code>parse_inform(root)\n</code></pre> <p>Parse a BinaryInform XML response into an InformInfo structure.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>Parsed XML root element of the BinaryInform response.</p> required <p>Returns:</p> Name Type Description <code>InformInfo</code> <code>InformInfo</code> <p>Dataclass containing latest firmware version, logic value,         filename, path and size in bytes.</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If the inform response status is not 200 or required fields are missing.</p> Source code in <code>fus/responses.py</code> Python<pre><code>def parse_inform(root: ET.Element) -&gt; InformInfo:\n    \"\"\"\n    Parse a BinaryInform XML response into an InformInfo structure.\n\n    Args:\n        root: Parsed XML root element of the BinaryInform response.\n\n    Returns:\n        InformInfo: Dataclass containing latest firmware version, logic value,\n                    filename, path and size in bytes.\n\n    Raises:\n        InformError: If the inform response status is not 200 or required fields are missing.\n    \"\"\"\n    status_elem = root.find(\"./FUSBody/Results/Status\")\n    if status_elem is None or status_elem.text is None:\n        raise InformError.MissingStatus()\n\n    status = int(status_elem.text)\n    if status != 200:\n        raise InformError.BadStatus(status)\n\n    # Extract required fields - raise InformError if any are missing\n    latest = root.findtext(\"./FUSBody/Results/LATEST_FW_VERSION/Data\")\n    if not latest:\n        raise InformError.MissingField(\"LATEST_FW_VERSION\")\n\n    logic = root.findtext(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\")\n    if not logic:\n        raise InformError.MissingField(\"LOGIC_VALUE_FACTORY\")\n\n    filename_elem = root.find(\"./FUSBody/Put/BINARY_NAME/Data\")\n    if filename_elem is None or not filename_elem.text:\n        raise InformError.MissingField(\"BINARY_NAME\")\n    filename = filename_elem.text\n\n    size_elem = root.find(\"./FUSBody/Put/BINARY_BYTE_SIZE/Data\")\n    if size_elem is None or not size_elem.text:\n        raise InformError.MissingField(\"BINARY_BYTE_SIZE\")\n    size = int(size_elem.text)\n\n    path = root.findtext(\"./FUSBody/Put/MODEL_PATH/Data\")\n    if not path:\n        raise InformError.MissingField(\"MODEL_PATH\")\n\n    return InformInfo(\n        latest_fw_version=latest,\n        logic_value_factory=logic,\n        filename=filename,\n        path=path,\n        size_bytes=size,\n    )\n</code></pre>"},{"location":"database/schema/","title":"Database Schema","text":"<p>This document describes the database schema used by nanosamfw for tracking firmware in the repository and IMEI operations.</p> <p>Release v0.1.2a</p>"},{"location":"database/schema/#overview","title":"Overview","text":"<p>The application uses SQLite (WAL mode, autocommit) for local data persistence with two main tables:</p> <ul> <li>firmware \u2014 Firmware repository with metadata from FUS inform responses</li> <li>imei_log \u2014 Logs IMEI-based firmware queries and FUS operation status</li> </ul> <p>All timestamps are in ISO 8601 format (UTC). Triggers automatically maintain <code>updated_at</code> fields.</p>"},{"location":"database/schema/#tables","title":"Tables","text":""},{"location":"database/schema/#firmware","title":"firmware","text":"<p>Firmware repository storing one record per firmware version with all metadata from Samsung FUS servers.</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>version_code</code> TEXT NOT NULL, UNIQUE Firmware version identifier (4-part format: AAA/BBB/CCC/DDD) <code>filename</code> TEXT NOT NULL Binary firmware filename from FUS server <code>path</code> TEXT NOT NULL Server model path from FUS inform response <code>size_bytes</code> INTEGER NOT NULL File size in bytes <code>logic_value_factory</code> TEXT NOT NULL Logic value for ENC4 decryption key derivation <code>latest_fw_version</code> TEXT NOT NULL Latest firmware version from inform response <code>encrypted_file_path</code> TEXT NOT NULL Absolute path to encrypted (.enc4) file on disk <code>decrypted_file_path</code> TEXT - Absolute path to decrypted file, or NULL if not decrypted <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of creation <code>updated_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of last update <p>Unique Constraint: <code>version_code</code> (one record per firmware version)</p> <p>Check Constraint: <code>version_code</code> must have exactly 3 slashes (4-part format)</p>"},{"location":"database/schema/#indexes","title":"Indexes","text":"<ul> <li><code>idx_firmware_version</code> - Index on <code>version_code</code> for fast lookups</li> <li><code>idx_firmware_filename</code> - Index on <code>filename</code> for search by filename</li> </ul>"},{"location":"database/schema/#triggers","title":"Triggers","text":"<ul> <li><code>trg_firmware_updated_at</code> - Automatically updates <code>updated_at</code> timestamp on row updates</li> </ul>"},{"location":"database/schema/#imei_log","title":"imei_log","text":"<p>Logs IMEI-based firmware queries with status tracking. Each device detection results in two log entries: 1. Initial FOTA query (status_fus=\"unknown\") 2. After firmware obtained from FUS or cache (status_fus=\"ok\")</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>imei</code> TEXT NOT NULL Device IMEI number <code>model</code> TEXT NOT NULL Device model identifier <code>csc</code> TEXT NOT NULL, CHECK length Country Specific Code (3-5 chars, supports multi-CSC like EUX/FTM) <code>version_code</code> TEXT NOT NULL, CHECK format Firmware version from FOTA in AAA/BBB/CCC/DDD format <code>status_fus</code> TEXT NOT NULL, DEFAULT 'unknown' FUS operation status (unknown=FOTA only, ok=firmware obtained, error/denied/unauthorized/throttled=FUS errors) <code>status_upgrade</code> TEXT NOT NULL, DEFAULT 'unknown' Reserved for future firmware flashing operations (currently always 'unknown') <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of log entry creation <code>upgrade_at</code> TEXT - Reserved for future firmware flashing timestamp (currently always NULL) <p>Constraints:</p> <ul> <li><code>status_fus</code> must be one of: <code>ok</code>, <code>error</code>, <code>denied</code>, <code>unauthorized</code>, <code>throttled</code>, <code>unknown</code></li> <li><code>status_upgrade</code> must be one of: <code>queued</code>, <code>in_progress</code>, <code>ok</code>, <code>failed</code>, <code>skipped</code>, <code>unknown</code></li> <li><code>version_code</code> must contain exactly 3 forward slashes (AAA/BBB/CCC/DDD format)</li> <li><code>csc</code> length must be between 3 and 5 characters</li> </ul> <p>Status Flow: Text Only<pre><code>Device Detected \u2192 check_and_prepare_firmware()\n  \u251c\u2500 Log #1: status_fus=\"unknown\" (FOTA queried, FUS not called yet)\n  \u2514\u2500 Check firmware table cache\n\nFirmware Obtained \u2192 download_and_decrypt()\n  \u2514\u2500 Log #2: status_fus=\"ok\" (firmware downloaded or retrieved from cache)\n</code></pre></p>"},{"location":"database/schema/#indexes_1","title":"Indexes","text":"<ul> <li><code>idx_imei_log__imei_created</code> - Composite index on <code>(imei, created_at DESC)</code> for IMEI history queries</li> <li><code>idx_imei_log__model_csc_created</code> - Composite index on <code>(model, csc, created_at DESC)</code> for device queries</li> <li><code>idx_imei_log__model_csc_version</code> - Composite index on <code>(model, csc, version_code)</code> for version lookups</li> <li><code>idx_imei_log__created_at</code> - Index on <code>created_at</code> for chronological queries</li> <li><code>idx_imei_log__upgrade_at</code> - Index on <code>upgrade_at</code> for upgrade operation queries</li> </ul>"},{"location":"database/schema/#sql-schema-files","title":"SQL Schema Files","text":"<p>The schema definitions are maintained in the following source files:</p> <ul> <li><code>download/sql/download.sql</code> - Downloads table schema</li> <li><code>download/sql/imei_log.sql</code> - IMEI log table schema</li> </ul>"},{"location":"database/schema/#usage","title":"Usage","text":"<p>The database is managed through the repository pattern:</p> <ul> <li>download.firmware_repository - Firmware repository operations</li> <li>download.imei_repository - IMEI log operations</li> <li>download.service - High-level service functions</li> <li>download.db - Database connection management</li> </ul>"}]}