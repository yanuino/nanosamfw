{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"nanosamfw Documentation","text":"<p>nanosamfw (NotANOtherSamsungFirmware downloader) is a Python package providing programmatic access to Samsung firmware downloads through the Samsung Firmware Update Service (FUS).</p>"},{"location":"#overview","title":"Overview","text":"<p>This package offers a clean, well-documented Python API for:</p> <ul> <li>Firmware Discovery: Query latest firmware versions for Samsung devices</li> <li>Secure Downloads: Download firmware with resume capability and encryption support</li> <li>Decryption: Automatic decryption of ENC2/ENC4 encrypted firmware files</li> <li>Database Tracking: Built-in SQLite tracking for downloads and IMEI operations</li> <li>Integration Ready: Designed for easy integration into tools and workflows</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#full-fus-protocol-support","title":"\ud83d\udd10 Full FUS Protocol Support","text":"<ul> <li>BinaryInform, BinaryInit, and BinaryDownload operations</li> <li>Server nonce handling and signature generation</li> <li>Device ID (IMEI/Serial) validation</li> </ul>"},{"location":"#device-detection","title":"\ud83d\udcf1 Device Detection","text":"<ul> <li>Auto-detect Samsung devices in MTP mode (cross-platform)</li> <li>Read device info via AT commands (model, IMEI, firmware versions)</li> <li>Seamless integration with firmware download workflow</li> <li>Requires: pyserial, Samsung USB drivers (Windows)</li> </ul>"},{"location":"#high-level-download-api","title":"\ud83d\udce6 High-Level Download API","text":"<ul> <li>One-line firmware downloads with automatic version resolution</li> <li>HTTP Range support for resuming interrupted downloads</li> <li>Progress callback support for custom UI integration</li> </ul>"},{"location":"#firmware-decryption","title":"\ud83d\udd13 Firmware Decryption","text":"<ul> <li>ENC2 (MD5-based) and ENC4 (logic-value-based) decryption</li> <li>Automatic key derivation from FUS responses</li> <li>Streaming decryption with progress tracking</li> </ul>"},{"location":"#firmware-repository","title":"\ud83d\udcbe Firmware Repository","text":"<ul> <li>Centralized firmware storage (no duplication per model/CSC)</li> <li>Cached InformInfo metadata for efficient operations</li> <li>IMEI event logging with status tracking</li> <li>Repository pattern for clean data access</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>nanosamfw uses a three-layer architecture for clean separation of concerns:</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Service Layer                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 check_and_prepare_firmware() \u2502 FOTA + cache check   \u2502\n\u2502 get_or_download_firmware()   \u2502 Smart download       \u2502\n\u2502 decrypt_firmware()           \u2502 Repository \u2192 decrypt \u2502\n\u2502 download_and_decrypt()       \u2502 Full workflow        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Repository Layer                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 firmware_repository.py   \u2502 FirmwareRecord CRUD       \u2502\n\u2502 imei_repository.py       \u2502 IMEIEvent logging         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Database Layer                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 firmware.db              \u2502                           \u2502\n\u2502  \u251c\u2500 firmware (repository)\u2502 version \u2192 file + metadata \u2502\n\u2502  \u2514\u2500 imei_log (tracking)  \u2502 FOTA queries + FUS status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key Design Principles:</p> <ul> <li>Firmware Repository: Centralized storage - one record per firmware version (no model/CSC duplication)</li> <li>Smart Downloads: Checks repository before downloading from FUS servers</li> <li>Cached Metadata: Stores InformInfo data including logic values for efficient decryption</li> <li>Separation of Concerns: FOTA check, download, and decrypt are independent operations</li> <li>Request Tracking: IMEI log captures all queries separately from firmware repository</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#complete-workflow","title":"Complete Workflow","text":"Python<pre><code>from download import download_and_decrypt\n\n# Download and decrypt in one call\nfirmware, decrypted = download_and_decrypt(\n    model=\"SM-G998B\",\n    csc=\"EUX\",\n    device_id=\"352976245060954\",\n    resume=True,\n)\n\nprint(f\"Version: {firmware.version_code}\")\nprint(f\"Decrypted file: {decrypted}\")\n</code></pre>"},{"location":"#separate-operations","title":"Separate Operations","text":"Python<pre><code>from download import check_and_prepare_firmware, get_or_download_firmware, decrypt_firmware\n\n# 1. Check FOTA for latest version and repository cache\nversion, is_cached = check_and_prepare_firmware(\n    \"SM-G998B\", \"EUX\", \"352976245060954\", \"current_firmware_version\"\n)\nprint(f\"Latest: {version}, Cached: {is_cached}\")\n\n# 2. Download to repository (if not already present)\nfirmware = get_or_download_firmware(version, \"SM-G998B\", \"EUX\", \"352976245060954\")\nprint(f\"Encrypted file: {firmware.encrypted_file_path}\")\n\n# 3. Decrypt from repository (can be deferred!)\ndecrypted = decrypt_firmware(version)\nprint(f\"Decrypted file: {decrypted}\")\n</code></pre>"},{"location":"#repository-queries","title":"Repository Queries","text":"Python<pre><code>from download import find_firmware, list_firmware\n\n# Find specific version\nfw = find_firmware(\"G998BXXU1ATCT/...\")\nif fw:\n    print(f\"Logic value: {fw.logic_value_factory}\")\n    print(f\"Size: {fw.size_bytes} bytes\")\n\n# List all firmware in repository\nfor fw in list_firmware(limit=10):\n    print(f\"{fw.version_code}: {fw.filename}\")\n</code></pre>"},{"location":"#device-integration","title":"Device Integration","text":"Python<pre><code>from device import read_device_info_at\nfrom download import check_and_prepare_firmware, download_and_decrypt\n\n# Auto-detect connected device (requires pyserial)\ndevice = read_device_info_at()\nprint(f\"Connected: {device.model} - IMEI: {device.imei}\")\nprint(f\"Current firmware: {device.firmware_version}\")\n\n# Check FOTA for latest version and repository cache\nlatest, is_cached = check_and_prepare_firmware(\n    device.model, device.sales_code, device.imei, device.firmware_version\n)\nprint(f\"Latest firmware: {latest}, Already downloaded: {is_cached}\")\n\n# Download if update available\nif latest != device.firmware_version:\n    firmware, decrypted = download_and_decrypt(\n        model=device.model,\n        csc=device.sales_code,\n        device_id=device.imei,\n        current_firmware=device.firmware_version\n    )\n    print(f\"Downloaded: {decrypted}\")\nelse:\n    print(\"Already up to date\")\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>Dependencies:</li> <li><code>pycryptodome</code> - Cryptographic operations</li> <li><code>requests</code> - HTTP client</li> <li><code>tqdm</code> - Progress bars</li> <li>Device Detection (optional):</li> <li><code>pyserial</code> - Serial port communication and device detection</li> <li>Samsung USB drivers (Windows)</li> </ul>"},{"location":"#installation","title":"Installation","text":"Bash<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":""},{"location":"#core-modules","title":"Core Modules","text":"<ul> <li>fus - FUS protocol client and utilities</li> <li>Client implementation with session management</li> <li>Cryptographic operations and key derivation</li> <li>Firmware version parsing and normalization</li> <li> <p>Device ID validation (IMEI/Serial)</p> </li> <li> <p>download - High-level download service</p> </li> <li>Firmware repository management</li> <li>FOTA version checking with IMEI logging</li> <li>Smart download (skips if already in repository)</li> <li>On-demand decryption with cached logic values</li> <li>Configuration and path management</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Core API - FUS client, cryptography, device validation</li> <li>Download API - Service layer, repositories, configuration</li> <li>Database - Schema documentation and repository patterns</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is MIT licensed. See the LICENSE file for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please ensure:</p> <ul> <li>Code follows PEP 8 and project style guidelines (100 char line length)</li> <li>Type hints are provided for all public APIs</li> <li>Google-style docstrings document all functions</li> <li>Tests cover new functionality</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> </ul>"},{"location":"api/device.detector/","title":"Device Detector","text":"<p>Samsung device detection via serial port enumeration.</p> <p>This module provides functions to detect Samsung devices connected in download mode (Odin mode) by enumerating serial ports for Samsung Mobile USB Modems.</p> <p>Uses pyserial's list_ports for cross-platform compatibility. Requires Samsung USB drivers installed on Windows.</p> <p>Based on SharpOdinClient implementation by Gsm Alphabet.</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.detector/#device.detector.DetectedDevice","title":"DetectedDevice","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Information about a detected Samsung device in download mode.</p> <p>Attributes:</p> Name Type Description <code>port_name</code> <code>str</code> <p>Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)</p> <code>device_name</code> <code>str</code> <p>Full device description from port enumeration</p> <code>manufacturer</code> <code>str</code> <p>Device manufacturer string (if available)</p> <code>product</code> <code>str</code> <p>Product description string (if available)</p> <code>vid</code> <code>Optional[str]</code> <p>USB Vendor ID (4-char hex string, if available)</p> <code>pid</code> <code>Optional[str]</code> <p>USB Product ID (4-char hex string, if available)</p> Source code in <code>device\\detector.py</code> Python<pre><code>class DetectedDevice(NamedTuple):\n    \"\"\"Information about a detected Samsung device in download mode.\n\n    Attributes:\n        port_name: Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)\n        device_name: Full device description from port enumeration\n        manufacturer: Device manufacturer string (if available)\n        product: Product description string (if available)\n        vid: USB Vendor ID (4-char hex string, if available)\n        pid: USB Product ID (4-char hex string, if available)\n    \"\"\"\n\n    port_name: str\n    device_name: str\n    manufacturer: str\n    product: str\n    vid: Optional[str] = None\n    pid: Optional[str] = None\n</code></pre>"},{"location":"api/device.detector/#device.detector.detect_download_mode_devices","title":"detect_download_mode_devices","text":"Python<pre><code>detect_download_mode_devices()\n</code></pre> <p>Detect Samsung devices connected in download mode (Odin mode).</p> <p>Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their device description. This is different from MTP mode devices.</p> <p>Uses pyserial's list_ports to enumerate serial ports.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected download mode devices. Empty if no devices found.</p> Source code in <code>device\\detector.py</code> Python<pre><code>def detect_download_mode_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect Samsung devices connected in download mode (Odin mode).\n\n    Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their\n    device description. This is different from MTP mode devices.\n\n    Uses pyserial's list_ports to enumerate serial ports.\n\n    Returns:\n        List of detected download mode devices. Empty if no devices found.\n    \"\"\"\n    devices = []\n\n    for port in list_ports.comports():\n        # Check device description for download mode signature\n        description = port.description or \"\"\n        manufacturer = port.manufacturer or \"\"\n        product = port.product or \"\"\n\n        # Download mode devices have specific signature\n        is_download_mode = \"samsung mobile usb modem\" in description.lower()\n\n        if is_download_mode and port.device:\n            # Extract VID/PID from hardware ID\n            hwid = port.hwid or \"\"\n            vid, pid = _extract_vid_pid(hwid)\n\n            devices.append(\n                DetectedDevice(\n                    port_name=port.device,\n                    device_name=description,\n                    manufacturer=manufacturer,\n                    product=product,\n                    vid=vid,\n                    pid=pid,\n                )\n            )\n\n    return devices\n</code></pre>"},{"location":"api/device.detector/#device.detector.detect_samsung_devices","title":"detect_samsung_devices","text":"Python<pre><code>detect_samsung_devices()\n</code></pre> <p>Detect all Samsung devices (alias for detect_download_mode_devices).</p> <p>This function is kept for backward compatibility but now detects download mode devices only.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected devices with port information. Empty if no devices found.</p> Source code in <code>device\\detector.py</code> Python<pre><code>def detect_samsung_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect all Samsung devices (alias for detect_download_mode_devices).\n\n    This function is kept for backward compatibility but now detects\n    download mode devices only.\n\n    Returns:\n        List of detected devices with port information. Empty if no devices found.\n    \"\"\"\n    return detect_download_mode_devices()\n</code></pre>"},{"location":"api/device.detector/#device.detector.get_first_device","title":"get_first_device","text":"Python<pre><code>get_first_device()\n</code></pre> <p>Get the first detected Samsung device in download mode.</p> <p>Convenience function for single-device scenarios.</p> <p>Returns:</p> Type Description <code>DetectedDevice</code> <p>First detected device</p> <p>Raises:</p> Type Description <code>DeviceNotFoundError</code> <p>If no Samsung devices are connected in download mode</p> Source code in <code>device\\detector.py</code> Python<pre><code>def get_first_device() -&gt; DetectedDevice:\n    \"\"\"Get the first detected Samsung device in download mode.\n\n    Convenience function for single-device scenarios.\n\n    Returns:\n        First detected device\n\n    Raises:\n        DeviceNotFoundError: If no Samsung devices are connected in download mode\n    \"\"\"\n    devices = detect_download_mode_devices()\n    if not devices:\n        raise DeviceNotFoundError(\n            \"No Samsung devices in download mode detected. \"\n            \"Ensure device is connected in download mode (Odin mode) \"\n            \"and Samsung USB drivers are installed (Windows). \"\n            \"To enter download mode: Power off device, then hold Volume Down + Home + Power.\"\n        )\n    return devices[0]\n</code></pre>"},{"location":"api/device.errors/","title":"Device Errors","text":"<p>Exception types for device operations.</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.errors/#device.errors.DeviceError","title":"DeviceError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for device-related errors.</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceError(Exception):\n    \"\"\"Base exception for device-related errors.\"\"\"\n</code></pre>"},{"location":"api/device.errors/#device.errors.DeviceNotFoundError","title":"DeviceNotFoundError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when no Samsung devices are detected in MTP mode.</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceNotFoundError(DeviceError):\n    \"\"\"Raised when no Samsung devices are detected in MTP mode.\"\"\"\n</code></pre>"},{"location":"api/device.errors/#device.errors.DeviceReadError","title":"DeviceReadError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when device information cannot be read via AT commands.</p> <p>This can occur due to: - Serial port communication failure - Device busy (returns BUSY response) - Malformed AT command response - Permission/driver issues</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceReadError(DeviceError):\n    \"\"\"Raised when device information cannot be read via AT commands.\n\n    This can occur due to:\n    - Serial port communication failure\n    - Device busy (returns BUSY response)\n    - Malformed AT command response\n    - Permission/driver issues\n    \"\"\"\n</code></pre>"},{"location":"api/device.errors/#device.errors.DeviceParseError","title":"DeviceParseError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when AT command response cannot be parsed.</p> <p>This indicates the device returned data but in an unexpected format.</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceParseError(DeviceError):\n    \"\"\"Raised when AT command response cannot be parsed.\n\n    This indicates the device returned data but in an unexpected format.\n    \"\"\"\n</code></pre>"},{"location":"api/device/","title":"Device Detection","text":"<p>Samsung device detection and information reading.</p> <p>This package provides functionality to detect Samsung devices in download mode (Odin mode) and read device information using the Odin binary protocol.</p> <p>Based on SharpOdinClient implementation by Gsm Alphabet (https://github.com/Alephgsm/SharpOdinClient)</p> <p>Platform Requirements: - Cross-platform support (Windows, Linux, macOS) - Samsung USB drivers installed (Windows) - Python package: pyserial - Device must be in download mode (Odin mode)</p> <p>Entering Download Mode:</p> <p>To put a Samsung device into download mode: 1. Power off the device completely 2. Press and hold: Volume Down + Home + Power buttons 3. When warning screen appears, press Volume Up to continue 4. Device should display \"Downloading...\" screen</p> <p>Installation:</p> <p>.. code-block:: bash</p> Text Only<pre><code>pip install pyserial\n</code></pre> <p>Usage:</p> <p>Auto-detect and read device info:</p> <p>.. code-block:: python</p> Text Only<pre><code>from device import read_device_info, is_odin_mode\n\ntry:\n    # Check if device is in Odin mode\n    from device import detect_download_mode_devices\n    devices = detect_download_mode_devices()\n\n    if devices:\n        port = devices[0].port_name\n        if is_odin_mode(port):\n            info = read_device_info(port)\n            print(f\"Model: {info.model}\")\n            print(f\"Firmware: {info.fwver}\")\n            print(f\"Sales Code: {info.sales}\")\nexcept Exception as ex:\n    print(f\"Error: {ex}\")\n</code></pre> <p>Manual device detection with VID/PID:</p> <p>.. code-block:: python</p> Text Only<pre><code>from device import detect_download_mode_devices\n\ndevices = detect_download_mode_devices()\nfor device in devices:\n    print(f\"Found: {device.device_name}\")\n    print(f\"  Port: {device.port_name}\")\n    print(f\"  VID: {device.vid}, PID: {device.pid}\")\n</code></pre> <p>Integration with nanosamfw:</p> <p>Use detected device information for firmware downloads:</p> <p>.. code-block:: python</p> Text Only<pre><code>from device import read_device_info\nfrom download import check_firmware, download_and_decrypt\n\n# Read from device in download mode\ndevice_info = read_device_info()\n\n# Use sales code as CSC for firmware download\nif device_info.model and device_info.sales:\n    firmware_info = check_firmware(\n        model=device_info.model,\n        csc=device_info.sales,\n        device_id=\"\"  # IMEI not available in download mode\n    )\n</code></pre> <p>Protocol Details:</p> <p>This package implements the Odin/LOKE protocol used by Samsung's Odin flash tool: - DVIF (0x44,0x56,0x49,0x46): Get device information - ODIN (0x4F,0x44,0x49,0x4E): Verify Odin mode (expects \"LOKE\" response) - Communication at 115200 baud with RTS/CTS flow control</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device/#device.DetectedDevice","title":"DetectedDevice","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Information about a detected Samsung device in download mode.</p> <p>Attributes:</p> Name Type Description <code>port_name</code> <code>str</code> <p>Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)</p> <code>device_name</code> <code>str</code> <p>Full device description from port enumeration</p> <code>manufacturer</code> <code>str</code> <p>Device manufacturer string (if available)</p> <code>product</code> <code>str</code> <p>Product description string (if available)</p> <code>vid</code> <code>Optional[str]</code> <p>USB Vendor ID (4-char hex string, if available)</p> <code>pid</code> <code>Optional[str]</code> <p>USB Product ID (4-char hex string, if available)</p> Source code in <code>device\\detector.py</code> Python<pre><code>class DetectedDevice(NamedTuple):\n    \"\"\"Information about a detected Samsung device in download mode.\n\n    Attributes:\n        port_name: Serial port device ID (e.g., COM3 on Windows, /dev/ttyACM0 on Linux)\n        device_name: Full device description from port enumeration\n        manufacturer: Device manufacturer string (if available)\n        product: Product description string (if available)\n        vid: USB Vendor ID (4-char hex string, if available)\n        pid: USB Product ID (4-char hex string, if available)\n    \"\"\"\n\n    port_name: str\n    device_name: str\n    manufacturer: str\n    product: str\n    vid: Optional[str] = None\n    pid: Optional[str] = None\n</code></pre>"},{"location":"api/device/#device.DeviceError","title":"DeviceError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for device-related errors.</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceError(Exception):\n    \"\"\"Base exception for device-related errors.\"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceNotFoundError","title":"DeviceNotFoundError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when no Samsung devices are detected in MTP mode.</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceNotFoundError(DeviceError):\n    \"\"\"Raised when no Samsung devices are detected in MTP mode.\"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceParseError","title":"DeviceParseError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when AT command response cannot be parsed.</p> <p>This indicates the device returned data but in an unexpected format.</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceParseError(DeviceError):\n    \"\"\"Raised when AT command response cannot be parsed.\n\n    This indicates the device returned data but in an unexpected format.\n    \"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceReadError","title":"DeviceReadError","text":"<p>               Bases: <code>DeviceError</code></p> <p>Raised when device information cannot be read via AT commands.</p> <p>This can occur due to: - Serial port communication failure - Device busy (returns BUSY response) - Malformed AT command response - Permission/driver issues</p> Source code in <code>device\\errors.py</code> Python<pre><code>class DeviceReadError(DeviceError):\n    \"\"\"Raised when device information cannot be read via AT commands.\n\n    This can occur due to:\n    - Serial port communication failure\n    - Device busy (returns BUSY response)\n    - Malformed AT command response\n    - Permission/driver issues\n    \"\"\"\n</code></pre>"},{"location":"api/device/#device.DeviceInfo","title":"DeviceInfo  <code>dataclass</code>","text":"<p>Samsung device information (DEPRECATED - kept for backward compatibility).</p> <p>.. deprecated::     This class was used with AT commands for MTP mode devices.     The package now uses Odin download mode protocol.     Use OdinDeviceInfo from device.protocol instead.</p> <p>All fields are extracted from the AT+DEVCONINFO response which follows the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product); SN(serial);IMEI(imei);UN(un).</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Device model code (e.g., SM-G991B)</p> <code>device_name</code> <code>str</code> <p>Device marketing name (typically same as model)</p> <code>pda_version</code> <code>str</code> <p>PDA firmware version</p> <code>csc_version</code> <code>str</code> <p>CSC (Country Specific Code) version</p> <code>modem_version</code> <code>str</code> <p>Modem/baseband firmware version</p> <code>region</code> <code>str</code> <p>3-character CSC region code</p> <code>serial_number</code> <code>str</code> <p>Device serial number</p> <code>imei</code> <code>str</code> <p>International Mobile Equipment Identity</p> <code>unique_number</code> <code>str</code> <p>Samsung unique number (UN)</p> Source code in <code>device\\models.py</code> Python<pre><code>@dataclass(frozen=True)\nclass DeviceInfo:\n    \"\"\"Samsung device information (DEPRECATED - kept for backward compatibility).\n\n    .. deprecated::\n        This class was used with AT commands for MTP mode devices.\n        The package now uses Odin download mode protocol.\n        Use OdinDeviceInfo from device.protocol instead.\n\n    All fields are extracted from the AT+DEVCONINFO response which follows\n    the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product);\n    SN(serial);IMEI(imei);UN(un).\n\n    Attributes:\n        model: Device model code (e.g., SM-G991B)\n        device_name: Device marketing name (typically same as model)\n        pda_version: PDA firmware version\n        csc_version: CSC (Country Specific Code) version\n        modem_version: Modem/baseband firmware version\n        region: 3-character CSC region code\n        serial_number: Device serial number\n        imei: International Mobile Equipment Identity\n        unique_number: Samsung unique number (UN)\n    \"\"\"\n\n    model: str\n    device_name: str\n    pda_version: str\n    csc_version: str\n    modem_version: str\n    region: str\n    serial_number: str\n    imei: str\n    unique_number: str\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return human-readable device information.\"\"\"\n        return (\n            f\"{self.model} ({self.device_name})\\n\"\n            f\"  PDA: {self.pda_version}\\n\"\n            f\"  CSC: {self.csc_version} ({self.region})\\n\"\n            f\"  Modem: {self.modem_version}\\n\"\n            f\"  IMEI: {self.imei}\\n\"\n            f\"  S/N: {self.serial_number}\\n\"\n            f\"  UN: {self.unique_number}\"\n        )\n</code></pre>"},{"location":"api/device/#device.OdinCommand","title":"OdinCommand  <code>dataclass</code>","text":"<p>Odin/LOKE protocol command structure.</p> <p>This represents the 1024-byte command buffer used for all Odin protocol operations. The structure matches Samsung's binary protocol.</p> <p>Structure (little-endian):     - Cmd (4 bytes): Command code     - SeqCmd (4 bytes): Sequence/sub-command     - BinaryType (4 or 8 bytes): Binary type identifier     - SizeWritten (4 bytes): Size of data written     - Unknown (4 bytes): Reserved/unknown field     - DeviceId (4 bytes): Device type identifier     - Identifier (4 bytes): Partition identifier     - SessionEnd (4 bytes): Session end flag     - EfsClear (4 bytes): EFS clear flag     - BootUpdate (4 bytes): Boot update flag</p> Common command codes <ul> <li>0x64 (100): LOKE_Initialize</li> <li>0x65 (101): Read/Write PIT</li> <li>0x66 (102): Flash data</li> <li>0x67 (103): Reboot to normal mode</li> <li>0x69 (105): Additional initialization</li> </ul> Source code in <code>device\\protocol.py</code> Python<pre><code>@dataclass\nclass OdinCommand:\n    \"\"\"Odin/LOKE protocol command structure.\n\n    This represents the 1024-byte command buffer used for all Odin protocol\n    operations. The structure matches Samsung's binary protocol.\n\n    Structure (little-endian):\n        - Cmd (4 bytes): Command code\n        - SeqCmd (4 bytes): Sequence/sub-command\n        - BinaryType (4 or 8 bytes): Binary type identifier\n        - SizeWritten (4 bytes): Size of data written\n        - Unknown (4 bytes): Reserved/unknown field\n        - DeviceId (4 bytes): Device type identifier\n        - Identifier (4 bytes): Partition identifier\n        - SessionEnd (4 bytes): Session end flag\n        - EfsClear (4 bytes): EFS clear flag\n        - BootUpdate (4 bytes): Boot update flag\n\n    Common command codes:\n        - 0x64 (100): LOKE_Initialize\n        - 0x65 (101): Read/Write PIT\n        - 0x66 (102): Flash data\n        - 0x67 (103): Reboot to normal mode\n        - 0x69 (105): Additional initialization\n    \"\"\"\n\n    cmd: int\n    seq_cmd: int = 0\n    binary_type: int = 0\n    size_written: int = 0\n    unknown: int = 0\n    device_id: int = 0\n    identifier: int = 0\n    session_end: int = 0\n    efs_clear: int = 0\n    boot_update: int = 0\n\n    def to_bytes(self) -&gt; bytes:\n        \"\"\"Serialize command to 1024-byte buffer.\n\n        Returns:\n            1024-byte buffer in Odin protocol format\n        \"\"\"\n        buffer = bytearray(1024)\n\n        # Pack header fields (little-endian)\n        struct.pack_into(\"&lt;I\", buffer, 0, self.cmd)\n        struct.pack_into(\"&lt;I\", buffer, 4, self.seq_cmd)\n\n        # BinaryType is 8 bytes for cmd 0x64 (100), else 4 bytes\n        if self.cmd == 100:\n            struct.pack_into(\"&lt;Q\", buffer, 8, self.binary_type)\n        else:\n            struct.pack_into(\"&lt;I\", buffer, 8, self.binary_type)\n            struct.pack_into(\"&lt;I\", buffer, 12, self.size_written)\n\n        struct.pack_into(\"&lt;I\", buffer, 16, self.unknown)\n        struct.pack_into(\"&lt;I\", buffer, 20, self.device_id)\n        struct.pack_into(\"&lt;I\", buffer, 24, self.identifier)\n        struct.pack_into(\"&lt;I\", buffer, 28, self.session_end)\n        struct.pack_into(\"&lt;I\", buffer, 32, self.efs_clear)\n        struct.pack_into(\"&lt;I\", buffer, 36, self.boot_update)\n\n        return bytes(buffer)\n\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; \"OdinCommand\":\n        \"\"\"Parse command from response buffer.\n\n        Args:\n            data: Response buffer (minimum 8 bytes)\n\n        Returns:\n            Parsed command\n\n        Raises:\n            ValueError: If data is too short\n        \"\"\"\n        if len(data) &lt; 8:\n            raise ValueError(f\"Response too short: {len(data)} bytes (need 8)\")\n\n        cmd = struct.unpack_from(\"&lt;I\", data, 0)[0]\n        seq_cmd = struct.unpack_from(\"&lt;I\", data, 4)[0]\n\n        return cls(cmd=cmd, seq_cmd=seq_cmd)\n</code></pre>"},{"location":"api/device/#device.OdinCommand.to_bytes","title":"to_bytes","text":"Python<pre><code>to_bytes()\n</code></pre> <p>Serialize command to 1024-byte buffer.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>1024-byte buffer in Odin protocol format</p> Source code in <code>device\\protocol.py</code> Python<pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"Serialize command to 1024-byte buffer.\n\n    Returns:\n        1024-byte buffer in Odin protocol format\n    \"\"\"\n    buffer = bytearray(1024)\n\n    # Pack header fields (little-endian)\n    struct.pack_into(\"&lt;I\", buffer, 0, self.cmd)\n    struct.pack_into(\"&lt;I\", buffer, 4, self.seq_cmd)\n\n    # BinaryType is 8 bytes for cmd 0x64 (100), else 4 bytes\n    if self.cmd == 100:\n        struct.pack_into(\"&lt;Q\", buffer, 8, self.binary_type)\n    else:\n        struct.pack_into(\"&lt;I\", buffer, 8, self.binary_type)\n        struct.pack_into(\"&lt;I\", buffer, 12, self.size_written)\n\n    struct.pack_into(\"&lt;I\", buffer, 16, self.unknown)\n    struct.pack_into(\"&lt;I\", buffer, 20, self.device_id)\n    struct.pack_into(\"&lt;I\", buffer, 24, self.identifier)\n    struct.pack_into(\"&lt;I\", buffer, 28, self.session_end)\n    struct.pack_into(\"&lt;I\", buffer, 32, self.efs_clear)\n    struct.pack_into(\"&lt;I\", buffer, 36, self.boot_update)\n\n    return bytes(buffer)\n</code></pre>"},{"location":"api/device/#device.OdinCommand.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"Python<pre><code>from_bytes(data)\n</code></pre> <p>Parse command from response buffer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Response buffer (minimum 8 bytes)</p> required <p>Returns:</p> Type Description <code>OdinCommand</code> <p>Parsed command</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data is too short</p> Source code in <code>device\\protocol.py</code> Python<pre><code>@classmethod\ndef from_bytes(cls, data: bytes) -&gt; \"OdinCommand\":\n    \"\"\"Parse command from response buffer.\n\n    Args:\n        data: Response buffer (minimum 8 bytes)\n\n    Returns:\n        Parsed command\n\n    Raises:\n        ValueError: If data is too short\n    \"\"\"\n    if len(data) &lt; 8:\n        raise ValueError(f\"Response too short: {len(data)} bytes (need 8)\")\n\n    cmd = struct.unpack_from(\"&lt;I\", data, 0)[0]\n    seq_cmd = struct.unpack_from(\"&lt;I\", data, 4)[0]\n\n    return cls(cmd=cmd, seq_cmd=seq_cmd)\n</code></pre>"},{"location":"api/device/#device.OdinDeviceInfo","title":"OdinDeviceInfo  <code>dataclass</code>","text":"<p>Device information from Odin download mode (DVIF protocol).</p> <p>This is returned by sending DVIF command (0x44,0x56,0x49,0x46) to a device in download mode. Response format is semicolon-separated key=value pairs.</p> Example response <p>@capa=1;product=GT-I9300;model=GT-I9300;fwver=I9300XXEMK4;...#</p> <p>Attributes:</p> Name Type Description <code>capa</code> <code>Optional[str]</code> <p>Device capability number</p> <code>product</code> <code>Optional[str]</code> <p>Product identifier</p> <code>model</code> <code>Optional[str]</code> <p>Model number</p> <code>fwver</code> <code>Optional[str]</code> <p>Firmware version string</p> <code>vendor</code> <code>Optional[str]</code> <p>Vendor identifier</p> <code>sales</code> <code>Optional[str]</code> <p>Sales code (region)</p> <code>ver</code> <code>Optional[str]</code> <p>Build number</p> <code>did</code> <code>Optional[str]</code> <p>Device ID</p> <code>un</code> <code>Optional[str]</code> <p>Unique number</p> <code>tmu_temp</code> <code>Optional[str]</code> <p>TMU temperature sensor value</p> <code>prov</code> <code>Optional[str]</code> <p>Provision status</p> <code>raw_response</code> <code>str</code> <p>Original raw response from device</p> Source code in <code>device\\protocol.py</code> Python<pre><code>@dataclass(frozen=True)\nclass OdinDeviceInfo:\n    \"\"\"Device information from Odin download mode (DVIF protocol).\n\n    This is returned by sending DVIF command (0x44,0x56,0x49,0x46) to a device\n    in download mode. Response format is semicolon-separated key=value pairs.\n\n    Example response:\n        @capa=1;product=GT-I9300;model=GT-I9300;fwver=I9300XXEMK4;...#\n\n    Attributes:\n        capa: Device capability number\n        product: Product identifier\n        model: Model number\n        fwver: Firmware version string\n        vendor: Vendor identifier\n        sales: Sales code (region)\n        ver: Build number\n        did: Device ID\n        un: Unique number\n        tmu_temp: TMU temperature sensor value\n        prov: Provision status\n        raw_response: Original raw response from device\n    \"\"\"\n\n    capa: Optional[str] = None\n    product: Optional[str] = None\n    model: Optional[str] = None\n    fwver: Optional[str] = None\n    vendor: Optional[str] = None\n    sales: Optional[str] = None\n    ver: Optional[str] = None\n    did: Optional[str] = None\n    un: Optional[str] = None\n    tmu_temp: Optional[str] = None\n    prov: Optional[str] = None\n    raw_response: str = \"\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return human-readable device information.\"\"\"\n        lines = []\n        if self.model:\n            lines.append(f\"Model: {self.model}\")\n        if self.product:\n            lines.append(f\"Product: {self.product}\")\n        if self.fwver:\n            lines.append(f\"Firmware: {self.fwver}\")\n        if self.sales:\n            lines.append(f\"Sales Code: {self.sales}\")\n        if self.un:\n            lines.append(f\"Unique ID: {self.un}\")\n        return \"\\n\".join(lines) if lines else \"No device info\"\n</code></pre>"},{"location":"api/device/#device.ATDeviceInfo","title":"ATDeviceInfo  <code>dataclass</code>","text":"<p>Device information from AT commands.</p> <p>Simplified device info structure for AT+DEVCONINFO responses. For more detailed information, use Odin protocol (OdinDeviceInfo).</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Device model code (e.g., SM-G991B)</p> <code>firmware_version</code> <code>str</code> <p>Current firmware version string</p> <code>sales_code</code> <code>str</code> <p>3-character CSC/region code (e.g., XAA, DBT)</p> <code>imei</code> <code>str</code> <p>International Mobile Equipment Identity (15 digits)</p> Source code in <code>device\\reader_at.py</code> Python<pre><code>@dataclass(frozen=True)\nclass ATDeviceInfo:\n    \"\"\"Device information from AT commands.\n\n    Simplified device info structure for AT+DEVCONINFO responses.\n    For more detailed information, use Odin protocol (OdinDeviceInfo).\n\n    Attributes:\n        model: Device model code (e.g., SM-G991B)\n        firmware_version: Current firmware version string\n        sales_code: 3-character CSC/region code (e.g., XAA, DBT)\n        imei: International Mobile Equipment Identity (15 digits)\n    \"\"\"\n\n    model: str\n    firmware_version: str\n    sales_code: str\n    imei: str\n</code></pre>"},{"location":"api/device/#device.detect_download_mode_devices","title":"detect_download_mode_devices","text":"Python<pre><code>detect_download_mode_devices()\n</code></pre> <p>Detect Samsung devices connected in download mode (Odin mode).</p> <p>Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their device description. This is different from MTP mode devices.</p> <p>Uses pyserial's list_ports to enumerate serial ports.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected download mode devices. Empty if no devices found.</p> Source code in <code>device\\detector.py</code> Python<pre><code>def detect_download_mode_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect Samsung devices connected in download mode (Odin mode).\n\n    Download mode devices identify as \"SAMSUNG MOBILE USB MODEM\" in their\n    device description. This is different from MTP mode devices.\n\n    Uses pyserial's list_ports to enumerate serial ports.\n\n    Returns:\n        List of detected download mode devices. Empty if no devices found.\n    \"\"\"\n    devices = []\n\n    for port in list_ports.comports():\n        # Check device description for download mode signature\n        description = port.description or \"\"\n        manufacturer = port.manufacturer or \"\"\n        product = port.product or \"\"\n\n        # Download mode devices have specific signature\n        is_download_mode = \"samsung mobile usb modem\" in description.lower()\n\n        if is_download_mode and port.device:\n            # Extract VID/PID from hardware ID\n            hwid = port.hwid or \"\"\n            vid, pid = _extract_vid_pid(hwid)\n\n            devices.append(\n                DetectedDevice(\n                    port_name=port.device,\n                    device_name=description,\n                    manufacturer=manufacturer,\n                    product=product,\n                    vid=vid,\n                    pid=pid,\n                )\n            )\n\n    return devices\n</code></pre>"},{"location":"api/device/#device.detect_samsung_devices","title":"detect_samsung_devices","text":"Python<pre><code>detect_samsung_devices()\n</code></pre> <p>Detect all Samsung devices (alias for detect_download_mode_devices).</p> <p>This function is kept for backward compatibility but now detects download mode devices only.</p> <p>Returns:</p> Type Description <code>list[DetectedDevice]</code> <p>List of detected devices with port information. Empty if no devices found.</p> Source code in <code>device\\detector.py</code> Python<pre><code>def detect_samsung_devices() -&gt; list[DetectedDevice]:\n    \"\"\"Detect all Samsung devices (alias for detect_download_mode_devices).\n\n    This function is kept for backward compatibility but now detects\n    download mode devices only.\n\n    Returns:\n        List of detected devices with port information. Empty if no devices found.\n    \"\"\"\n    return detect_download_mode_devices()\n</code></pre>"},{"location":"api/device/#device.get_first_device","title":"get_first_device","text":"Python<pre><code>get_first_device()\n</code></pre> <p>Get the first detected Samsung device in download mode.</p> <p>Convenience function for single-device scenarios.</p> <p>Returns:</p> Type Description <code>DetectedDevice</code> <p>First detected device</p> <p>Raises:</p> Type Description <code>DeviceNotFoundError</code> <p>If no Samsung devices are connected in download mode</p> Source code in <code>device\\detector.py</code> Python<pre><code>def get_first_device() -&gt; DetectedDevice:\n    \"\"\"Get the first detected Samsung device in download mode.\n\n    Convenience function for single-device scenarios.\n\n    Returns:\n        First detected device\n\n    Raises:\n        DeviceNotFoundError: If no Samsung devices are connected in download mode\n    \"\"\"\n    devices = detect_download_mode_devices()\n    if not devices:\n        raise DeviceNotFoundError(\n            \"No Samsung devices in download mode detected. \"\n            \"Ensure device is connected in download mode (Odin mode) \"\n            \"and Samsung USB drivers are installed (Windows). \"\n            \"To enter download mode: Power off device, then hold Volume Down + Home + Power.\"\n        )\n    return devices[0]\n</code></pre>"},{"location":"api/device/#device.get_variant","title":"get_variant","text":"Python<pre><code>get_variant(response)\n</code></pre> <p>Extract protocol variant from LOKE response.</p> <p>The variant determines which initialization sequence to use.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>bytes</code> <p>8-byte response from LOKE_Initialize</p> required <p>Returns:</p> Type Description <code>int</code> <p>Protocol variant (2, 3, 4, or 5)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If response is invalid</p> Source code in <code>device\\protocol.py</code> Python<pre><code>def get_variant(response: bytes) -&gt; int:\n    \"\"\"Extract protocol variant from LOKE response.\n\n    The variant determines which initialization sequence to use.\n\n    Args:\n        response: 8-byte response from LOKE_Initialize\n\n    Returns:\n        Protocol variant (2, 3, 4, or 5)\n\n    Raises:\n        ValueError: If response is invalid\n    \"\"\"\n    if len(response) &lt; 8:\n        raise ValueError(f\"Invalid response length: {len(response)}\")\n\n    # Variant is in bits 16-31 of second dword\n    value = struct.unpack_from(\"&lt;I\", response, 4)[0]\n    variant = (value &amp; 0xFFFF0000) &gt;&gt; 16\n    return variant\n</code></pre>"},{"location":"api/device/#device.parse_dvif_response","title":"parse_dvif_response","text":"Python<pre><code>parse_dvif_response(response)\n</code></pre> <p>Parse DVIF response into OdinDeviceInfo.</p> <p>The response format is: @key1=value1;key2=value2;...#</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>Raw DVIF response string</p> required <p>Returns:</p> Type Description <code>OdinDeviceInfo</code> <p>Parsed device information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If response format is invalid</p> Source code in <code>device\\protocol.py</code> Python<pre><code>def parse_dvif_response(response: str) -&gt; OdinDeviceInfo:\n    \"\"\"Parse DVIF response into OdinDeviceInfo.\n\n    The response format is: @key1=value1;key2=value2;...#\n\n    Args:\n        response: Raw DVIF response string\n\n    Returns:\n        Parsed device information\n\n    Raises:\n        ValueError: If response format is invalid\n    \"\"\"\n    # Remove @ and # markers\n    cleaned = response.replace(\"#\", \"\").replace(\"@\", \"\")\n\n    if not cleaned:\n        raise ValueError(\"Empty DVIF response\")\n\n    # Parse key=value pairs\n    data = {}\n    for pair in cleaned.split(\";\"):\n        pair = pair.strip()\n        if not pair or \"=\" not in pair:\n            continue\n\n        key, value = pair.split(\"=\", 1)\n        key = key.strip().lower()\n        value = value.strip()\n\n        if key and value:\n            data[key] = value\n\n    return OdinDeviceInfo(\n        capa=data.get(\"capa\"),\n        product=data.get(\"product\"),\n        model=data.get(\"model\"),\n        fwver=data.get(\"fwver\"),\n        vendor=data.get(\"vendor\"),\n        sales=data.get(\"sales\"),\n        ver=data.get(\"ver\"),\n        did=data.get(\"did\"),\n        un=data.get(\"un\"),\n        tmu_temp=data.get(\"tmu_temp\"),\n        prov=data.get(\"prov\"),\n        raw_response=response,\n    )\n</code></pre>"},{"location":"api/device/#device.is_odin_mode","title":"is_odin_mode","text":"Python<pre><code>is_odin_mode(port_name, *, timeout=2.0)\n</code></pre> <p>Check if device is in Odin download mode.</p> <p>Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)</p> required <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if device responds with LOKE, False otherwise</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails</p> Source code in <code>device\\reader.py</code> Python<pre><code>def is_odin_mode(\n    port_name: str,\n    *,\n    timeout: float = 2.0,\n) -&gt; bool:\n    \"\"\"Check if device is in Odin download mode.\n\n    Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)\n        timeout: Read timeout in seconds\n\n    Returns:\n        True if device responds with LOKE, False otherwise\n\n    Raises:\n        DeviceReadError: If serial communication fails\n    \"\"\"\n    try:\n        with serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,  # RTS/CTS hardware flow control\n        ) as port:\n            # Clear input buffer\n            port.reset_input_buffer()\n\n            # Send ODIN command\n            port.write(ODIN_COMMAND)\n            time.sleep(0.4)  # Wait for response\n\n            # Read response\n            bytes_waiting = port.in_waiting\n            if bytes_waiting &gt; 0:\n                response = port.read(bytes_waiting)\n                return LOKE_RESPONSE in response\n            return False\n\n    except serial.SerialException as ex:\n        raise DeviceReadError(\n            f\"Serial communication error on {port_name}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n</code></pre>"},{"location":"api/device/#device.read_device_info","title":"read_device_info","text":"Python<pre><code>read_device_info(\n    port_name=None, *, timeout=2.0, port_instance=None\n)\n</code></pre> <p>Read device information from Samsung device in download mode.</p> <p>Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode and parses the response.</p> <p>The device must be in download mode (Odin mode) for this to work. To enter download mode: Power off device, then hold Volume Down + Home + Power.</p> <p>IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened port via port_instance to keep the connection alive between operations.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>Optional[str]</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux). If None, auto-detects first device in download mode. Ignored if port_instance provided.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <code>port_instance</code> <code>Optional[Serial]</code> <p>Optional pre-opened serial port. If provided, port will NOT be closed.</p> <code>None</code> <p>Returns:</p> Type Description <code>OdinDeviceInfo</code> <p>Device information from Odin protocol</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails or device not in Odin mode</p> <code>ValueError</code> <p>If response cannot be parsed</p> <code>DeviceNotFoundError</code> <p>If auto-detection fails</p> Source code in <code>device\\reader.py</code> Python<pre><code>def read_device_info(\n    port_name: Optional[str] = None,\n    *,\n    timeout: float = 2.0,\n    port_instance: Optional[serial.Serial] = None,\n) -&gt; OdinDeviceInfo:\n    \"\"\"Read device information from Samsung device in download mode.\n\n    Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode\n    and parses the response.\n\n    The device must be in download mode (Odin mode) for this to work.\n    To enter download mode: Power off device, then hold Volume Down + Home + Power.\n\n    IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened\n    port via port_instance to keep the connection alive between operations.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux).\n            If None, auto-detects first device in download mode. Ignored if port_instance provided.\n        timeout: Read timeout in seconds\n        port_instance: Optional pre-opened serial port. If provided, port will NOT be closed.\n\n    Returns:\n        Device information from Odin protocol\n\n    Raises:\n        DeviceReadError: If serial communication fails or device not in Odin mode\n        ValueError: If response cannot be parsed\n        DeviceNotFoundError: If auto-detection fails\n    \"\"\"\n    # Use provided port or auto-detect/open new one\n    if port_instance is not None:\n        port = port_instance\n        should_close = False\n    else:\n        # Auto-detect device if port not specified\n        if port_name is None:\n            device = get_first_device()\n            port_name = device.port_name\n\n        port = serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,\n        )\n        # Disable DTR and RTS after opening (may reset device if done before)\n        port.dtr = False\n        port.rts = False\n        should_close = True\n\n    try:\n        # Clear input buffer\n        port.reset_input_buffer()\n\n        # Send DVIF command\n        port.write(DVIF_COMMAND)\n        time.sleep(0.4)  # Wait for device response\n\n        # Read response\n        bytes_waiting = port.in_waiting\n        if bytes_waiting &gt; 0:\n            raw_response = port.read(bytes_waiting)\n            response = raw_response.decode(\"utf-8\", errors=\"replace\")\n        else:\n            response = \"\"\n\n        if not response:\n            port_desc = port_name if port_name else port.port\n            raise DeviceReadError(\n                f\"No response from device on {port_desc}. \"\n                \"Ensure device is in download mode (Odin mode). \"\n                \"To enter download mode: Power off device, \"\n                \"then hold Volume Down + Home + Power.\"\n            )\n\n        # Parse DVIF response\n        return parse_dvif_response(response)\n\n    except serial.SerialException as ex:\n        port_desc = port_name if port_name else port.port\n        raise DeviceReadError(\n            f\"Serial communication error on {port_desc}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n    finally:\n        # Only close if we created the port\n        if should_close and port.is_open:\n            port.close()\n</code></pre>"},{"location":"api/device/#device.read_device_info_at","title":"read_device_info_at","text":"Python<pre><code>read_device_info_at(port_name=None, *, timeout=2.0)\n</code></pre> <p>Read device information from Samsung device using AT commands.</p> <p>Sends AT+DEVCONINFO command to device and parses the response.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>Optional[str]</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux). If None, auto-detects first device.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ATDeviceInfo</code> <p>Device information from AT command response</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails or AT command returns no data</p> <code>DeviceNotFoundError</code> <p>If auto-detection fails</p> Source code in <code>device\\reader_at.py</code> Python<pre><code>def read_device_info_at(\n    port_name: Optional[str] = None,\n    *,\n    timeout: float = 2.0,\n) -&gt; ATDeviceInfo:\n    \"\"\"Read device information from Samsung device using AT commands.\n\n    Sends AT+DEVCONINFO command to device and parses the response.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux).\n            If None, auto-detects first device.\n        timeout: Read timeout in seconds\n\n    Returns:\n        Device information from AT command response\n\n    Raises:\n        DeviceReadError: If serial communication fails or AT command returns no data\n        DeviceNotFoundError: If auto-detection fails\n    \"\"\"\n    # Auto-detect device if port not specified\n    if port_name is None:\n        device = get_first_device()\n        port_name = device.port_name\n\n    try:\n        with serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n        ) as port:\n            # Clear buffers\n            port.reset_input_buffer()\n            port.reset_output_buffer()\n\n            # Send AT command to get device info\n            command = b\"AT+DEVCONINFO\\r\\n\"\n            port.write(command)\n            time.sleep(0.3)  # Wait for response\n\n            # Read response\n            response = \"\"\n            while port.in_waiting &gt; 0:\n                chunk = port.read(port.in_waiting)\n                response += chunk.decode(\"utf-8\", errors=\"replace\")\n                time.sleep(0.1)\n\n            if not response or \"OK\" not in response:\n                raise DeviceReadError(\n                    f\"No valid AT response from device on {port_name}. \"\n                    \"Device may not support AT commands or is in wrong mode.\"\n                )\n\n            # Parse response\n            return _parse_at_response(response, port_name)\n\n    except serial.SerialException as ex:\n        raise DeviceReadError(\n            f\"Serial communication error on {port_name}: {ex}. \"\n            \"Verify device is connected and drivers are installed.\"\n        ) from ex\n</code></pre>"},{"location":"api/device.models/","title":"Device Models","text":"<p>Data models for Samsung device information.</p> <p>This module defines the data structures for device information.</p> <p>.. deprecated::     DeviceInfo (AT command format) is deprecated. The package now uses     Odin download mode protocol. Use OdinDeviceInfo from device.protocol instead.</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.models/#device.models.DeviceInfo","title":"DeviceInfo  <code>dataclass</code>","text":"<p>Samsung device information (DEPRECATED - kept for backward compatibility).</p> <p>.. deprecated::     This class was used with AT commands for MTP mode devices.     The package now uses Odin download mode protocol.     Use OdinDeviceInfo from device.protocol instead.</p> <p>All fields are extracted from the AT+DEVCONINFO response which follows the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product); SN(serial);IMEI(imei);UN(un).</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Device model code (e.g., SM-G991B)</p> <code>device_name</code> <code>str</code> <p>Device marketing name (typically same as model)</p> <code>pda_version</code> <code>str</code> <p>PDA firmware version</p> <code>csc_version</code> <code>str</code> <p>CSC (Country Specific Code) version</p> <code>modem_version</code> <code>str</code> <p>Modem/baseband firmware version</p> <code>region</code> <code>str</code> <p>3-character CSC region code</p> <code>serial_number</code> <code>str</code> <p>Device serial number</p> <code>imei</code> <code>str</code> <p>International Mobile Equipment Identity</p> <code>unique_number</code> <code>str</code> <p>Samsung unique number (UN)</p> Source code in <code>device\\models.py</code> Python<pre><code>@dataclass(frozen=True)\nclass DeviceInfo:\n    \"\"\"Samsung device information (DEPRECATED - kept for backward compatibility).\n\n    .. deprecated::\n        This class was used with AT commands for MTP mode devices.\n        The package now uses Odin download mode protocol.\n        Use OdinDeviceInfo from device.protocol instead.\n\n    All fields are extracted from the AT+DEVCONINFO response which follows\n    the pattern: MN(model);BASE(base);VER(pda/csc/modem/etc);PRD(product);\n    SN(serial);IMEI(imei);UN(un).\n\n    Attributes:\n        model: Device model code (e.g., SM-G991B)\n        device_name: Device marketing name (typically same as model)\n        pda_version: PDA firmware version\n        csc_version: CSC (Country Specific Code) version\n        modem_version: Modem/baseband firmware version\n        region: 3-character CSC region code\n        serial_number: Device serial number\n        imei: International Mobile Equipment Identity\n        unique_number: Samsung unique number (UN)\n    \"\"\"\n\n    model: str\n    device_name: str\n    pda_version: str\n    csc_version: str\n    modem_version: str\n    region: str\n    serial_number: str\n    imei: str\n    unique_number: str\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return human-readable device information.\"\"\"\n        return (\n            f\"{self.model} ({self.device_name})\\n\"\n            f\"  PDA: {self.pda_version}\\n\"\n            f\"  CSC: {self.csc_version} ({self.region})\\n\"\n            f\"  Modem: {self.modem_version}\\n\"\n            f\"  IMEI: {self.imei}\\n\"\n            f\"  S/N: {self.serial_number}\\n\"\n            f\"  UN: {self.unique_number}\"\n        )\n</code></pre>"},{"location":"api/device.reader/","title":"Device Reader","text":"<p>Read device information via Odin protocol over serial port.</p> <p>This module communicates with Samsung devices in download mode (Odin mode) using the DVIF (0x44,0x56,0x49,0x46) byte protocol to retrieve firmware version, model, and device info.</p> <p>Based on SharpOdinClient implementation by Gsm Alphabet.</p> <p>Protocol: Odin/LOKE binary protocol Requires: pyserial, Samsung USB drivers (Windows), device in download mode</p> <p>Copyright (c) 2024 nanosamfw contributors SPDX-License-Identifier: MIT</p>"},{"location":"api/device.reader/#device.reader.is_odin_mode","title":"is_odin_mode","text":"Python<pre><code>is_odin_mode(port_name, *, timeout=2.0)\n</code></pre> <p>Check if device is in Odin download mode.</p> <p>Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)</p> required <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if device responds with LOKE, False otherwise</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails</p> Source code in <code>device\\reader.py</code> Python<pre><code>def is_odin_mode(\n    port_name: str,\n    *,\n    timeout: float = 2.0,\n) -&gt; bool:\n    \"\"\"Check if device is in Odin download mode.\n\n    Sends ODIN command (0x4F,0x44,0x49,0x4E) and checks for LOKE response.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux)\n        timeout: Read timeout in seconds\n\n    Returns:\n        True if device responds with LOKE, False otherwise\n\n    Raises:\n        DeviceReadError: If serial communication fails\n    \"\"\"\n    try:\n        with serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,  # RTS/CTS hardware flow control\n        ) as port:\n            # Clear input buffer\n            port.reset_input_buffer()\n\n            # Send ODIN command\n            port.write(ODIN_COMMAND)\n            time.sleep(0.4)  # Wait for response\n\n            # Read response\n            bytes_waiting = port.in_waiting\n            if bytes_waiting &gt; 0:\n                response = port.read(bytes_waiting)\n                return LOKE_RESPONSE in response\n            return False\n\n    except serial.SerialException as ex:\n        raise DeviceReadError(\n            f\"Serial communication error on {port_name}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n</code></pre>"},{"location":"api/device.reader/#device.reader.read_device_info","title":"read_device_info","text":"Python<pre><code>read_device_info(\n    port_name=None, *, timeout=2.0, port_instance=None\n)\n</code></pre> <p>Read device information from Samsung device in download mode.</p> <p>Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode and parses the response.</p> <p>The device must be in download mode (Odin mode) for this to work. To enter download mode: Power off device, then hold Volume Down + Home + Power.</p> <p>IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened port via port_instance to keep the connection alive between operations.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>Optional[str]</code> <p>Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux). If None, auto-detects first device in download mode. Ignored if port_instance provided.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds</p> <code>2.0</code> <code>port_instance</code> <code>Optional[Serial]</code> <p>Optional pre-opened serial port. If provided, port will NOT be closed.</p> <code>None</code> <p>Returns:</p> Type Description <code>OdinDeviceInfo</code> <p>Device information from Odin protocol</p> <p>Raises:</p> Type Description <code>DeviceReadError</code> <p>If serial communication fails or device not in Odin mode</p> <code>ValueError</code> <p>If response cannot be parsed</p> <code>DeviceNotFoundError</code> <p>If auto-detection fails</p> Source code in <code>device\\reader.py</code> Python<pre><code>def read_device_info(\n    port_name: Optional[str] = None,\n    *,\n    timeout: float = 2.0,\n    port_instance: Optional[serial.Serial] = None,\n) -&gt; OdinDeviceInfo:\n    \"\"\"Read device information from Samsung device in download mode.\n\n    Sends DVIF command (0x44,0x56,0x49,0x46) to device in Odin mode\n    and parses the response.\n\n    The device must be in download mode (Odin mode) for this to work.\n    To enter download mode: Power off device, then hold Volume Down + Home + Power.\n\n    IMPORTANT: If calling both is_odin_mode() and read_device_info(), pass an opened\n    port via port_instance to keep the connection alive between operations.\n\n    Args:\n        port_name: Serial port name (e.g., \"COM3\" on Windows, \"/dev/ttyACM0\" on Linux).\n            If None, auto-detects first device in download mode. Ignored if port_instance provided.\n        timeout: Read timeout in seconds\n        port_instance: Optional pre-opened serial port. If provided, port will NOT be closed.\n\n    Returns:\n        Device information from Odin protocol\n\n    Raises:\n        DeviceReadError: If serial communication fails or device not in Odin mode\n        ValueError: If response cannot be parsed\n        DeviceNotFoundError: If auto-detection fails\n    \"\"\"\n    # Use provided port or auto-detect/open new one\n    if port_instance is not None:\n        port = port_instance\n        should_close = False\n    else:\n        # Auto-detect device if port not specified\n        if port_name is None:\n            device = get_first_device()\n            port_name = device.port_name\n\n        port = serial.Serial(\n            port=port_name,\n            baudrate=115200,\n            bytesize=serial.EIGHTBITS,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            timeout=timeout,\n            rtscts=True,\n        )\n        # Disable DTR and RTS after opening (may reset device if done before)\n        port.dtr = False\n        port.rts = False\n        should_close = True\n\n    try:\n        # Clear input buffer\n        port.reset_input_buffer()\n\n        # Send DVIF command\n        port.write(DVIF_COMMAND)\n        time.sleep(0.4)  # Wait for device response\n\n        # Read response\n        bytes_waiting = port.in_waiting\n        if bytes_waiting &gt; 0:\n            raw_response = port.read(bytes_waiting)\n            response = raw_response.decode(\"utf-8\", errors=\"replace\")\n        else:\n            response = \"\"\n\n        if not response:\n            port_desc = port_name if port_name else port.port\n            raise DeviceReadError(\n                f\"No response from device on {port_desc}. \"\n                \"Ensure device is in download mode (Odin mode). \"\n                \"To enter download mode: Power off device, \"\n                \"then hold Volume Down + Home + Power.\"\n            )\n\n        # Parse DVIF response\n        return parse_dvif_response(response)\n\n    except serial.SerialException as ex:\n        port_desc = port_name if port_name else port.port\n        raise DeviceReadError(\n            f\"Serial communication error on {port_desc}: {ex}. \"\n            \"Verify device is in download mode and Samsung USB drivers are installed.\"\n        ) from ex\n    finally:\n        # Only close if we created the port\n        if should_close and port.is_open:\n            port.close()\n</code></pre>"},{"location":"api/download.config/","title":"Package API <code>download.config</code>","text":""},{"location":"api/download.config/#download.config","title":"download.config","text":"<p>Download module configuration.</p> <p>This module provides configuration for download paths and directories used throughout the download module.</p>"},{"location":"api/download.config/#download.config.PATHS","title":"PATHS  <code>module-attribute</code>","text":"Python<pre><code>PATHS = _resolve_paths()\n</code></pre> <p>Global paths configuration instance.</p> <p>This constant provides access to all configured paths used by the download module.</p>"},{"location":"api/download.config/#download.config.Paths","title":"Paths  <code>dataclass</code>","text":"<p>Configuration paths for download operations.</p> <p>This dataclass holds all filesystem paths used by the download module, including the data directory, database path, firmware repository, and decrypted firmware output directory.</p> <p>Attributes:</p> Name Type Description <code>data_dir</code> <code>Path</code> <p>Root directory for application data storage.</p> <code>db_path</code> <code>Path</code> <p>Path to the SQLite database file.</p> <code>firmware_dir</code> <code>Path</code> <p>Directory where encrypted firmware files (.enc4) are stored.</p> <code>decrypted_dir</code> <code>Path</code> <p>Directory where decrypted firmware files are stored.</p> Source code in <code>download\\config.py</code> Python<pre><code>@dataclass(frozen=True)\nclass Paths:\n    \"\"\"Configuration paths for download operations.\n\n    This dataclass holds all filesystem paths used by the download module,\n    including the data directory, database path, firmware repository, and\n    decrypted firmware output directory.\n\n    Attributes:\n        data_dir: Root directory for application data storage.\n        db_path: Path to the SQLite database file.\n        firmware_dir: Directory where encrypted firmware files (.enc4) are stored.\n        decrypted_dir: Directory where decrypted firmware files are stored.\n    \"\"\"\n\n    data_dir: Path\n    db_path: Path\n    firmware_dir: Path\n    decrypted_dir: Path\n</code></pre>"},{"location":"api/download.db/","title":"Package API <code>download.db</code>","text":""},{"location":"api/download.db/#download.db","title":"download.db","text":"<p>Database connection and schema management.</p> <p>This module provides database connection utilities, schema initialization, and database health/repair operations for the firmware download system.</p>"},{"location":"api/download.db/#download.db.get_db_path","title":"get_db_path","text":"Python<pre><code>get_db_path()\n</code></pre> <p>Get the path to the SQLite database file.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Absolute path to the database file.</p> Source code in <code>download\\db.py</code> Python<pre><code>def get_db_path() -&gt; Path:\n    \"\"\"Get the path to the SQLite database file.\n\n    Returns:\n        Path: Absolute path to the database file.\n    \"\"\"\n    return PATHS.db_path\n</code></pre>"},{"location":"api/download.db/#download.db.connect","title":"connect","text":"Python<pre><code>connect()\n</code></pre> <p>Open a SQLite connection with optimized PRAGMAs.</p> <p>Creates the data directory if it doesn't exist and establishes a database connection with WAL mode, reasonable timeouts, and other performance settings. One connection per thread/process is recommended.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>sqlite3.Connection: Configured database connection with Row factory enabled.</p> Note <p>The connection uses autocommit mode (isolation_level=None), so transactions must be managed explicitly with BEGIN/COMMIT/ROLLBACK.</p> Source code in <code>download\\db.py</code> Python<pre><code>def connect() -&gt; sqlite3.Connection:\n    \"\"\"Open a SQLite connection with optimized PRAGMAs.\n\n    Creates the data directory if it doesn't exist and establishes a database\n    connection with WAL mode, reasonable timeouts, and other performance settings.\n    One connection per thread/process is recommended.\n\n    Returns:\n        sqlite3.Connection: Configured database connection with Row factory enabled.\n\n    Note:\n        The connection uses autocommit mode (isolation_level=None), so transactions\n        must be managed explicitly with BEGIN/COMMIT/ROLLBACK.\n    \"\"\"\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    conn = sqlite3.connect(\n        PATHS.db_path,\n        timeout=10.0,\n        isolation_level=None,\n        check_same_thread=False,\n    )\n    conn.row_factory = sqlite3.Row\n    _apply_pragmas(conn)\n    return conn\n</code></pre>"},{"location":"api/download.db/#download.db.init_db","title":"init_db","text":"Python<pre><code>init_db()\n</code></pre> <p>Initialize the database schema.</p> <p>Creates the data directory and database tables if they don't exist. Note: executescript() implicitly commits, so no manual transaction control needed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If schema creation fails</p> Source code in <code>download\\db.py</code> Python<pre><code>def init_db() -&gt; None:\n    \"\"\"Initialize the database schema.\n\n    Creates the data directory and database tables if they don't exist.\n    Note: executescript() implicitly commits, so no manual transaction control needed.\n\n    Raises:\n        Exception: If schema creation fails\n    \"\"\"\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    with connect() as conn:\n        conn.executescript(SCHEMA_SQL)\n</code></pre>"},{"location":"api/download.db/#download.db.is_healthy","title":"is_healthy","text":"Python<pre><code>is_healthy()\n</code></pre> <p>Check database integrity.</p> <p>Runs SQLite's integrity_check pragma to verify the database is not corrupted.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if database passes integrity check, False otherwise.</p> Source code in <code>download\\db.py</code> Python<pre><code>def is_healthy() -&gt; bool:\n    \"\"\"Check database integrity.\n\n    Runs SQLite's integrity_check pragma to verify the database is not corrupted.\n\n    Returns:\n        bool: True if database passes integrity check, False otherwise.\n    \"\"\"\n    try:\n        with sqlite3.connect(PATHS.db_path) as conn:\n            cur = conn.cursor()\n            cur.execute(\"PRAGMA integrity_check(1);\")\n            row = cur.fetchone()\n            cur.close()\n            return row is not None and row[0] == \"ok\"\n    except sqlite3.DatabaseError:\n        return False\n</code></pre>"},{"location":"api/download.db/#download.db.repair_db","title":"repair_db","text":"Python<pre><code>repair_db()\n</code></pre> <p>Attempt to repair a corrupted SQLite database.</p> <p>If the database fails the integrity check, this function performs a dump to a temporary SQL file, deletes the corrupted database, and restores from the dump into a new database file.</p> The process <ol> <li>Check if database is healthy (returns immediately if healthy)</li> <li>Dump database to temporary SQL file</li> <li>Delete the corrupted database file</li> <li>Restore from the SQL dump</li> <li>Clean up temporary dump file</li> </ol> Source code in <code>download\\db.py</code> Python<pre><code>def repair_db() -&gt; None:\n    \"\"\"Attempt to repair a corrupted SQLite database.\n\n    If the database fails the integrity check, this function performs a dump\n    to a temporary SQL file, deletes the corrupted database, and restores\n    from the dump into a new database file.\n\n    The process:\n        1. Check if database is healthy (returns immediately if healthy)\n        2. Dump database to temporary SQL file\n        3. Delete the corrupted database file\n        4. Restore from the SQL dump\n        5. Clean up temporary dump file\n    \"\"\"\n    if is_healthy():\n        return\n\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    temp_dump_path = PATHS.data_dir / \"temp_dump.sql\"\n    _dump_db(temp_dump_path)\n\n    try:\n        PATHS.db_path.unlink()\n    except FileNotFoundError:\n        pass\n\n    _restore_db(temp_dump_path)\n\n    try:\n        temp_dump_path.unlink()\n    except FileNotFoundError:\n        pass\n</code></pre>"},{"location":"api/download.firmware_repository/","title":"Firmware Repository","text":""},{"location":"api/download.firmware_repository/#download.firmware_repository","title":"download.firmware_repository","text":"<p>Repository layer for firmware management.</p> <p>This module provides the data access layer for managing firmware files in the repository database using the repository pattern.</p>"},{"location":"api/download.firmware_repository/#download.firmware_repository.FirmwareRecord","title":"FirmwareRecord  <code>dataclass</code>","text":"<p>Firmware repository record.</p> <p>Represents a firmware entry with all metadata from FUS inform response and local file paths.</p> <p>Attributes:</p> Name Type Description <code>version_code</code> <code>str</code> <p>Firmware version identifier (format: AAA/BBB/CCC/DDD).</p> <code>filename</code> <code>str</code> <p>Binary firmware filename from FUS server.</p> <code>path</code> <code>str</code> <p>Server model path from FUS inform response.</p> <code>size_bytes</code> <code>int</code> <p>File size in bytes.</p> <code>logic_value_factory</code> <code>str</code> <p>Logic value for ENC4 decryption key derivation.</p> <code>latest_fw_version</code> <code>str</code> <p>Latest firmware version from inform response.</p> <code>encrypted_file_path</code> <code>str</code> <p>Absolute path to encrypted (.enc4) file on disk.</p> <code>decrypted_file_path</code> <code>str | None</code> <p>Absolute path to decrypted file, or None if not decrypted.</p> Source code in <code>download\\firmware_repository.py</code> Python<pre><code>@dataclass\nclass FirmwareRecord:\n    \"\"\"Firmware repository record.\n\n    Represents a firmware entry with all metadata from FUS inform response\n    and local file paths.\n\n    Attributes:\n        version_code: Firmware version identifier (format: AAA/BBB/CCC/DDD).\n        filename: Binary firmware filename from FUS server.\n        path: Server model path from FUS inform response.\n        size_bytes: File size in bytes.\n        logic_value_factory: Logic value for ENC4 decryption key derivation.\n        latest_fw_version: Latest firmware version from inform response.\n        encrypted_file_path: Absolute path to encrypted (.enc4) file on disk.\n        decrypted_file_path: Absolute path to decrypted file, or None if not decrypted.\n    \"\"\"\n\n    version_code: str\n    filename: str\n    path: str\n    size_bytes: int\n    logic_value_factory: str\n    latest_fw_version: str\n    encrypted_file_path: str\n    decrypted_file_path: str | None\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.upsert_firmware","title":"upsert_firmware","text":"Python<pre><code>upsert_firmware(rec)\n</code></pre> <p>Insert or update a firmware record.</p> <p>Creates a new firmware record or updates an existing one if a record with the same version_code already exists. The operation is performed within a transaction.</p> <p>Parameters:</p> Name Type Description Default <code>rec</code> <code>FirmwareRecord</code> <p>Firmware record to insert or update.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the database operation fails, the exception is re-raised after rolling back the transaction.</p> Source code in <code>download\\firmware_repository.py</code> Python<pre><code>def upsert_firmware(rec: FirmwareRecord) -&gt; None:\n    \"\"\"Insert or update a firmware record.\n\n    Creates a new firmware record or updates an existing one if a record with\n    the same version_code already exists. The operation is performed within\n    a transaction.\n\n    Args:\n        rec: Firmware record to insert or update.\n\n    Raises:\n        Exception: If the database operation fails, the exception is re-raised\n            after rolling back the transaction.\n    \"\"\"\n    sql = \"\"\"\n    INSERT INTO firmware (version_code, filename, path, size_bytes,\n                          logic_value_factory, latest_fw_version,\n                          encrypted_file_path, decrypted_file_path)\n    VALUES (:version_code, :filename, :path, :size_bytes,\n            :logic_value_factory, :latest_fw_version,\n            :encrypted_file_path, :decrypted_file_path)\n    ON CONFLICT(version_code) DO UPDATE SET\n        filename=excluded.filename,\n        path=excluded.path,\n        size_bytes=excluded.size_bytes,\n        logic_value_factory=excluded.logic_value_factory,\n        latest_fw_version=excluded.latest_fw_version,\n        encrypted_file_path=excluded.encrypted_file_path,\n        decrypted_file_path=excluded.decrypted_file_path;\n    \"\"\"\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.execute(sql, rec.__dict__)\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.find_firmware","title":"find_firmware","text":"Python<pre><code>find_firmware(version_code)\n</code></pre> <p>Find a specific firmware record by version code.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier to search for.</p> required <p>Returns:</p> Type Description <code>Optional[FirmwareRecord]</code> <p>FirmwareRecord if found, None otherwise.</p> Source code in <code>download\\firmware_repository.py</code> Python<pre><code>def find_firmware(version_code: str) -&gt; Optional[FirmwareRecord]:\n    \"\"\"Find a specific firmware record by version code.\n\n    Args:\n        version_code: Firmware version identifier to search for.\n\n    Returns:\n        FirmwareRecord if found, None otherwise.\n    \"\"\"\n    sql = \"\"\"\n    SELECT version_code, filename, path, size_bytes,\n           logic_value_factory, latest_fw_version,\n           encrypted_file_path, decrypted_file_path\n    FROM firmware\n    WHERE version_code=?;\n    \"\"\"\n    with connect() as conn:\n        row = conn.execute(sql, (version_code,)).fetchone()\n        if not row:\n            return None\n        return FirmwareRecord(\n            version_code=row[0],\n            filename=row[1],\n            path=row[2],\n            size_bytes=row[3],\n            logic_value_factory=row[4],\n            latest_fw_version=row[5],\n            encrypted_file_path=row[6],\n            decrypted_file_path=row[7],\n        )\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.list_firmware","title":"list_firmware","text":"Python<pre><code>list_firmware(limit=None)\n</code></pre> <p>List all firmware records.</p> <p>Yields firmware records ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to return, or None for all.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>FirmwareRecord</code> <code>Iterable[FirmwareRecord]</code> <p>Each firmware entry in the repository.</p> Source code in <code>download\\firmware_repository.py</code> Python<pre><code>def list_firmware(limit: Optional[int] = None) -&gt; Iterable[FirmwareRecord]:\n    \"\"\"List all firmware records.\n\n    Yields firmware records ordered by creation date (newest first).\n\n    Args:\n        limit: Maximum number of records to return, or None for all.\n\n    Yields:\n        FirmwareRecord: Each firmware entry in the repository.\n    \"\"\"\n    sql = \"\"\"\n    SELECT version_code, filename, path, size_bytes,\n           logic_value_factory, latest_fw_version,\n           encrypted_file_path, decrypted_file_path\n    FROM firmware\n    ORDER BY created_at DESC\n    \"\"\"\n    if limit:\n        sql += f\" LIMIT {int(limit)}\"\n    sql += \";\"\n\n    with connect() as conn:\n        for row in conn.execute(sql):\n            yield FirmwareRecord(\n                version_code=row[0],\n                filename=row[1],\n                path=row[2],\n                size_bytes=row[3],\n                logic_value_factory=row[4],\n                latest_fw_version=row[5],\n                encrypted_file_path=row[6],\n                decrypted_file_path=row[7],\n            )\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.update_decrypted_path","title":"update_decrypted_path","text":"Python<pre><code>update_decrypted_path(version_code, decrypted_path)\n</code></pre> <p>Update the decrypted file path for a firmware record.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier.</p> required <code>decrypted_path</code> <code>str</code> <p>Absolute path to the decrypted file.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the database operation fails.</p> Source code in <code>download\\firmware_repository.py</code> Python<pre><code>def update_decrypted_path(version_code: str, decrypted_path: str) -&gt; None:\n    \"\"\"Update the decrypted file path for a firmware record.\n\n    Args:\n        version_code: Firmware version identifier.\n        decrypted_path: Absolute path to the decrypted file.\n\n    Raises:\n        Exception: If the database operation fails.\n    \"\"\"\n    sql = \"\"\"\n    UPDATE firmware\n    SET decrypted_file_path=?\n    WHERE version_code=?;\n    \"\"\"\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.execute(sql, (decrypted_path, version_code))\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.firmware_repository/#download.firmware_repository.delete_firmware","title":"delete_firmware","text":"Python<pre><code>delete_firmware(version_code)\n</code></pre> <p>Delete a firmware record by version code.</p> <p>Removes the firmware row from the repository. This does not delete any files on disk; callers should remove associated files before invoking.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier to delete.</p> required Source code in <code>download\\firmware_repository.py</code> Python<pre><code>def delete_firmware(version_code: str) -&gt; None:\n    \"\"\"Delete a firmware record by version code.\n\n    Removes the firmware row from the repository. This does not delete any\n    files on disk; callers should remove associated files before invoking.\n\n    Args:\n        version_code: Firmware version identifier to delete.\n    \"\"\"\n    sql = \"DELETE FROM firmware WHERE version_code=?;\"\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.execute(sql, (version_code,))\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.imei_repository/","title":"Package API <code>download.imei_repository</code>","text":""},{"location":"api/download.imei_repository/#download.imei_repository","title":"download.imei_repository","text":"<p>Repository layer for IMEI event logging.</p> <p>This module provides data access functions for tracking IMEI-based firmware queries and upgrade operations. Events are logged with FUS status and upgrade status for traceability.</p>"},{"location":"api/download.imei_repository/#download.imei_repository.IMEIEvent","title":"IMEIEvent  <code>dataclass</code>","text":"<p>IMEI event record.</p> <p>Represents a logged IMEI-based firmware query or upgrade operation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Database record ID, or None for new records.</p> <code>session_id</code> <code>str</code> <p>Application session identifier (changes per app launch).</p> <code>imei</code> <code>str</code> <p>Device IMEI number.</p> <code>model</code> <code>str</code> <p>Device model identifier.</p> <code>csc</code> <code>str</code> <p>Country Specific Code.</p> <code>version_code</code> <code>str</code> <p>Firmware version identifier (format: AAA/BBB/CCC/DDD).</p> <code>status_fus</code> <code>str</code> <p>FUS query status (ok, error, denied, unauthorized, throttled, unknown).</p> <code>status_upgrade</code> <code>str</code> <p>Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown).</p> <code>created_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of event creation, or None.</p> <code>updated_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of last update, or None.</p> <code>upgrade_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of upgrade operation, or None.</p> Source code in <code>download\\imei_repository.py</code> Python<pre><code>@dataclass\nclass IMEIEvent:\n    \"\"\"IMEI event record.\n\n    Represents a logged IMEI-based firmware query or upgrade operation.\n\n    Attributes:\n        id: Database record ID, or None for new records.\n        session_id: Application session identifier (changes per app launch).\n        imei: Device IMEI number.\n        model: Device model identifier.\n        csc: Country Specific Code.\n        version_code: Firmware version identifier (format: AAA/BBB/CCC/DDD).\n        status_fus: FUS query status (ok, error, denied, unauthorized, throttled, unknown).\n        status_upgrade: Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown).\n        created_at: ISO 8601 UTC timestamp of event creation, or None.\n        updated_at: ISO 8601 UTC timestamp of last update, or None.\n        upgrade_at: ISO 8601 UTC timestamp of upgrade operation, or None.\n    \"\"\"\n\n    id: int | None\n    session_id: str\n    imei: str\n    model: str\n    csc: str\n    version_code: str\n    status_fus: str = \"unknown\"  # ok/error/denied/unauthorized/throttled/unknown\n    status_upgrade: str = \"unknown\"  # queued/in_progress/ok/failed/skipped/unknown\n    created_at: str | None = None  # ISO-8601 UTC\n    updated_at: str | None = None  # ISO-8601 UTC\n    upgrade_at: str | None = None  # ISO-8601 UTC\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.upsert_imei_event","title":"upsert_imei_event","text":"Python<pre><code>upsert_imei_event(\n    *,\n    session_id,\n    imei,\n    model,\n    csc,\n    version_code,\n    status_fus=\"unknown\",\n    status_upgrade=\"unknown\",\n    upgrade_at=None\n)\n</code></pre> <p>Insert or update IMEI event record for current session.</p> <p>Creates a new IMEI event log entry, or updates the existing one if a record with the same session_id and imei already exists. This ensures one record per device per application session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Application session identifier (generated at app launch).</p> required <code>imei</code> <code>str</code> <p>Device IMEI number.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>version_code</code> <code>str</code> <p>Firmware version identifier (format: AAA/BBB/CCC/DDD).</p> required <code>status_fus</code> <code>str</code> <p>FUS query status. Defaults to \"unknown\".</p> <code>'unknown'</code> <code>status_upgrade</code> <code>str</code> <p>Upgrade operation status. Defaults to \"unknown\".</p> <code>'unknown'</code> <code>upgrade_at</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp of upgrade operation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Database ID of the inserted or updated record.</p> Source code in <code>download\\imei_repository.py</code> Python<pre><code>def upsert_imei_event(\n    *,\n    session_id: str,\n    imei: str,\n    model: str,\n    csc: str,\n    version_code: str,\n    status_fus: str = \"unknown\",\n    status_upgrade: str = \"unknown\",\n    upgrade_at: str | None = None,\n) -&gt; int:\n    \"\"\"Insert or update IMEI event record for current session.\n\n    Creates a new IMEI event log entry, or updates the existing one if a record\n    with the same session_id and imei already exists. This ensures one record\n    per device per application session.\n\n    Args:\n        session_id: Application session identifier (generated at app launch).\n        imei: Device IMEI number.\n        model: Device model identifier.\n        csc: Country Specific Code.\n        version_code: Firmware version identifier (format: AAA/BBB/CCC/DDD).\n        status_fus: FUS query status. Defaults to \"unknown\".\n        status_upgrade: Upgrade operation status. Defaults to \"unknown\".\n        upgrade_at: Optional ISO 8601 UTC timestamp of upgrade operation.\n\n    Returns:\n        int: Database ID of the inserted or updated record.\n    \"\"\"\n    sql = \"\"\"\n    INSERT INTO imei_log\n        (session_id, imei, model, csc, version_code, status_fus, status_upgrade, created_at, updated_at, upgrade_at)\n    VALUES\n        (:session_id, :imei, :model, :csc, :version_code, :status_fus, :status_upgrade, :created_at, :updated_at, :upgrade_at)\n    ON CONFLICT(session_id, imei) DO UPDATE SET\n        model=excluded.model,\n        csc=excluded.csc,\n        version_code=excluded.version_code,\n        status_fus=excluded.status_fus,\n        status_upgrade=excluded.status_upgrade,\n        updated_at=excluded.updated_at,\n        upgrade_at=excluded.upgrade_at;\n    \"\"\"\n    now = _iso_now()\n    params = {\n        \"session_id\": session_id,\n        \"imei\": imei,\n        \"model\": model,\n        \"csc\": csc,\n        \"version_code\": version_code,\n        \"status_fus\": status_fus,\n        \"status_upgrade\": status_upgrade,\n        \"created_at\": now,\n        \"updated_at\": now,\n        \"upgrade_at\": upgrade_at,\n    }\n    with connect() as conn:\n        cur = conn.execute(sql, params)\n        return int(cur.lastrowid)  # type: ignore\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.add_imei_event","title":"add_imei_event","text":"Python<pre><code>add_imei_event(\n    *,\n    imei,\n    model,\n    csc,\n    version_code,\n    status_fus=\"unknown\",\n    status_upgrade=\"unknown\",\n    upgrade_at=None,\n    session_id=\"legacy\"\n)\n</code></pre> <p>Legacy function - use upsert_imei_event instead.</p> <p>Kept for backward compatibility. New code should use upsert_imei_event.</p> Source code in <code>download\\imei_repository.py</code> Python<pre><code>def add_imei_event(\n    *,\n    imei: str,\n    model: str,\n    csc: str,\n    version_code: str,\n    status_fus: str = \"unknown\",\n    status_upgrade: str = \"unknown\",\n    upgrade_at: str | None = None,\n    session_id: str = \"legacy\",\n) -&gt; int:\n    \"\"\"Legacy function - use upsert_imei_event instead.\n\n    Kept for backward compatibility. New code should use upsert_imei_event.\n    \"\"\"\n    return upsert_imei_event(\n        session_id=session_id,\n        imei=imei,\n        model=model,\n        csc=csc,\n        version_code=version_code,\n        status_fus=status_fus,\n        status_upgrade=status_upgrade,\n        upgrade_at=upgrade_at,\n    )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.set_upgrade_status","title":"set_upgrade_status","text":"Python<pre><code>set_upgrade_status(id_, status_upgrade, upgrade_at=None)\n</code></pre> <p>Update the upgrade status for an existing event.</p> <p>Updates the upgrade status and timestamp for a previously logged IMEI event.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>Database ID of the event to update.</p> required <code>status_upgrade</code> <code>str</code> <p>New upgrade status (e.g., ok, failed, skipped).</p> required <code>upgrade_at</code> <code>Optional[str]</code> <p>Optional ISO 8601 UTC timestamp. If None, current time is used.</p> <code>None</code> Source code in <code>download\\imei_repository.py</code> Python<pre><code>def set_upgrade_status(id_: int, status_upgrade: str, upgrade_at: Optional[str] = None) -&gt; None:\n    \"\"\"Update the upgrade status for an existing event.\n\n    Updates the upgrade status and timestamp for a previously logged IMEI event.\n\n    Args:\n        id_: Database ID of the event to update.\n        status_upgrade: New upgrade status (e.g., ok, failed, skipped).\n        upgrade_at: Optional ISO 8601 UTC timestamp. If None, current time is used.\n    \"\"\"\n    if upgrade_at is None:\n        upgrade_at = _iso_now()\n    sql = \"\"\"\n    UPDATE imei_log\n       SET status_upgrade = :status_upgrade,\n           upgrade_at = :upgrade_at\n     WHERE id = :id\n    \"\"\"\n    with connect() as conn:\n        conn.execute(sql, {\"status_upgrade\": status_upgrade, \"upgrade_at\": upgrade_at, \"id\": id_})\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_by_imei","title":"list_by_imei","text":"Python<pre><code>list_by_imei(imei, *, limit=200, offset=0)\n</code></pre> <p>List IMEI events for a specific IMEI number.</p> <p>Retrieves event records for a given IMEI, ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>Device IMEI number to search for.</p> required <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 200.</p> <code>200</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the IMEI, ordered by created_at descending.</p> Source code in <code>download\\imei_repository.py</code> Python<pre><code>def list_by_imei(imei: str, *, limit: int = 200, offset: int = 0) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events for a specific IMEI number.\n\n    Retrieves event records for a given IMEI, ordered by creation date (newest first).\n\n    Args:\n        imei: Device IMEI number to search for.\n        limit: Maximum number of records to return. Defaults to 200.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the IMEI, ordered by created_at descending.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE imei = ?\n     ORDER BY created_at DESC\n     LIMIT ? OFFSET ?;\n    \"\"\"\n    with connect() as conn:\n        for row in conn.execute(sql, (imei, limit, offset)):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                session_id=row[\"session_id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_by_model_csc","title":"list_by_model_csc","text":"Python<pre><code>list_by_model_csc(\n    model,\n    csc,\n    *,\n    since=None,\n    until=None,\n    limit=200,\n    offset=0\n)\n</code></pre> <p>List IMEI events for a specific model and CSC combination.</p> <p>Retrieves event records filtered by model and CSC, with optional date range filtering. Results are ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum created_at filter.</p> <code>None</code> <code>until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum created_at filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 200.</p> <code>200</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the filters, ordered by created_at descending.</p> Source code in <code>download\\imei_repository.py</code> Python<pre><code>def list_by_model_csc(\n    model: str,\n    csc: str,\n    *,\n    since: str | None = None,\n    until: str | None = None,\n    limit: int = 200,\n    offset: int = 0,\n) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events for a specific model and CSC combination.\n\n    Retrieves event records filtered by model and CSC, with optional date range\n    filtering. Results are ordered by creation date (newest first).\n\n    Args:\n        model: Device model identifier.\n        csc: Country Specific Code.\n        since: Optional ISO 8601 UTC timestamp for minimum created_at filter.\n        until: Optional ISO 8601 UTC timestamp for maximum created_at filter.\n        limit: Maximum number of records to return. Defaults to 200.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the filters, ordered by created_at descending.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE model = :model AND csc = :csc\n       AND (:since IS NULL OR created_at &gt;= :since)\n       AND (:until IS NULL OR created_at &lt;= :until)\n     ORDER BY created_at DESC\n     LIMIT :limit OFFSET :offset;\n    \"\"\"\n    with connect() as conn:\n        for row in conn.execute(\n            sql,\n            {\n                \"model\": model,\n                \"csc\": csc,\n                \"since\": since,\n                \"until\": until,\n                \"limit\": limit,\n                \"offset\": offset,\n            },\n        ):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                session_id=row[\"session_id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_between_dates","title":"list_between_dates","text":"Python<pre><code>list_between_dates(\n    *,\n    created_since=None,\n    created_until=None,\n    upgrade_since=None,\n    upgrade_until=None,\n    limit=500,\n    offset=0\n)\n</code></pre> <p>List IMEI events filtered by creation and/or upgrade date ranges.</p> <p>Retrieves event records with flexible date range filtering on both creation and upgrade timestamps. All filters are optional and can be combined.</p> <p>Parameters:</p> Name Type Description Default <code>created_since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum created_at filter.</p> <code>None</code> <code>created_until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum created_at filter.</p> <code>None</code> <code>upgrade_since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum upgrade_at filter.</p> <code>None</code> <code>upgrade_until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum upgrade_at filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 500.</p> <code>500</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the date filters, ordered by created_at descending.</p> Note <p>Upgrade date filters only match records where upgrade_at is not NULL.</p> Source code in <code>download\\imei_repository.py</code> Python<pre><code>def list_between_dates(\n    *,\n    created_since: str | None = None,\n    created_until: str | None = None,\n    upgrade_since: str | None = None,\n    upgrade_until: str | None = None,\n    limit: int = 500,\n    offset: int = 0,\n) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events filtered by creation and/or upgrade date ranges.\n\n    Retrieves event records with flexible date range filtering on both creation\n    and upgrade timestamps. All filters are optional and can be combined.\n\n    Args:\n        created_since: Optional ISO 8601 UTC timestamp for minimum created_at filter.\n        created_until: Optional ISO 8601 UTC timestamp for maximum created_at filter.\n        upgrade_since: Optional ISO 8601 UTC timestamp for minimum upgrade_at filter.\n        upgrade_until: Optional ISO 8601 UTC timestamp for maximum upgrade_at filter.\n        limit: Maximum number of records to return. Defaults to 500.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the date filters, ordered by created_at descending.\n\n    Note:\n        Upgrade date filters only match records where upgrade_at is not NULL.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE (:cs IS NULL OR created_at &gt;= :cs)\n       AND (:cu IS NULL OR created_at &lt;= :cu)\n       AND (:us IS NULL OR (upgrade_at IS NOT NULL AND upgrade_at &gt;= :us))\n       AND (:uu IS NULL OR (upgrade_at IS NOT NULL AND upgrade_at &lt;= :uu))\n     ORDER BY created_at DESC\n     LIMIT :limit OFFSET :offset;\n    \"\"\"\n    params = {\n        \"cs\": created_since,\n        \"cu\": created_until,\n        \"us\": upgrade_since,\n        \"uu\": upgrade_until,\n        \"limit\": limit,\n        \"offset\": offset,\n    }\n    with connect() as conn:\n        for row in conn.execute(sql, params):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                session_id=row[\"session_id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.last_status_by_imei","title":"last_status_by_imei","text":"Python<pre><code>last_status_by_imei(imei)\n</code></pre> <p>Get the most recent IMEI event for a specific IMEI number.</p> <p>Retrieves the latest event record (by creation date) for the given IMEI.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>Device IMEI number to search for.</p> required <p>Returns:</p> Type Description <code>IMEIEvent | None</code> <p>IMEIEvent if found, None if no events exist for this IMEI.</p> Source code in <code>download\\imei_repository.py</code> Python<pre><code>def last_status_by_imei(imei: str) -&gt; IMEIEvent | None:\n    \"\"\"Get the most recent IMEI event for a specific IMEI number.\n\n    Retrieves the latest event record (by creation date) for the given IMEI.\n\n    Args:\n        imei: Device IMEI number to search for.\n\n    Returns:\n        IMEIEvent if found, None if no events exist for this IMEI.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE imei = ?\n     ORDER BY created_at DESC\n     LIMIT 1;\n    \"\"\"\n    with connect() as conn:\n        row = conn.execute(sql, (imei,)).fetchone()\n        if not row:\n            return None\n        return IMEIEvent(\n            id=row[\"id\"],\n            session_id=row[\"session_id\"],\n            imei=row[\"imei\"],\n            model=row[\"model\"],\n            csc=row[\"csc\"],\n            version_code=row[\"version_code\"],\n            status_fus=row[\"status_fus\"],\n            status_upgrade=row[\"status_upgrade\"],\n            created_at=row[\"created_at\"],\n            updated_at=row.get(\"updated_at\", row[\"created_at\"]),\n            upgrade_at=row[\"upgrade_at\"],\n        )\n</code></pre>"},{"location":"api/download.service/","title":"Package API <code>download.service</code>","text":""},{"location":"api/download.service/#download.service","title":"download.service","text":"<p>Firmware download and management service.</p> <p>This module provides high-level firmware management functionality including FOTA version checking, firmware download with repository management, and decryption services.</p>"},{"location":"api/download.service/#download.service.get_session_id","title":"get_session_id","text":"Python<pre><code>get_session_id()\n</code></pre> <p>Get the current application session ID.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>UUID string identifying this application session.</p> Source code in <code>download\\service.py</code> Python<pre><code>def get_session_id() -&gt; str:\n    \"\"\"Get the current application session ID.\n\n    Returns:\n        str: UUID string identifying this application session.\n    \"\"\"\n    return _SESSION_ID\n</code></pre>"},{"location":"api/download.service/#download.service.check_and_prepare_firmware","title":"check_and_prepare_firmware","text":"Python<pre><code>check_and_prepare_firmware(\n    model, csc, device_id, current_firmware\n)\n</code></pre> <p>Check latest firmware via FOTA and determine if cached in repository.</p> <p>Always queries Samsung FOTA for latest version. Logs to imei_log with status_fus=\"unknown\" (no FUS query yet). Then checks firmware table to see if that version is already downloaded.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier (e.g., SM-G998B).</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or serial number.</p> required <code>current_firmware</code> <code>str</code> <p>Current device firmware version (for logging/comparison).</p> required <p>Returns:</p> Type Description <code>(latest_version, is_cached)</code> <p>Latest version from FOTA and whether it exists in local repository.</p> <p>Raises:</p> Type Description <code>FOTAError</code> <p>If FOTA query fails.</p> Example <p>latest, cached = check_and_prepare_firmware(     \"SM-A146P\", \"EUX\", \"352976245060954\", \"A146PXXS6CXK3/...\" ) if cached:     print(f\"Version {latest} already downloaded\")</p> Source code in <code>download\\service.py</code> Python<pre><code>def check_and_prepare_firmware(\n    model: str,\n    csc: str,\n    device_id: str,\n    current_firmware: str,  # noqa: ARG001 - Reserved for future comparison logic\n) -&gt; tuple[str, bool]:\n    \"\"\"Check latest firmware via FOTA and determine if cached in repository.\n\n    Always queries Samsung FOTA for latest version. Logs to imei_log with\n    status_fus=\"unknown\" (no FUS query yet). Then checks firmware table\n    to see if that version is already downloaded.\n\n    Args:\n        model: Device model identifier (e.g., SM-G998B).\n        csc: Country Specific Code.\n        device_id: Device IMEI or serial number.\n        current_firmware: Current device firmware version (for logging/comparison).\n\n    Returns:\n        (latest_version, is_cached): Latest version from FOTA and whether\n            it exists in local repository.\n\n    Raises:\n        FOTAError: If FOTA query fails.\n\n    Example:\n        latest, cached = check_and_prepare_firmware(\n            \"SM-A146P\", \"EUX\", \"352976245060954\", \"A146PXXS6CXK3/...\"\n        )\n        if cached:\n            print(f\"Version {latest} already downloaded\")\n    \"\"\"\n    # 1. Always query FOTA for latest version\n    version = get_latest_version(model, csc)\n    version_norm = normalize_vercode(version)\n\n    # 2. Log device detection with FOTA result (status_fus=\"unknown\" - no FUS download yet)\n    upsert_imei_event(\n        session_id=_SESSION_ID,\n        imei=device_id,\n        model=model,\n        csc=csc,\n        version_code=version_norm,\n        status_fus=\"unknown\",  # FUS download not attempted yet\n        status_upgrade=\"unknown\",  # Firmware flashing not implemented\n    )\n\n    # 3. Check if this specific version exists in repository\n    cached = find_firmware(version_norm)\n    is_cached = cached is not None and Path(cached.encrypted_file_path).exists()\n\n    return version_norm, is_cached\n</code></pre>"},{"location":"api/download.service/#download.service.get_or_download_firmware","title":"get_or_download_firmware","text":"Python<pre><code>get_or_download_firmware(\n    version_code,\n    model,\n    csc,\n    device_id,\n    *,\n    resume=True,\n    progress_cb=None\n)\n</code></pre> <p>Get firmware from repository or download if not present.</p> <p>Checks if the firmware already exists in the repository. If not, downloads it from Samsung FUS servers and stores metadata in the database.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier (4-part format).</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or serial number.</p> required <code>resume</code> <code>bool</code> <p>If True, resume from partial download if .part file exists.</p> <code>True</code> <code>progress_cb</code> <code>Optional[Callable[[int, int], None]]</code> <p>Optional callback function(bytes_downloaded, total_bytes).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FirmwareRecord</code> <code>FirmwareRecord</code> <p>Repository record with encrypted file path and metadata.</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If FUS inform request fails.</p> <code>DownloadError</code> <p>If download fails or size verification fails.</p> Example <p>firmware = get_or_download_firmware(     \"A146PXXS6CXK3/A146POXM6CXK3/...\",     \"SM-A146P\",     \"EUX\",     \"352976245060954\" ) print(f\"Encrypted file: {firmware.encrypted_file_path}\")</p> Source code in <code>download\\service.py</code> Python<pre><code>def get_or_download_firmware(\n    version_code: str,\n    model: str,\n    csc: str,\n    device_id: str,\n    *,\n    resume: bool = True,\n    progress_cb: Optional[Callable[[int, int], None]] = None,\n) -&gt; FirmwareRecord:\n    \"\"\"Get firmware from repository or download if not present.\n\n    Checks if the firmware already exists in the repository. If not, downloads\n    it from Samsung FUS servers and stores metadata in the database.\n\n    Args:\n        version_code: Firmware version identifier (4-part format).\n        model: Device model identifier.\n        csc: Country Specific Code.\n        device_id: Device IMEI or serial number.\n        resume: If True, resume from partial download if .part file exists.\n        progress_cb: Optional callback function(bytes_downloaded, total_bytes).\n\n    Returns:\n        FirmwareRecord: Repository record with encrypted file path and metadata.\n\n    Raises:\n        InformError: If FUS inform request fails.\n        DownloadError: If download fails or size verification fails.\n\n    Example:\n        firmware = get_or_download_firmware(\n            \"A146PXXS6CXK3/A146POXM6CXK3/...\",\n            \"SM-A146P\",\n            \"EUX\",\n            \"352976245060954\"\n        )\n        print(f\"Encrypted file: {firmware.encrypted_file_path}\")\n    \"\"\"\n    # Check if already in repository\n    existing = find_firmware(version_code)\n    if existing and Path(existing.encrypted_file_path).exists():\n        return existing\n\n    # Download from FUS\n    version_norm = normalize_vercode(version_code)\n    client = FUSClient()\n\n    # 1. INFORM - get firmware metadata\n    inform_payload = build_binary_inform(version_norm, model, csc, device_id, client.nonce)\n    inform_root = client.inform(inform_payload)\n    info = parse_inform(inform_root)\n\n    # 2. INIT - authorize download\n    init_payload = build_binary_init(info.filename, client.nonce)\n    client.init(init_payload)\n\n    # 3. DOWNLOAD - stream to disk\n    PATHS.firmware_dir.mkdir(parents=True, exist_ok=True)\n    enc_path = PATHS.firmware_dir / info.filename\n    part_path = enc_path.with_suffix(enc_path.suffix + \".part\")\n\n    start = part_path.stat().st_size if (resume and part_path.exists()) else 0\n    remote = info.path + info.filename\n    resp = client.stream(remote, start=start)\n\n    mode = \"ab\" if start &gt; 0 else \"wb\"\n    written = start\n    with open(part_path, mode) as f:\n        for chunk in resp.iter_content(chunk_size=1024 * 1024):\n            if not chunk:\n                continue\n            f.write(chunk)\n            written += len(chunk)\n            if progress_cb:\n                progress_cb(written, info.size_bytes)\n\n    if written != info.size_bytes:\n        raise DownloadError(f\"Size mismatch: got {written}, expected {info.size_bytes}\")\n\n    # Atomic finalize\n    part_path.replace(enc_path)\n\n    # 4. PERSIST to repository\n    rec = FirmwareRecord(\n        version_code=version_norm,\n        filename=info.filename,\n        path=info.path,\n        size_bytes=info.size_bytes,\n        logic_value_factory=info.logic_value_factory,\n        latest_fw_version=info.latest_fw_version,\n        encrypted_file_path=str(enc_path.resolve()),\n        decrypted_file_path=None,\n    )\n    upsert_firmware(rec)\n\n    return rec\n</code></pre>"},{"location":"api/download.service/#download.service.decrypt_firmware","title":"decrypt_firmware","text":"Python<pre><code>decrypt_firmware(\n    version_code, output_path=None, *, progress_cb=None\n)\n</code></pre> <p>Decrypt firmware from repository.</p> <p>Decrypts a firmware file that exists in the repository. The decrypted file is saved to the configured decrypted directory or a custom path.</p> <p>Parameters:</p> Name Type Description Default <code>version_code</code> <code>str</code> <p>Firmware version identifier to decrypt.</p> required <code>output_path</code> <code>Optional[str]</code> <p>Optional custom output path. If None, uses PATHS.decrypted_dir/. <code>None</code> <code>progress_cb</code> <code>Optional[Callable[[int, int], None]]</code> <p>Optional callback function(bytes_processed, total_bytes).</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Absolute path to the decrypted file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If firmware not found in repository.</p> <code>FileNotFoundError</code> <p>If encrypted file doesn't exist on disk.</p> <code>DecryptError</code> <p>If decryption fails.</p> Example <p>decrypted = decrypt_firmware(\"A146PXXS6CXK3/...\") print(f\"Decrypted to: {decrypted}\")</p> Source code in <code>download\\service.py</code> Python<pre><code>def decrypt_firmware(\n    version_code: str,\n    output_path: Optional[str] = None,\n    *,\n    progress_cb: Optional[Callable[[int, int], None]] = None,\n) -&gt; str:\n    \"\"\"Decrypt firmware from repository.\n\n    Decrypts a firmware file that exists in the repository. The decrypted\n    file is saved to the configured decrypted directory or a custom path.\n\n    Args:\n        version_code: Firmware version identifier to decrypt.\n        output_path: Optional custom output path. If None, uses\n            PATHS.decrypted_dir/&lt;filename_without_enc4&gt;.\n        progress_cb: Optional callback function(bytes_processed, total_bytes).\n\n    Returns:\n        Absolute path to the decrypted file.\n\n    Raises:\n        ValueError: If firmware not found in repository.\n        FileNotFoundError: If encrypted file doesn't exist on disk.\n        DecryptError: If decryption fails.\n\n    Example:\n        decrypted = decrypt_firmware(\"A146PXXS6CXK3/...\")\n        print(f\"Decrypted to: {decrypted}\")\n    \"\"\"\n    # Get firmware from repository\n    firmware = find_firmware(version_code)\n    if not firmware:\n        raise ValueError(f\"Firmware {version_code} not found in repository\")\n\n    enc_path = Path(firmware.encrypted_file_path)\n    if not enc_path.exists():\n        raise FileNotFoundError(f\"Encrypted file not found: {enc_path}\")\n\n    # Determine output path\n    if output_path:\n        dec_path = Path(output_path)\n    else:\n        PATHS.decrypted_dir.mkdir(parents=True, exist_ok=True)\n        dec_path = PATHS.decrypted_dir / enc_path.stem\n\n    # Decrypt using logic value from repository\n    key = get_v4_key_from_logic(firmware.latest_fw_version, firmware.logic_value_factory)\n    decrypt_file(\n        str(enc_path),\n        str(dec_path),\n        key=key,\n        progress_cb=progress_cb,\n    )\n\n    # Update repository with decrypted path\n    update_decrypted_path(version_code, str(dec_path.resolve()))\n\n    return str(dec_path.resolve())\n</code></pre>"},{"location":"api/download.service/#download.service.download_and_decrypt","title":"download_and_decrypt","text":"Python<pre><code>download_and_decrypt(\n    model,\n    csc,\n    device_id,\n    current_firmware,\n    version=None,\n    *,\n    output_path=None,\n    resume=True,\n    progress_cb=None\n)\n</code></pre> <p>Complete workflow: check FOTA, download, and decrypt firmware.</p> <p>Performs the full workflow: 1. Query FOTA for latest version and check repository cache 2. Download encrypted firmware if not cached (with resume support) 3. Decrypt firmware to output directory 4. Update imei_log with FUS download status</p> <p>A single optional <code>progress_cb</code> is invoked for both stages with:     progress_cb(stage, done_bytes, total_bytes) where <code>stage</code> is one of <code>\"download\"</code> or <code>\"decrypt\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code (region).</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or serial/blank for download mode.</p> required <code>current_firmware</code> <code>str</code> <p>Current device firmware version.</p> required <code>version</code> <code>Optional[str]</code> <p>Specific version to fetch; if None latest from FOTA is used.</p> <code>None</code> <code>output_path</code> <code>Optional[str]</code> <p>Optional explicit decrypted output path.</p> <code>None</code> <code>resume</code> <code>bool</code> <p>Resume partial downloads when True.</p> <code>True</code> <code>progress_cb</code> <code>Optional[Callable[[str, int, int], None]]</code> <p>Unified callback for both stages.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[FirmwareRecord, str]</code> <p>(FirmwareRecord, decrypted_file_path)</p> Source code in <code>download\\service.py</code> Python<pre><code>def download_and_decrypt(\n    model: str,\n    csc: str,\n    device_id: str,\n    current_firmware: str,\n    version: Optional[str] = None,\n    *,\n    output_path: Optional[str] = None,\n    resume: bool = True,\n    progress_cb: Optional[Callable[[str, int, int], None]] = None,\n) -&gt; tuple[FirmwareRecord, str]:\n    \"\"\"Complete workflow: check FOTA, download, and decrypt firmware.\n\n    Performs the full workflow:\n    1. Query FOTA for latest version and check repository cache\n    2. Download encrypted firmware if not cached (with resume support)\n    3. Decrypt firmware to output directory\n    4. Update imei_log with FUS download status\n\n    A single optional ``progress_cb`` is invoked for both stages with:\n        progress_cb(stage, done_bytes, total_bytes)\n    where ``stage`` is one of ``\"download\"`` or ``\"decrypt\"``.\n\n    Args:\n        model: Device model identifier.\n        csc: Country Specific Code (region).\n        device_id: Device IMEI or serial/blank for download mode.\n        current_firmware: Current device firmware version.\n        version: Specific version to fetch; if None latest from FOTA is used.\n        output_path: Optional explicit decrypted output path.\n        resume: Resume partial downloads when True.\n        progress_cb: Unified callback for both stages.\n\n    Returns:\n        (FirmwareRecord, decrypted_file_path)\n    \"\"\"\n    # 1. Resolve version and check cache\n    if not version:\n        version, _is_cached = check_and_prepare_firmware(model, csc, device_id, current_firmware)\n    else:\n        version = normalize_vercode(version)\n\n    # 2. Download to repository\n    def _dl_cb(done: int, total: int):\n        if progress_cb:\n            progress_cb(\"download\", done, total)\n\n    firmware = get_or_download_firmware(\n        version, model, csc, device_id, resume=resume, progress_cb=_dl_cb if progress_cb else None\n    )\n\n    # Update log with successful firmware retrieval (whether downloaded or cached)\n    # This updates the existing session record created by check_and_prepare_firmware\n    upsert_imei_event(\n        session_id=_SESSION_ID,\n        imei=device_id,\n        model=model,\n        csc=csc,\n        version_code=version,\n        status_fus=\"ok\",  # Firmware obtained successfully\n        status_upgrade=\"unknown\",  # Firmware flashing not implemented\n    )\n\n    # 3. Decrypt\n    def _dec_cb(done: int, total: int):\n        if progress_cb:\n            progress_cb(\"decrypt\", done, total)\n\n    decrypted_path = decrypt_firmware(\n        version,\n        output_path,\n        progress_cb=_dec_cb if progress_cb else None,\n    )\n\n    return firmware, decrypted_path\n</code></pre>"},{"location":"api/download.service/#download.service.cleanup_repository","title":"cleanup_repository","text":"Python<pre><code>cleanup_repository(progress_cb=None)\n</code></pre> <p>Clean repository inconsistencies.</p> <p>Verifies each firmware record's encrypted file exists. If missing:     * Deletes decrypted file if present.     * Deletes database record.</p> <p>Parameters:</p> Name Type Description Default <code>progress_cb</code> <code>Optional[Callable[[int, int, int, int, int], None]]</code> <p>Optional callback invoked as progress_cb(processed, total, missing_encrypted, records_deleted, decrypted_deleted)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Summary statistics dict with keys: total_records, missing_encrypted, decrypted_deleted, records_deleted</p> Source code in <code>download\\service.py</code> Python<pre><code>def cleanup_repository(\n    progress_cb: Optional[Callable[[int, int, int, int, int], None]] = None,\n) -&gt; Dict[str, int]:\n    \"\"\"Clean repository inconsistencies.\n\n    Verifies each firmware record's encrypted file exists. If missing:\n        * Deletes decrypted file if present.\n        * Deletes database record.\n\n    Args:\n        progress_cb: Optional callback invoked as\n            progress_cb(processed, total, missing_encrypted, records_deleted, decrypted_deleted)\n\n    Returns:\n        Summary statistics dict with keys:\n            total_records, missing_encrypted, decrypted_deleted, records_deleted\n    \"\"\"\n    stats = {\n        \"total_records\": 0,\n        \"missing_encrypted\": 0,\n        \"decrypted_deleted\": 0,\n        \"records_deleted\": 0,\n    }\n\n    records = list(list_firmware())\n    total = len(records)\n    for idx, rec in enumerate(records, start=1):\n        stats[\"total_records\"] += 1\n        enc_path = Path(rec.encrypted_file_path)\n        if not enc_path.is_file():\n            stats[\"missing_encrypted\"] += 1\n            # remove decrypted file if exists\n            if rec.decrypted_file_path:\n                dec_path = Path(rec.decrypted_file_path)\n                try:\n                    if dec_path.exists():\n                        dec_path.unlink()\n                        stats[\"decrypted_deleted\"] += 1\n                except OSError:\n                    pass\n            delete_firmware(rec.version_code)\n            stats[\"records_deleted\"] += 1\n\n        if progress_cb:\n            progress_cb(\n                idx,\n                total,\n                stats[\"missing_encrypted\"],\n                stats[\"records_deleted\"],\n                stats[\"decrypted_deleted\"],\n            )\n\n    return stats\n</code></pre>"},{"location":"api/fus.client/","title":"Package API <code>fus.client</code>","text":""},{"location":"api/fus.client/#fus.client","title":"fus.client","text":"<p>Samsung Firmware Update Service (FUS) client implementation.</p> <p>Provides the core FUSClient class for communicating with Samsung's firmware servers using the FUS protocol including inform, init, and download operations.</p>"},{"location":"api/fus.client/#fus.client.FUSClient","title":"FUSClient","text":"<p>Samsung Firmware Update Service (FUS) client implementation.</p> <p>Handles core FUS protocol operations including NONCE rotation, signature generation, and session management.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>FUSConfig</code> <p>FUS configuration settings. Defaults to DEFAULT_CONFIG.</p> <code>DEFAULT_CONFIG</code> <code>session</code> <code>Optional[Session]</code> <p>Optional requests.Session for connection reuse.</p> <code>None</code> Source code in <code>fus\\client.py</code> Python<pre><code>class FUSClient:\n    \"\"\"\n    Samsung Firmware Update Service (FUS) client implementation.\n\n    Handles core FUS protocol operations including NONCE rotation,\n    signature generation, and session management.\n\n    Args:\n        cfg: FUS configuration settings. Defaults to DEFAULT_CONFIG.\n        session: Optional requests.Session for connection reuse.\n    \"\"\"\n\n    def __init__(self, cfg: FUSConfig = DEFAULT_CONFIG, session: Optional[requests.Session] = None):\n        self.cfg = cfg\n        self.sess = session or requests.Session()\n        self._auth = \"\"\n        self._sessid = \"\"\n        self._enc_nonce = \"\"\n        self.nonce = \"\"\n        # bootstrap: r\u00e9cup\u00e9rer un NONCE\n        self._makereq(\"NF_DownloadGenerateNonce.do\")\n\n    def _headers(self, with_server_nonce: bool = False) -&gt; dict:\n        \"\"\"\n        Build request headers including Authorization and User-Agent.\n\n        Args:\n            with_server_nonce: Whether to include encrypted NONCE in Authorization.\n\n        Returns:\n            dict: Headers dictionary for FUS requests.\n        \"\"\"\n        nonce = self._enc_nonce if with_server_nonce else \"\"\n        authv = (\n            f'FUS nonce=\"{nonce}\", signature=\"{self._auth}\", nc=\"\", type=\"\", realm=\"\", newauth=\"1\"'\n        )\n        return {\"Authorization\": authv, \"User-Agent\": self.cfg.user_agent}\n\n    def _makereq(self, path: str, data: bytes | str = b\"\") -&gt; str:\n        \"\"\"\n        Make an authenticated request to FUS server with NONCE rotation.\n\n        Args:\n            path: API endpoint path.\n            data: Request payload (XML or bytes).\n\n        Returns:\n            str: Response text from server.\n\n        Raises:\n            requests.exceptions.HTTPError: On non-200 response.\n        \"\"\"\n        url = f\"{self.cfg.base_url}/{path}\"\n        r = self.sess.post(\n            url,\n            data=data,\n            headers=self._headers(),\n            timeout=self.cfg.request_timeout,\n            cookies={\"JSESSIONID\": self._sessid},\n        )\n        # rotation de nonce + signature\n        if \"NONCE\" in r.headers:\n            self._enc_nonce = r.headers[\"NONCE\"]\n            self.nonce = decrypt_nonce(self._enc_nonce)\n            self._auth = make_signature(self.nonce)\n        if \"JSESSIONID\" in r.cookies:\n            self._sessid = r.cookies[\"JSESSIONID\"]\n        r.raise_for_status()\n        return r.text\n\n    def inform(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Send inform request to get firmware information.\n\n        Args:\n            payload: XML payload containing device and firmware details.\n\n        Returns:\n            ET.Element: Parsed XML response containing firmware metadata.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n        return ET.fromstring(xml)\n\n    def init(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Initialize binary download session.\n\n        Args:\n            payload: XML payload with download request details.\n\n        Returns:\n            ET.Element: Parsed XML response with download authorization.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n        return ET.fromstring(xml)\n\n    def stream(self, filename: str, start: int = 0) -&gt; requests.Response:\n        \"\"\"\n        Stream firmware download from cloud server.\n\n        Args:\n            filename: Remote firmware file path.\n            start: Byte offset for resume capability.\n\n        Returns:\n            requests.Response: Streaming response object.\n\n        Raises:\n            DownloadError: On download initialization failure.\n        \"\"\"\n        # cloud download (transmits client-side encrypted NONCE)\n        url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n        headers = self._headers(with_server_nonce=True)\n        if start &gt; 0:\n            headers[\"Range\"] = f\"bytes={start}-\"\n        r = self.sess.get(\n            url,\n            params=\"file=\" + filename,\n            headers=headers,\n            stream=True,\n            timeout=self.cfg.request_timeout,\n        )\n        if not r.ok:\n            raise DownloadError.HTTPError(r.status_code, filename)\n        return r\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.inform","title":"inform","text":"Python<pre><code>inform(payload)\n</code></pre> <p>Send inform request to get firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload containing device and firmware details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response containing firmware metadata.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus\\client.py</code> Python<pre><code>def inform(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Send inform request to get firmware information.\n\n    Args:\n        payload: XML payload containing device and firmware details.\n\n    Returns:\n        ET.Element: Parsed XML response containing firmware metadata.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.init","title":"init","text":"Python<pre><code>init(payload)\n</code></pre> <p>Initialize binary download session.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload with download request details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response with download authorization.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus\\client.py</code> Python<pre><code>def init(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Initialize binary download session.\n\n    Args:\n        payload: XML payload with download request details.\n\n    Returns:\n        ET.Element: Parsed XML response with download authorization.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.stream","title":"stream","text":"Python<pre><code>stream(filename, start=0)\n</code></pre> <p>Stream firmware download from cloud server.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Remote firmware file path.</p> required <code>start</code> <code>int</code> <p>Byte offset for resume capability.</p> <code>0</code> <p>Returns:</p> Type Description <code>Response</code> <p>requests.Response: Streaming response object.</p> <p>Raises:</p> Type Description <code>DownloadError</code> <p>On download initialization failure.</p> Source code in <code>fus\\client.py</code> Python<pre><code>def stream(self, filename: str, start: int = 0) -&gt; requests.Response:\n    \"\"\"\n    Stream firmware download from cloud server.\n\n    Args:\n        filename: Remote firmware file path.\n        start: Byte offset for resume capability.\n\n    Returns:\n        requests.Response: Streaming response object.\n\n    Raises:\n        DownloadError: On download initialization failure.\n    \"\"\"\n    # cloud download (transmits client-side encrypted NONCE)\n    url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n    headers = self._headers(with_server_nonce=True)\n    if start &gt; 0:\n        headers[\"Range\"] = f\"bytes={start}-\"\n    r = self.sess.get(\n        url,\n        params=\"file=\" + filename,\n        headers=headers,\n        stream=True,\n        timeout=self.cfg.request_timeout,\n    )\n    if not r.ok:\n        raise DownloadError.HTTPError(r.status_code, filename)\n    return r\n</code></pre>"},{"location":"api/fus.config/","title":"Package API <code>fus.config</code>","text":""},{"location":"api/fus.config/#fus.config","title":"fus.config","text":"<p>FUS configuration helpers.</p> <p>This module defines the FUSConfig dataclass which centralizes default endpoints and HTTP settings used by the FUS client.</p>"},{"location":"api/fus.config/#fus.config.FUSConfig","title":"FUSConfig  <code>dataclass</code>","text":"<p>Configuration for the Firmware Update Service (FUS) client.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for FUS control endpoints. Some clients/tools may use a different host.</p> <code>'https://neofussvr.sslcs.cdngc.net'</code> <code>cloud_url</code> <code>str</code> <p>Primary cloud URL used for firmware downloads.</p> <code>'http://cloud-neofussvr.samsungmobile.com'</code> <code>old_cloud_url</code> <code>str</code> <p>Legacy cloud URL kept for compatibility.</p> <code>'http://cloud-fussvr.sslcs.cdngc.net'</code> <code>user_agent</code> <code>str</code> <p>User-Agent header used for HTTP requests.</p> <code>'Kies2.0_FUS'</code> <code>request_timeout</code> <code>int</code> <p>Default timeout in seconds for HTTP requests.</p> <code>60</code> Source code in <code>fus\\config.py</code> Python<pre><code>@dataclass(frozen=True)\nclass FUSConfig:\n    \"\"\"\n    Configuration for the Firmware Update Service (FUS) client.\n\n    Args:\n        base_url: Base URL for FUS control endpoints. Some clients/tools may use a different host.\n        cloud_url: Primary cloud URL used for firmware downloads.\n        old_cloud_url: Legacy cloud URL kept for compatibility.\n        user_agent: User-Agent header used for HTTP requests.\n        request_timeout: Default timeout in seconds for HTTP requests.\n    \"\"\"\n\n    # Endpoints (some clients/tools may use a different cloud host)\n    base_url: str = \"https://neofussvr.sslcs.cdngc.net\"\n    cloud_url: str = \"http://cloud-neofussvr.samsungmobile.com\"\n    old_cloud_url: str = \"http://cloud-fussvr.sslcs.cdngc.net\"\n    # Default User-Agent and timeout for HTTP requests\n    user_agent: str = \"Kies2.0_FUS\"\n    request_timeout: int = 60  # seconds\n</code></pre>"},{"location":"api/fus.crypto/","title":"Package API <code>fus.crypto</code>","text":""},{"location":"api/fus.crypto/#fus.crypto","title":"fus.crypto","text":"<p>FUS crypto helpers: AES CBC utilities, padding, key derivation and logic checks.</p> <p>Provides small helpers used by the FUS client and decryption routines.</p>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_pad","title":"pkcs_pad","text":"Python<pre><code>pkcs_pad(data)\n</code></pre> <p>Apply PKCS#7 padding to reach a 16-byte boundary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw bytes to pad.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Padded bytes.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def pkcs_pad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Apply PKCS#7 padding to reach a 16-byte boundary.\n\n    Args:\n        data: Raw bytes to pad.\n\n    Returns:\n        Padded bytes.\n    \"\"\"\n    pad_len = 16 - (len(data) % 16)\n    return data + bytes([pad_len]) * pad_len\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_unpad","title":"pkcs_unpad","text":"Python<pre><code>pkcs_unpad(data)\n</code></pre> <p>Remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Padded bytes.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Original unpadded bytes.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def pkcs_unpad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Remove PKCS#7 padding.\n\n    Args:\n        data: Padded bytes.\n\n    Returns:\n        Original unpadded bytes.\n    \"\"\"\n    return data[: -data[-1]]\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_encrypt","title":"aes_cbc_encrypt","text":"Python<pre><code>aes_cbc_encrypt(inp, key)\n</code></pre> <p>Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Plaintext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key (16/24/32 bytes).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Ciphertext bytes.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def aes_cbc_encrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.\n\n    Args:\n        inp: Plaintext bytes.\n        key: AES key (16/24/32 bytes).\n\n    Returns:\n        Ciphertext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return cipher.encrypt(pkcs_pad(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_decrypt","title":"aes_cbc_decrypt","text":"Python<pre><code>aes_cbc_decrypt(inp, key)\n</code></pre> <p>Decrypt AES-CBC ciphertext and remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Ciphertext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key used to encrypt.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Plaintext bytes.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def aes_cbc_decrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt AES-CBC ciphertext and remove PKCS#7 padding.\n\n    Args:\n        inp: Ciphertext bytes.\n        key: AES key used to encrypt.\n\n    Returns:\n        Plaintext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return pkcs_unpad(cipher.decrypt(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.derive_key","title":"derive_key","text":"Python<pre><code>derive_key(nonce)\n</code></pre> <p>Build a key from a 16-character server nonce.</p> <p>The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars, concatenated with KEY_2, returned as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>16-character nonce string.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Derived key bytes.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def derive_key(nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a key from a 16-character server nonce.\n\n    The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars,\n    concatenated with KEY_2, returned as bytes.\n\n    Args:\n        nonce: 16-character nonce string.\n\n    Returns:\n        Derived key bytes.\n    \"\"\"\n    k = \"\".join(KEY_1[ord(nonce[i]) % 16] for i in range(16))\n    k += KEY_2\n    return k.encode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.make_signature","title":"make_signature","text":"Python<pre><code>make_signature(nonce)\n</code></pre> <p>Compute the base64-encoded signature for a nonce.</p> <p>The signature is base64(AES-CBC(nonce, derive_key(nonce))).</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>Plaintext nonce.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base64-encoded signature string.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def make_signature(nonce: str) -&gt; str:\n    \"\"\"\n    Compute the base64-encoded signature for a nonce.\n\n    The signature is base64(AES-CBC(nonce, derive_key(nonce))).\n\n    Args:\n        nonce: Plaintext nonce.\n\n    Returns:\n        Base64-encoded signature string.\n    \"\"\"\n    raw = aes_cbc_encrypt(nonce.encode(), derive_key(nonce))\n    return base64.b64encode(raw).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.decrypt_nonce","title":"decrypt_nonce","text":"Python<pre><code>decrypt_nonce(enc_nonce)\n</code></pre> <p>Decrypt a server NONCE header.</p> <p>Parameters:</p> Name Type Description Default <code>enc_nonce</code> <code>str</code> <p>Base64-encoded ciphertext from server.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Decrypted plaintext nonce.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates base64 and AES decode errors if input is malformed.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def decrypt_nonce(enc_nonce: str) -&gt; str:\n    \"\"\"\n    Decrypt a server NONCE header.\n\n    Args:\n        enc_nonce: Base64-encoded ciphertext from server.\n\n    Returns:\n        Decrypted plaintext nonce.\n\n    Raises:\n        Exception: Propagates base64 and AES decode errors if input is malformed.\n    \"\"\"\n    data = base64.b64decode(enc_nonce)\n    return aes_cbc_decrypt(data, KEY_1.encode()).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.logic_check","title":"logic_check","text":"Python<pre><code>logic_check(inp, nonce)\n</code></pre> <p>Compute the FUS logic-check value.</p> <p>Picks characters from <code>inp</code> using the low 4 bits of each character in <code>nonce</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Input string (must be at least 16 characters).</p> required <code>nonce</code> <code>str</code> <p>Server nonce string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Computed logic-check string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>inp</code> is shorter than 16 characters.</p> Source code in <code>fus\\crypto.py</code> Python<pre><code>def logic_check(inp: str, nonce: str) -&gt; str:\n    \"\"\"\n    Compute the FUS logic-check value.\n\n    Picks characters from `inp` using the low 4 bits of each character in `nonce`.\n\n    Args:\n        inp: Input string (must be at least 16 characters).\n        nonce: Server nonce string.\n\n    Returns:\n        Computed logic-check string.\n\n    Raises:\n        ValueError: If `inp` is shorter than 16 characters.\n    \"\"\"\n    if len(inp) &lt; 16:\n        raise ValueError(\"logic_check input too short\")\n    return \"\".join(inp[ord(c) &amp; 0xF] for c in nonce)\n</code></pre>"},{"location":"api/fus.csclist/","title":"Package API <code>fus.csclist</code>","text":""},{"location":"api/fus.csclist/#fus.csclist","title":"fus.csclist","text":"<p>CSC mapping for Samsung firmware regions.</p> <p>This module provides CSC_DICT, a dictionary that maps 3-letter Samsung CSC codes to their corresponding country or region names. It is used by the CLI and GUI components to display or validate CSC/region information.</p> <p>Attributes:</p> Name Type Description <code>CSC_DICT</code> <code>dict</code> <p>Mapping of 3-letter CSC codes to region/country names.</p>"},{"location":"api/fus.decrypt/","title":"Package API <code>fus.decrypt</code>","text":""},{"location":"api/fus.decrypt/#fus.decrypt","title":"fus.decrypt","text":"<p>FUS decryption helpers.</p> <p>Provides functions to derive ENC2/ENC4 keys and to decrypt streaming firmware blobs.</p> <p>Functions: - get_v2_key: derive MD5-based ENC2 key. - get_v4_key_from_logic: derive ENC4 key from firmware version and logic value. - get_v4_key: retrieve logic value via FUS inform and derive ENC4 key. - decrypt_file: decrypt a file encrypting in 16-byte AES blocks.</p>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v2_key","title":"get_v2_key","text":"Python<pre><code>get_v2_key(version, model, region, _device_id)\n</code></pre> <p>Derive ENC2 key (V2) using MD5.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>_device_id</code> <code>str</code> <p>Unused for V2 (kept for API parity).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>MD5 digest bytes of the string \"region:model:version\".</p> Source code in <code>fus\\decrypt.py</code> Python<pre><code>def get_v2_key(version: str, model: str, region: str, _device_id: str) -&gt; bytes:\n    \"\"\"\n    Derive ENC2 key (V2) using MD5.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        _device_id: Unused for V2 (kept for API parity).\n\n    Returns:\n        MD5 digest bytes of the string \"region:model:version\".\n    \"\"\"\n    deckey = f\"{region}:{model}:{version}\"\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v4_key_from_logic","title":"get_v4_key_from_logic","text":"Python<pre><code>get_v4_key_from_logic(fw_version, logic_value)\n</code></pre> <p>Derive ENC4 key (V4) from firmware version and logic value.</p> <p>Use this when you already have the logic value from a previous inform call.</p> <p>Parameters:</p> Name Type Description Default <code>fw_version</code> <code>str</code> <p>Latest firmware version string from inform response.</p> required <code>logic_value</code> <code>str</code> <p>Logic value factory string from inform response.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>MD5 digest bytes derived from the logic-check value.</p> Source code in <code>fus\\decrypt.py</code> Python<pre><code>def get_v4_key_from_logic(fw_version: str, logic_value: str) -&gt; bytes:\n    \"\"\"\n    Derive ENC4 key (V4) from firmware version and logic value.\n\n    Use this when you already have the logic value from a previous inform call.\n\n    Args:\n        fw_version: Latest firmware version string from inform response.\n        logic_value: Logic value factory string from inform response.\n\n    Returns:\n        MD5 digest bytes derived from the logic-check value.\n    \"\"\"\n    deckey = logic_check(fw_version, logic_value)\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v4_key","title":"get_v4_key","text":"Python<pre><code>get_v4_key(version, model, region, device_id, client=None)\n</code></pre> <p>Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>device_id</code> <code>str</code> <p>IMEI or Serial required by Samsung for ENC4.</p> required <code>client</code> <code>FUSClient | None</code> <p>Optional FUSClient instance to use (a new one is created if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>MD5 digest bytes derived from the logic-check value, or None on failure.</p> <p>Raises:</p> Type Description <code>DecryptError</code> <p>If device_id is not provided.</p> <code>InformError</code> <p>If the inform response lacks expected fields.</p> Source code in <code>fus\\decrypt.py</code> Python<pre><code>def get_v4_key(\n    version: str, model: str, region: str, device_id: str, client: FUSClient | None = None\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        device_id: IMEI or Serial required by Samsung for ENC4.\n        client: Optional FUSClient instance to use (a new one is created if None).\n\n    Returns:\n        MD5 digest bytes derived from the logic-check value, or None on failure.\n\n    Raises:\n        DecryptError: If device_id is not provided.\n        InformError: If the inform response lacks expected fields.\n    \"\"\"\n    if not device_id:\n        raise DecryptError.DeviceIdRequired()\n    client = client or FUSClient()\n    ver = normalize_vercode(version)\n    resp = client.inform(build_binary_inform(ver, model, region, device_id, client.nonce))\n    try:\n        fwver = resp.find(\"./FUSBody/Results/LATEST_FW_VERSION/Data\").text  # type: ignore\n        logicval = resp.find(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\").text  # type: ignore\n    except Exception as exc:\n        raise InformError.DecryptionKeyError(model, region, device_id) from exc\n    return get_v4_key_from_logic(fwver, logicval)  # type: ignore\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.decrypt_file","title":"decrypt_file","text":"Python<pre><code>decrypt_file(enc_path, out_path, *, key, progress_cb=None)\n</code></pre> <p>Decrypt an encrypted firmware file to disk.</p> <p>Parameters:</p> Name Type Description Default <code>enc_path</code> <code>str</code> <p>Path to the encrypted input file.</p> required <code>out_path</code> <code>str</code> <p>Path to write the decrypted output file.</p> required <code>key</code> <code>bytes</code> <p>AES key used for decryption.</p> required <code>progress_cb</code> <code>Optional[Callable[[int, int], None]]</code> <p>Optional progress callback(progress_bytes, total_bytes).</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>fus\\decrypt.py</code> Python<pre><code>def decrypt_file(\n    enc_path: str,\n    out_path: str,\n    *,\n    key: bytes,\n    progress_cb: Optional[Callable[[int, int], None]] = None,\n) -&gt; None:\n    \"\"\"\n    Decrypt an encrypted firmware file to disk.\n\n    Args:\n        enc_path: Path to the encrypted input file.\n        out_path: Path to write the decrypted output file.\n        key: AES key used for decryption.\n        progress_cb: Optional progress callback(progress_bytes, total_bytes).\n\n    Returns:\n        None\n    \"\"\"\n    size = os.stat(enc_path).st_size\n    with open(enc_path, \"rb\") as fin, open(out_path, \"wb\") as fout:\n        _decrypt_progress(fin, fout, key, size, progress_cb=progress_cb)\n</code></pre>"},{"location":"api/fus.deviceid/","title":"Package API <code>fus.deviceid</code>","text":""},{"location":"api/fus.deviceid/#fus.deviceid","title":"fus.deviceid","text":"<p>Device identifier helpers for FUS interactions.</p> <p>Provides IMEI Luhn checksum computation, TAC-based IMEI autofill, and validation helpers for serial numbers and IMEIs.</p> <p>Functions: - luhn_checksum: compute Luhn check digit for a 14-digit IMEI core. - autofill_imei: complete a TAC to a full 15-digit IMEI (random fill + Luhn). - validate_serial: basic alphanumeric serial validation. - validate_imei: full 15-digit IMEI validation using Luhn. - is_device_id_required: policy for when a device id is required by commands.</p>"},{"location":"api/fus.deviceid/#fus.deviceid.luhn_checksum","title":"luhn_checksum","text":"Python<pre><code>luhn_checksum(imei_without_cd)\n</code></pre> <p>Compute the Luhn check digit for the provided IMEI core.</p> <p>Parameters:</p> Name Type Description Default <code>imei_without_cd</code> <code>str</code> <p>IMEI digits excluding the check digit (typically 14 digits).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The single-digit Luhn checksum as an int.</p> Source code in <code>fus\\deviceid.py</code> Python<pre><code>def luhn_checksum(imei_without_cd: str) -&gt; int:\n    \"\"\"\n    Compute the Luhn check digit for the provided IMEI core.\n\n    Args:\n        imei_without_cd: IMEI digits excluding the check digit (typically 14 digits).\n\n    Returns:\n        The single-digit Luhn checksum as an int.\n    \"\"\"\n    s, tmp = 0, imei_without_cd + \"0\"\n    parity = len(tmp) % 2\n    for idx, ch in enumerate(tmp):\n        d = int(ch)\n        if idx % 2 == parity:\n            d *= 2\n            if d &gt; 9:\n                d -= 9\n        s += d\n    return (10 - (s % 10)) % 10\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.autofill_imei","title":"autofill_imei","text":"Python<pre><code>autofill_imei(tac)\n</code></pre> <p>Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.</p> <p>Parameters:</p> Name Type Description Default <code>tac</code> <code>str</code> <p>TAC prefix (must be numeric and at least 8 digits).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A 15-digit IMEI string.</p> <p>Raises:</p> Type Description <code>DeviceIdError</code> <p>If TAC is not numeric or shorter than 8 digits.</p> Source code in <code>fus\\deviceid.py</code> Python<pre><code>def autofill_imei(tac: str) -&gt; str:\n    \"\"\"\n    Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.\n\n    Args:\n        tac: TAC prefix (must be numeric and at least 8 digits).\n\n    Returns:\n        A 15-digit IMEI string.\n\n    Raises:\n        DeviceIdError: If TAC is not numeric or shorter than 8 digits.\n    \"\"\"\n    if not tac.isdecimal() or len(tac) &lt; 8:\n        raise DeviceIdError.InvalidTAC(tac)\n    if len(tac) &gt;= 15:\n        return tac[:15]\n    missing = 14 - len(tac)\n    rnd = f\"{random.randint(0, 10**missing - 1):0{missing}d}\"\n    core = tac + rnd\n    return core + str(luhn_checksum(core))\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_serial","title":"validate_serial","text":"Python<pre><code>validate_serial(serial)\n</code></pre> <p>Validate a device serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str</code> <p>Serial string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if serial is non-empty, alphanumeric and length between 1 and 35.</p> Source code in <code>fus\\deviceid.py</code> Python<pre><code>def validate_serial(serial: str) -&gt; bool:\n    \"\"\"\n    Validate a device serial number.\n\n    Args:\n        serial: Serial string to validate.\n\n    Returns:\n        True if serial is non-empty, alphanumeric and length between 1 and 35.\n    \"\"\"\n    return bool(serial) and (1 &lt;= len(serial) &lt;= 35) and serial.isalnum()\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_imei","title":"validate_imei","text":"Python<pre><code>validate_imei(imei)\n</code></pre> <p>Validate a full 15-digit IMEI using the Luhn checksum.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>IMEI string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.</p> Source code in <code>fus\\deviceid.py</code> Python<pre><code>def validate_imei(imei: str) -&gt; bool:\n    \"\"\"\n    Validate a full 15-digit IMEI using the Luhn checksum.\n\n    Args:\n        imei: IMEI string to validate.\n\n    Returns:\n        True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.\n    \"\"\"\n    if not imei or not imei.isdecimal():\n        return False\n    if len(imei) != 15:\n        return False\n    try:\n        check_digit = int(imei[14])\n    except ValueError:\n        return False\n    return luhn_checksum(imei[:14]) == check_digit\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.is_device_id_required","title":"is_device_id_required","text":"Python<pre><code>is_device_id_required(command, enc_ver)\n</code></pre> <p>Policy deciding whether a device id is required for an operation.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name (e.g. \"download\", \"decrypt\").</p> required <code>enc_ver</code> <code>int | None</code> <p>Encryption version (None if unknown).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the command requires a device id (download always, decrypt only for ENC4).</p> Source code in <code>fus\\deviceid.py</code> Python<pre><code>def is_device_id_required(command: str, enc_ver: int | None) -&gt; bool:\n    \"\"\"\n    Policy deciding whether a device id is required for an operation.\n\n    Args:\n        command: Command name (e.g. \"download\", \"decrypt\").\n        enc_ver: Encryption version (None if unknown).\n\n    Returns:\n        True if the command requires a device id (download always, decrypt only for ENC4).\n    \"\"\"\n    return command == \"download\" or (command == \"decrypt\" and enc_ver == 4)\n</code></pre>"},{"location":"api/fus.errors/","title":"Package API <code>fus.errors</code>","text":""},{"location":"api/fus.errors/#fus.errors","title":"fus.errors","text":"<p>FUS package error definitions.</p> <p>This module defines custom exceptions used across the FUS package. In particular, DeviceIdError is raised by the device identifier utilities (e.g. IMEI/TAC validation and autofill) when provided input is invalid.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>Base class for FUS-related errors.</p> <code>AuthError</code> <p>Raised for authentication failures in FUS operations.</p> <code>InformError</code> <p>Raised for protocol or information errors in FUS communication.</p> <code>DownloadError</code> <p>Raised when a firmware download fails or is incomplete.</p> <code>DecryptError</code> <p>Raised when firmware decryption fails.</p> <code>DeviceIdError</code> <p>Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.</p> <code>FOTAError</code> <p>Base class for FOTA endpoint errors.</p> <code>FOTAParsingError</code> <p>Raised when FOTA XML response parsing fails.</p>"},{"location":"api/fus.errors/#fus.errors.FUSError","title":"FUSError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for FUS-related errors with optional predefined messages.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class FUSError(Exception):\n    \"\"\"Base class for FUS-related errors with optional predefined messages.\"\"\"\n\n    # Error subtypes with built-in messages\n    class NoFirmware(Exception):\n        \"\"\"No firmware available for the specified model/region.\"\"\"\n\n        def __init__(self, model: str = \"\", region: str = \"\"):\n            msg = \"No latest firmware available\"\n            if model or region:\n                msg += f\" for {model}/{region}\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FUSError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.AuthError","title":"AuthError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised for authentication failures in FUS operations.</p> <p>Typical causes include invalid or expired NONCE, signature mismatch, or blocked client credentials when contacting Samsung FUS endpoints.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class AuthError(FUSError):\n    \"\"\"Raised for authentication failures in FUS operations.\n\n    Typical causes include invalid or expired NONCE, signature mismatch,\n    or blocked client credentials when contacting Samsung FUS endpoints.\n    \"\"\"\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.AuthError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError","title":"InformError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised for protocol or information errors in FUS communication.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class InformError(FUSError):\n    \"\"\"Raised for protocol or information errors in FUS communication.\"\"\"\n\n    # Error subtypes with built-in messages\n    class MissingStatus(Exception):\n        \"\"\"Missing Status field in inform response.\"\"\"\n\n        def __init__(self):\n            super().__init__(\"Missing Status field in inform response\")\n\n    class BadStatus(Exception):\n        \"\"\"Non-200 status code in inform response.\"\"\"\n\n        def __init__(self, status: int):\n            super().__init__(f\"DownloadBinaryInform returned {status}\")\n\n    class MissingField(Exception):\n        \"\"\"Required field missing from inform response.\"\"\"\n\n        def __init__(self, field_name: str):\n            super().__init__(f\"Missing {field_name} in inform response\")\n\n    class DecryptionKeyError(Exception):\n        \"\"\"Could not obtain decryption key from inform response.\"\"\"\n\n        def __init__(self, model: str = \"\", region: str = \"\", device_id: str = \"\"):\n            msg = \"Could not obtain decryption key\"\n            details = []\n            if model:\n                details.append(f\"model={model}\")\n            if region:\n                details.append(f\"region={region}\")\n            if device_id:\n                details.append(f\"device_id={device_id[:4]}***\")\n            if details:\n                msg += f\" ({', '.join(details)})\"\n            msg += \"; check model/region/device_id\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.MissingStatus","title":"MissingStatus","text":"<p>               Bases: <code>Exception</code></p> <p>Missing Status field in inform response.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class MissingStatus(Exception):\n    \"\"\"Missing Status field in inform response.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"Missing Status field in inform response\")\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.BadStatus","title":"BadStatus","text":"<p>               Bases: <code>Exception</code></p> <p>Non-200 status code in inform response.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class BadStatus(Exception):\n    \"\"\"Non-200 status code in inform response.\"\"\"\n\n    def __init__(self, status: int):\n        super().__init__(f\"DownloadBinaryInform returned {status}\")\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.MissingField","title":"MissingField","text":"<p>               Bases: <code>Exception</code></p> <p>Required field missing from inform response.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class MissingField(Exception):\n    \"\"\"Required field missing from inform response.\"\"\"\n\n    def __init__(self, field_name: str):\n        super().__init__(f\"Missing {field_name} in inform response\")\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.DecryptionKeyError","title":"DecryptionKeyError","text":"<p>               Bases: <code>Exception</code></p> <p>Could not obtain decryption key from inform response.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class DecryptionKeyError(Exception):\n    \"\"\"Could not obtain decryption key from inform response.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\", device_id: str = \"\"):\n        msg = \"Could not obtain decryption key\"\n        details = []\n        if model:\n            details.append(f\"model={model}\")\n        if region:\n            details.append(f\"region={region}\")\n        if device_id:\n            details.append(f\"device_id={device_id[:4]}***\")\n        if details:\n            msg += f\" ({', '.join(details)})\"\n        msg += \"; check model/region/device_id\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.InformError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DownloadError","title":"DownloadError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised when a firmware download fails or is incomplete.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class DownloadError(FUSError):\n    \"\"\"Raised when a firmware download fails or is incomplete.\"\"\"\n\n    # Error subtypes with built-in messages\n    class HTTPError(Exception):\n        \"\"\"HTTP error during download.\"\"\"\n\n        def __init__(self, status_code: int, url: str = \"\"):\n            msg = f\"HTTP {status_code} on download\"\n            if url:\n                msg += f\": {url}\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DownloadError.HTTPError","title":"HTTPError","text":"<p>               Bases: <code>Exception</code></p> <p>HTTP error during download.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class HTTPError(Exception):\n    \"\"\"HTTP error during download.\"\"\"\n\n    def __init__(self, status_code: int, url: str = \"\"):\n        msg = f\"HTTP {status_code} on download\"\n        if url:\n            msg += f\": {url}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DownloadError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError","title":"DecryptError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised when firmware decryption fails.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class DecryptError(FUSError):\n    \"\"\"Raised when firmware decryption fails.\"\"\"\n\n    # Error subtypes with built-in messages\n    class DeviceIdRequired(Exception):\n        \"\"\"Device ID required for ENC4 decryption.\"\"\"\n\n        def __init__(self):\n            super().__init__(\n                \"Device ID (IMEI or Serial) required for ENC4 key (Samsung requirement)\"\n            )\n\n    class InvalidBlockSize(Exception):\n        \"\"\"Invalid encrypted file block size.\"\"\"\n\n        def __init__(self, size: int = 0):\n            msg = \"Invalid input block size (not multiple of 16)\"\n            if size:\n                msg += f\": {size} bytes\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.DeviceIdRequired","title":"DeviceIdRequired","text":"<p>               Bases: <code>Exception</code></p> <p>Device ID required for ENC4 decryption.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class DeviceIdRequired(Exception):\n    \"\"\"Device ID required for ENC4 decryption.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            \"Device ID (IMEI or Serial) required for ENC4 key (Samsung requirement)\"\n        )\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.InvalidBlockSize","title":"InvalidBlockSize","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid encrypted file block size.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class InvalidBlockSize(Exception):\n    \"\"\"Invalid encrypted file block size.\"\"\"\n\n    def __init__(self, size: int = 0):\n        msg = \"Invalid input block size (not multiple of 16)\"\n        if size:\n            msg += f\": {size} bytes\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DecryptError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DeviceIdError","title":"DeviceIdError","text":"<p>               Bases: <code>FUSError</code></p> <p>Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class DeviceIdError(FUSError):\n    \"\"\"Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.\"\"\"\n\n    # Error subtypes with built-in messages\n    class InvalidTAC(Exception):\n        \"\"\"TAC validation failed.\"\"\"\n\n        def __init__(self, tac: str = \"\"):\n            msg = \"TAC must have at least 8 digits\"\n            if tac:\n                msg += f\" (got: {tac})\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DeviceIdError.InvalidTAC","title":"InvalidTAC","text":"<p>               Bases: <code>Exception</code></p> <p>TAC validation failed.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class InvalidTAC(Exception):\n    \"\"\"TAC validation failed.\"\"\"\n\n    def __init__(self, tac: str = \"\"):\n        msg = \"TAC must have at least 8 digits\"\n        if tac:\n            msg += f\" (got: {tac})\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.DeviceIdError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available for the specified model/region.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available for the specified model/region.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAError","title":"FOTAError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for FOTA endpoint errors with optional predefined messages.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class FOTAError(Exception):\n    \"\"\"Base class for FOTA endpoint errors with optional predefined messages.\"\"\"\n\n    # Error subtypes with built-in messages\n    class ModelOrRegionNotFound(Exception):\n        \"\"\"Model or region not found (HTTP 403).\"\"\"\n\n        def __init__(self, model: str = \"\", region: str = \"\"):\n            msg = \"Model or region not found (403)\"\n            if model or region:\n                msg += f\": {model}/{region}\"\n            super().__init__(msg)\n\n    class NoFirmware(Exception):\n        \"\"\"No firmware available in FOTA response.\"\"\"\n\n        def __init__(self, model: str = \"\", region: str = \"\"):\n            msg = \"No latest firmware available\"\n            if model or region:\n                msg += f\" for {model}/{region}\"\n            super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAError.ModelOrRegionNotFound","title":"ModelOrRegionNotFound","text":"<p>               Bases: <code>Exception</code></p> <p>Model or region not found (HTTP 403).</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class ModelOrRegionNotFound(Exception):\n    \"\"\"Model or region not found (HTTP 403).\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"Model or region not found (403)\"\n        if model or region:\n            msg += f\": {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available in FOTA response.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available in FOTA response.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAParsingError","title":"FOTAParsingError","text":"<p>               Bases: <code>FOTAError</code></p> <p>Raised when FOTA XML response parsing fails.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The XML field that failed to parse.</p> <code>''</code> <code>model</code> <code>str</code> <p>Optional device model for context.</p> <code>''</code> <code>region</code> <code>str</code> <p>Optional region code for context.</p> <code>''</code> Source code in <code>fus\\errors.py</code> Python<pre><code>class FOTAParsingError(FOTAError):\n    \"\"\"Raised when FOTA XML response parsing fails.\n\n    Args:\n        field: The XML field that failed to parse.\n        model: Optional device model for context.\n        region: Optional region code for context.\n    \"\"\"\n\n    def __init__(self, field: str = \"\", model: str = \"\", region: str = \"\"):\n        msg = \"Failed to parse FOTA response\"\n        if field:\n            msg += f\": missing or invalid '{field}' field\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAParsingError.ModelOrRegionNotFound","title":"ModelOrRegionNotFound","text":"<p>               Bases: <code>Exception</code></p> <p>Model or region not found (HTTP 403).</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class ModelOrRegionNotFound(Exception):\n    \"\"\"Model or region not found (HTTP 403).\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"Model or region not found (403)\"\n        if model or region:\n            msg += f\": {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.errors/#fus.errors.FOTAParsingError.NoFirmware","title":"NoFirmware","text":"<p>               Bases: <code>Exception</code></p> <p>No firmware available in FOTA response.</p> Source code in <code>fus\\errors.py</code> Python<pre><code>class NoFirmware(Exception):\n    \"\"\"No firmware available in FOTA response.\"\"\"\n\n    def __init__(self, model: str = \"\", region: str = \"\"):\n        msg = \"No latest firmware available\"\n        if model or region:\n            msg += f\" for {model}/{region}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api/fus.firmware/","title":"Package API <code>fus.firmware</code>","text":""},{"location":"api/fus.firmware/#fus.firmware","title":"fus.firmware","text":"<p>Firmware parsing and FOTA helpers for Samsung FUS.</p> <p>Provides utilities to normalize firmware version codes, parse PDA strings into meaningful fields (bootloader type, year, month, iteration), format human-readable info and fetch the latest firmware version from the FOTA endpoint.</p> <p>Functions: - normalize_vercode: Normalize a version code to a 4-part representation. - _read_firmware: Extract structured fields from a PDA/firmware string. - read_firmware_info: Return parsed firmware fields as a dictionary. - format_firmware_info: Produce a human-readable summary. - get_latest_version: Query the FOTA service for the latest version.</p>"},{"location":"api/fus.firmware/#fus.firmware.normalize_vercode","title":"normalize_vercode","text":"Python<pre><code>normalize_vercode(vercode)\n</code></pre> <p>Normalize a 3- or 4-part firmware version code to exactly 4 parts.</p> <p>Parameters:</p> Name Type Description Default <code>vercode</code> <code>str</code> <p>Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A normalized 4-part version string separated by '/'.</p> Source code in <code>fus\\firmware.py</code> Python<pre><code>def normalize_vercode(vercode: str) -&gt; str:\n    \"\"\"\n    Normalize a 3- or 4-part firmware version code to exactly 4 parts.\n\n    Args:\n        vercode: Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".\n\n    Returns:\n        A normalized 4-part version string separated by '/'.\n    \"\"\"\n    parts = vercode.split(\"/\")\n    if len(parts) == 3:\n        parts.append(parts[0])\n    if parts[2] == \"\":\n        parts[2] = parts[0]\n    return \"/\".join(parts)\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.read_firmware_info","title":"read_firmware_info","text":"Python<pre><code>read_firmware_info(firmware)\n</code></pre> <p>Return parsed firmware information as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: - \"bl\": bootloader type or None - \"date\": formatted \"YYYY.MM\" string - \"it\": iteration string \"major.minor\"</p> Source code in <code>fus\\firmware.py</code> Python<pre><code>def read_firmware_info(firmware: str) -&gt; dict:\n    \"\"\"\n    Return parsed firmware information as a dictionary.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        Dictionary with keys:\n            - \"bl\": bootloader type or None\n            - \"date\": formatted \"YYYY.MM\" string\n            - \"it\": iteration string \"major.minor\"\n    \"\"\"\n    ff = _read_firmware(firmware)\n    return {\"bl\": ff[0], \"date\": f\"{ff[2]}.{ff[3]+1:02d}\", \"it\": f\"{ff[1]}.{ff[4]}\"}\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.format_firmware_info","title":"format_firmware_info","text":"Python<pre><code>format_firmware_info(firmware)\n</code></pre> <p>Produce a human-readable summary of firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A multi-line string with normalized firmware, bootloader (if any),</p> <code>str</code> <p>date (YYYY.MM) and version iteration. If parsing fails, returns an</p> <code>str</code> <p>explanatory message containing the original input.</p> Source code in <code>fus\\firmware.py</code> Python<pre><code>def format_firmware_info(firmware: str) -&gt; str:\n    \"\"\"\n    Produce a human-readable summary of firmware information.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        A multi-line string with normalized firmware, bootloader (if any),\n        date (YYYY.MM) and version iteration. If parsing fails, returns an\n        explanatory message containing the original input.\n    \"\"\"\n    try:\n        info = read_firmware_info(firmware)\n        norm_fw = normalize_vercode(firmware)\n\n        result = f\"Firmware: {norm_fw}\\n\"\n        if info[\"bl\"]:\n            result += f\"Bootloader type: {info['bl']}\\n\"\n        result += f\"Date: {info['date']} (YYYY.MM)\\n\"\n        result += f\"Version iteration: {info['it']}\"\n\n        return result\n    except ValueError as ex:\n        raise FOTAParsingError(field=\"firmware\") from ex\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.get_latest_version","title":"get_latest_version","text":"Python<pre><code>get_latest_version(model, region)\n</code></pre> <p>Query the FOTA endpoint and return the latest firmware version code.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier (e.g. \"SM-G900F\").</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized version code string.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>If the endpoint returns 403 or other domain-specific errors.</p> <code>HTTPError</code> <p>For other non-success HTTP responses.</p> Source code in <code>fus\\firmware.py</code> Python<pre><code>def get_latest_version(model: str, region: str) -&gt; str:\n    \"\"\"\n    Query the FOTA endpoint and return the latest firmware version code.\n\n    Args:\n        model: Device model identifier (e.g. \"SM-G900F\").\n        region: CSC/region code.\n\n    Returns:\n        Normalized version code string.\n\n    Raises:\n        FUSError: If the endpoint returns 403 or other domain-specific errors.\n        requests.exceptions.HTTPError: For other non-success HTTP responses.\n    \"\"\"\n    # Use the request_timeout from DEFAULT_CONFIG (FUSConfig), fallback to 30 if not present.\n    if hasattr(DEFAULT_CONFIG, \"request_timeout\"):\n        timeout = DEFAULT_CONFIG.request_timeout\n    else:\n        timeout = 30\n    req = requests.get(\n        \"https://fota-cloud-dn.ospserver.net/firmware/\" + region + \"/\" + model + \"/version.xml\",\n        headers={'User-Agent': 'curl/7.87.0'},\n        timeout=timeout,\n    )\n    if req.status_code == 403:\n        raise FOTAError.ModelOrRegionNotFound(model, region)\n    req.raise_for_status()\n    root = ET.fromstring(req.text)\n    latest = root.find(\"./firmware/version/latest\").text  # type: ignore\n    if latest is None:\n        raise FOTAError.NoFirmware(model, region)\n    return normalize_vercode(latest)\n</code></pre>"},{"location":"api/fus.messages/","title":"Package API <code>fus.messages</code>","text":""},{"location":"api/fus.messages/#fus.messages","title":"fus.messages","text":"<p>FUS XML message builders.</p> <p>Provides helpers to construct XML payloads used by the FUS protocol (inform/init). These builders return raw XML bytes ready to be posted to the FUS endpoints.</p>"},{"location":"api/fus.messages/#fus.messages.build_binary_inform","title":"build_binary_inform","text":"Python<pre><code>build_binary_inform(fwv, model, region, device_id, nonce)\n</code></pre> <p>Build a BinaryInform request payload.</p> <p>Parameters:</p> Name Type Description Default <code>fwv</code> <code>str</code> <p>Firmware version code.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or Serial number.</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus\\messages.py</code> Python<pre><code>def build_binary_inform(fwv: str, model: str, region: str, device_id: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInform request payload.\n\n    Args:\n        fwv: Firmware version code.\n        model: Device model identifier.\n        region: CSC/region code.\n        device_id: Device IMEI or Serial number.\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    params = {\n        \"ACCESS_MODE\": 2,\n        \"BINARY_NATURE\": 1,\n        \"CLIENT_PRODUCT\": \"Smart Switch\",\n        \"CLIENT_VERSION\": \"4.3.23123_1\",\n        \"DEVICE_IMEI_PUSH\": device_id,\n        \"DEVICE_FW_VERSION\": fwv,\n        \"DEVICE_LOCAL_CODE\": region,\n        \"DEVICE_MODEL_NAME\": model,\n        \"LOGIC_CHECK\": logic_check(fwv, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.messages/#fus.messages.build_binary_init","title":"build_binary_init","text":"Python<pre><code>build_binary_init(filename, nonce)\n</code></pre> <p>Build a BinaryInitForMass request payload.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Firmware file name (including extension).</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus\\messages.py</code> Python<pre><code>def build_binary_init(filename: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInitForMass request payload.\n\n    Args:\n        filename: Firmware file name (including extension).\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    checkinp = filename.split(\".\")[0][-16:]\n    params = {\n        \"BINARY_FILE_NAME\": filename,\n        \"LOGIC_CHECK\": logic_check(checkinp, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.responses/","title":"Package API <code>fus.responses</code>","text":""},{"location":"api/fus.responses/#fus.responses","title":"fus.responses","text":"<p>FUS inform response parsing helpers.</p> <p>Provides a dataclass and parser to extract firmware-related metadata from a FUS BinaryInform XML response.</p> <p>Functions: - parse_inform: parse BinaryInform response into an InformInfo dataclass.</p>"},{"location":"api/fus.responses/#fus.responses.InformInfo","title":"InformInfo  <code>dataclass</code>","text":"<p>FUS BinaryInform response data.</p> <p>Dataclass holding parsed metadata from a Samsung FUS BinaryInform XML response. All fields are guaranteed to be present when status is 200.</p> <p>Attributes:</p> Name Type Description <code>latest_fw_version</code> <code>str</code> <p>Latest firmware version string.</p> <code>logic_value_factory</code> <code>str</code> <p>Logic value for ENC4 decryption key derivation.</p> <code>filename</code> <code>str</code> <p>Binary firmware filename on the server.</p> <code>path</code> <code>str</code> <p>Server model path.</p> <code>size_bytes</code> <code>int</code> <p>Firmware file size in bytes.</p> Source code in <code>fus\\responses.py</code> Python<pre><code>@dataclass(frozen=True)\nclass InformInfo:\n    \"\"\"FUS BinaryInform response data.\n\n    Dataclass holding parsed metadata from a Samsung FUS BinaryInform XML response.\n    All fields are guaranteed to be present when status is 200.\n\n    Attributes:\n        latest_fw_version: Latest firmware version string.\n        logic_value_factory: Logic value for ENC4 decryption key derivation.\n        filename: Binary firmware filename on the server.\n        path: Server model path.\n        size_bytes: Firmware file size in bytes.\n    \"\"\"\n\n    latest_fw_version: str\n    logic_value_factory: str\n    filename: str\n    path: str\n    size_bytes: int\n</code></pre>"},{"location":"api/fus.responses/#fus.responses.parse_inform","title":"parse_inform","text":"Python<pre><code>parse_inform(root)\n</code></pre> <p>Parse a BinaryInform XML response into an InformInfo structure.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>Parsed XML root element of the BinaryInform response.</p> required <p>Returns:</p> Name Type Description <code>InformInfo</code> <code>InformInfo</code> <p>Dataclass containing latest firmware version, logic value,         filename, path and size in bytes.</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If the inform response status is not 200 or required fields are missing.</p> Source code in <code>fus\\responses.py</code> Python<pre><code>def parse_inform(root: ET.Element) -&gt; InformInfo:\n    \"\"\"\n    Parse a BinaryInform XML response into an InformInfo structure.\n\n    Args:\n        root: Parsed XML root element of the BinaryInform response.\n\n    Returns:\n        InformInfo: Dataclass containing latest firmware version, logic value,\n                    filename, path and size in bytes.\n\n    Raises:\n        InformError: If the inform response status is not 200 or required fields are missing.\n    \"\"\"\n    status_elem = root.find(\"./FUSBody/Results/Status\")\n    if status_elem is None or status_elem.text is None:\n        raise InformError.MissingStatus()\n\n    status = int(status_elem.text)\n    if status != 200:\n        raise InformError.BadStatus(status)\n\n    # Extract required fields - raise InformError if any are missing\n    latest = root.findtext(\"./FUSBody/Results/LATEST_FW_VERSION/Data\")\n    if not latest:\n        raise InformError.MissingField(\"LATEST_FW_VERSION\")\n\n    logic = root.findtext(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\")\n    if not logic:\n        raise InformError.MissingField(\"LOGIC_VALUE_FACTORY\")\n\n    filename_elem = root.find(\"./FUSBody/Put/BINARY_NAME/Data\")\n    if filename_elem is None or not filename_elem.text:\n        raise InformError.MissingField(\"BINARY_NAME\")\n    filename = filename_elem.text\n\n    size_elem = root.find(\"./FUSBody/Put/BINARY_BYTE_SIZE/Data\")\n    if size_elem is None or not size_elem.text:\n        raise InformError.MissingField(\"BINARY_BYTE_SIZE\")\n    size = int(size_elem.text)\n\n    path = root.findtext(\"./FUSBody/Put/MODEL_PATH/Data\")\n    if not path:\n        raise InformError.MissingField(\"MODEL_PATH\")\n\n    return InformInfo(\n        latest_fw_version=latest,\n        logic_value_factory=logic,\n        filename=filename,\n        path=path,\n        size_bytes=size,\n    )\n</code></pre>"},{"location":"database/schema/","title":"Database Schema","text":"<p>This document describes the database schema used by nanosamfw for tracking firmware in the repository and IMEI operations.</p>"},{"location":"database/schema/#overview","title":"Overview","text":"<p>The application uses SQLite for local data persistence with two main tables:</p> <ul> <li>firmware - Firmware repository with metadata from FUS inform responses</li> <li>imei_log - Logs IMEI-based firmware queries and upgrade operations</li> </ul>"},{"location":"database/schema/#tables","title":"Tables","text":""},{"location":"database/schema/#firmware","title":"firmware","text":"<p>Firmware repository storing one record per firmware version with all metadata from Samsung FUS servers.</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>version_code</code> TEXT NOT NULL, UNIQUE Firmware version identifier (4-part format: AAA/BBB/CCC/DDD) <code>filename</code> TEXT NOT NULL Binary firmware filename from FUS server <code>path</code> TEXT NOT NULL Server model path from FUS inform response <code>size_bytes</code> INTEGER NOT NULL File size in bytes <code>logic_value_factory</code> TEXT NOT NULL Logic value for ENC4 decryption key derivation <code>latest_fw_version</code> TEXT NOT NULL Latest firmware version from inform response <code>encrypted_file_path</code> TEXT NOT NULL Absolute path to encrypted (.enc4) file on disk <code>decrypted_file_path</code> TEXT - Absolute path to decrypted file, or NULL if not decrypted <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of creation <code>updated_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of last update <p>Unique Constraint: <code>version_code</code> (one record per firmware version)</p> <p>Check Constraint: <code>version_code</code> must have exactly 3 slashes (4-part format)</p>"},{"location":"database/schema/#indexes","title":"Indexes","text":"<ul> <li><code>idx_firmware_version</code> - Index on <code>version_code</code> for fast lookups</li> <li><code>idx_firmware_filename</code> - Index on <code>filename</code> for search by filename</li> </ul>"},{"location":"database/schema/#triggers","title":"Triggers","text":"<ul> <li><code>trg_firmware_updated_at</code> - Automatically updates <code>updated_at</code> timestamp on row updates</li> </ul>"},{"location":"database/schema/#imei_log","title":"imei_log","text":"<p>Logs IMEI-based firmware queries with status tracking. Each device detection results in two log entries: 1. Initial FOTA query (status_fus=\"unknown\") 2. After firmware obtained from FUS or cache (status_fus=\"ok\")</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>imei</code> TEXT NOT NULL Device IMEI number <code>model</code> TEXT NOT NULL Device model identifier <code>csc</code> TEXT NOT NULL, CHECK length Country Specific Code (3-5 chars, supports multi-CSC like EUX/FTM) <code>version_code</code> TEXT NOT NULL, CHECK format Firmware version from FOTA in AAA/BBB/CCC/DDD format <code>status_fus</code> TEXT NOT NULL, DEFAULT 'unknown' FUS operation status (unknown=FOTA only, ok=firmware obtained, error/denied/unauthorized/throttled=FUS errors) <code>status_upgrade</code> TEXT NOT NULL, DEFAULT 'unknown' Reserved for future firmware flashing operations (currently always 'unknown') <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of log entry creation <code>upgrade_at</code> TEXT - Reserved for future firmware flashing timestamp (currently always NULL) <p>Constraints:</p> <ul> <li><code>status_fus</code> must be one of: <code>ok</code>, <code>error</code>, <code>denied</code>, <code>unauthorized</code>, <code>throttled</code>, <code>unknown</code></li> <li><code>status_upgrade</code> must be one of: <code>queued</code>, <code>in_progress</code>, <code>ok</code>, <code>failed</code>, <code>skipped</code>, <code>unknown</code></li> <li><code>version_code</code> must contain exactly 3 forward slashes (AAA/BBB/CCC/DDD format)</li> <li><code>csc</code> length must be between 3 and 5 characters</li> </ul> <p>Status Flow: Text Only<pre><code>Device Detected \u2192 check_and_prepare_firmware()\n  \u251c\u2500 Log #1: status_fus=\"unknown\" (FOTA queried, FUS not called yet)\n  \u2514\u2500 Check firmware table cache\n\nFirmware Obtained \u2192 download_and_decrypt()\n  \u2514\u2500 Log #2: status_fus=\"ok\" (firmware downloaded or retrieved from cache)\n</code></pre></p>"},{"location":"database/schema/#indexes_1","title":"Indexes","text":"<ul> <li><code>idx_imei_log__imei_created</code> - Composite index on <code>(imei, created_at DESC)</code> for IMEI history queries</li> <li><code>idx_imei_log__model_csc_created</code> - Composite index on <code>(model, csc, created_at DESC)</code> for device queries</li> <li><code>idx_imei_log__model_csc_version</code> - Composite index on <code>(model, csc, version_code)</code> for version lookups</li> <li><code>idx_imei_log__created_at</code> - Index on <code>created_at</code> for chronological queries</li> <li><code>idx_imei_log__upgrade_at</code> - Index on <code>upgrade_at</code> for upgrade operation queries</li> </ul>"},{"location":"database/schema/#sql-schema-files","title":"SQL Schema Files","text":"<p>The schema definitions are maintained in the following source files:</p> <ul> <li><code>download/sql/download.sql</code> - Downloads table schema</li> <li><code>download/sql/imei_log.sql</code> - IMEI log table schema</li> </ul>"},{"location":"database/schema/#usage","title":"Usage","text":"<p>The database is managed through the repository pattern:</p> <ul> <li>download.firmware_repository - Firmware repository operations</li> <li>download.imei_repository - IMEI log operations</li> <li>download.service - High-level service functions</li> <li>download.db - Database connection management</li> </ul>"}]}