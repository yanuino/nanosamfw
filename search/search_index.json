{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"Text Only<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api/download.config/","title":"Package API <code>download.config</code>","text":""},{"location":"api/download.config/#download.config","title":"download.config","text":"<p>Download module configuration.</p> <p>This module provides configuration for download paths and directories used throughout the download module.</p>"},{"location":"api/download.config/#download.config.PATHS","title":"PATHS  <code>module-attribute</code>","text":"Python<pre><code>PATHS = _resolve_paths()\n</code></pre> <p>Global paths configuration instance.</p> <p>This constant provides access to all configured paths used by the download module.</p>"},{"location":"api/download.config/#download.config.Paths","title":"Paths  <code>dataclass</code>","text":"<p>Configuration paths for download operations.</p> <p>This dataclass holds all filesystem paths used by the download module, including the data directory, database path, and downloads directory.</p> <p>Attributes:</p> Name Type Description <code>data_dir</code> <code>Path</code> <p>Root directory for application data storage.</p> <code>db_path</code> <code>Path</code> <p>Path to the SQLite database file.</p> <code>downloads_dir</code> <code>Path</code> <p>Directory where firmware files are downloaded.</p> Source code in <code>download/config.py</code> Python<pre><code>@dataclass(frozen=True)\nclass Paths:\n    \"\"\"Configuration paths for download operations.\n\n    This dataclass holds all filesystem paths used by the download module,\n    including the data directory, database path, and downloads directory.\n\n    Attributes:\n        data_dir: Root directory for application data storage.\n        db_path: Path to the SQLite database file.\n        downloads_dir: Directory where firmware files are downloaded.\n    \"\"\"\n\n    data_dir: Path\n    db_path: Path\n    downloads_dir: Path\n</code></pre>"},{"location":"api/download.db/","title":"Package API <code>download.db</code>","text":""},{"location":"api/download.db/#download.db","title":"download.db","text":"<p>Database connection and schema management.</p> <p>This module provides database connection utilities, schema initialization, and database health/repair operations for the firmware download system.</p>"},{"location":"api/download.db/#download.db.get_db_path","title":"get_db_path","text":"Python<pre><code>get_db_path()\n</code></pre> <p>Get the path to the SQLite database file.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Absolute path to the database file.</p> Source code in <code>download/db.py</code> Python<pre><code>def get_db_path() -&gt; Path:\n    \"\"\"Get the path to the SQLite database file.\n\n    Returns:\n        Path: Absolute path to the database file.\n    \"\"\"\n    return PATHS.db_path\n</code></pre>"},{"location":"api/download.db/#download.db.connect","title":"connect","text":"Python<pre><code>connect()\n</code></pre> <p>Open a SQLite connection with optimized PRAGMAs.</p> <p>Creates the data directory if it doesn't exist and establishes a database connection with WAL mode, reasonable timeouts, and other performance settings. One connection per thread/process is recommended.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>sqlite3.Connection: Configured database connection with Row factory enabled.</p> Note <p>The connection uses autocommit mode (isolation_level=None), so transactions must be managed explicitly with BEGIN/COMMIT/ROLLBACK.</p> Source code in <code>download/db.py</code> Python<pre><code>def connect() -&gt; sqlite3.Connection:\n    \"\"\"Open a SQLite connection with optimized PRAGMAs.\n\n    Creates the data directory if it doesn't exist and establishes a database\n    connection with WAL mode, reasonable timeouts, and other performance settings.\n    One connection per thread/process is recommended.\n\n    Returns:\n        sqlite3.Connection: Configured database connection with Row factory enabled.\n\n    Note:\n        The connection uses autocommit mode (isolation_level=None), so transactions\n        must be managed explicitly with BEGIN/COMMIT/ROLLBACK.\n    \"\"\"\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    conn = sqlite3.connect(\n        PATHS.db_path,\n        timeout=10.0,\n        isolation_level=None,\n        check_same_thread=False,\n    )\n    conn.row_factory = sqlite3.Row\n    _apply_pragmas(conn)\n    return conn\n</code></pre>"},{"location":"api/download.db/#download.db.init_db","title":"init_db","text":"Python<pre><code>init_db()\n</code></pre> <p>Initialize the database schema.</p> <p>Creates the data directory and downloads table if they don't exist. The operation is performed within a transaction that will rollback on any error.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If schema creation fails, the exception is re-raised after rollback.</p> Source code in <code>download/db.py</code> Python<pre><code>def init_db() -&gt; None:\n    \"\"\"Initialize the database schema.\n\n    Creates the data directory and downloads table if they don't exist.\n    The operation is performed within a transaction that will rollback\n    on any error.\n\n    Raises:\n        Exception: If schema creation fails, the exception is re-raised after rollback.\n    \"\"\"\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.executescript(SCHEMA_SQL)\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.db/#download.db.is_healthy","title":"is_healthy","text":"Python<pre><code>is_healthy()\n</code></pre> <p>Check database integrity.</p> <p>Runs SQLite's integrity_check pragma to verify the database is not corrupted.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if database passes integrity check, False otherwise.</p> Source code in <code>download/db.py</code> Python<pre><code>def is_healthy() -&gt; bool:\n    \"\"\"Check database integrity.\n\n    Runs SQLite's integrity_check pragma to verify the database is not corrupted.\n\n    Returns:\n        bool: True if database passes integrity check, False otherwise.\n    \"\"\"\n    try:\n        with sqlite3.connect(PATHS.db_path) as conn:\n            cur = conn.cursor()\n            cur.execute(\"PRAGMA integrity_check(1);\")\n            row = cur.fetchone()\n            cur.close()\n            return row is not None and row[0] == \"ok\"\n    except sqlite3.DatabaseError:\n        return False\n</code></pre>"},{"location":"api/download.db/#download.db.repair_db","title":"repair_db","text":"Python<pre><code>repair_db()\n</code></pre> <p>Attempt to repair a corrupted SQLite database.</p> <p>If the database fails the integrity check, this function performs a dump to a temporary SQL file, deletes the corrupted database, and restores from the dump into a new database file.</p> The process <ol> <li>Check if database is healthy (returns immediately if healthy)</li> <li>Dump database to temporary SQL file</li> <li>Delete the corrupted database file</li> <li>Restore from the SQL dump</li> <li>Clean up temporary dump file</li> </ol> Source code in <code>download/db.py</code> Python<pre><code>def repair_db() -&gt; None:\n    \"\"\"Attempt to repair a corrupted SQLite database.\n\n    If the database fails the integrity check, this function performs a dump\n    to a temporary SQL file, deletes the corrupted database, and restores\n    from the dump into a new database file.\n\n    The process:\n        1. Check if database is healthy (returns immediately if healthy)\n        2. Dump database to temporary SQL file\n        3. Delete the corrupted database file\n        4. Restore from the SQL dump\n        5. Clean up temporary dump file\n    \"\"\"\n    if is_healthy():\n        return\n\n    PATHS.data_dir.mkdir(parents=True, exist_ok=True)\n    temp_dump_path = PATHS.data_dir / \"temp_dump.sql\"\n    _dump_db(temp_dump_path)\n\n    try:\n        PATHS.db_path.unlink()\n    except FileNotFoundError:\n        pass\n\n    _restore_db(temp_dump_path)\n\n    try:\n        temp_dump_path.unlink()\n    except FileNotFoundError:\n        pass\n</code></pre>"},{"location":"api/download.imei_repository/","title":"Package API <code>download.imei_repository</code>","text":""},{"location":"api/download.imei_repository/#download.imei_repository","title":"download.imei_repository","text":"<p>Repository layer for IMEI event logging.</p> <p>This module provides data access functions for tracking IMEI-based firmware queries and upgrade operations. Events are logged with FUS status and upgrade status for traceability.</p>"},{"location":"api/download.imei_repository/#download.imei_repository.IMEIEvent","title":"IMEIEvent  <code>dataclass</code>","text":"<p>IMEI event record.</p> <p>Represents a logged IMEI-based firmware query or upgrade operation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>Database record ID, or None for new records.</p> <code>imei</code> <code>str</code> <p>Device IMEI number.</p> <code>model</code> <code>str</code> <p>Device model identifier.</p> <code>csc</code> <code>str</code> <p>Country Specific Code.</p> <code>version_code</code> <code>str</code> <p>Firmware version identifier (format: AAA/BBB/CCC/DDD).</p> <code>status_fus</code> <code>str</code> <p>FUS query status (ok, error, denied, unauthorized, throttled, unknown).</p> <code>status_upgrade</code> <code>str</code> <p>Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown).</p> <code>created_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of event creation, or None.</p> <code>upgrade_at</code> <code>str | None</code> <p>ISO 8601 UTC timestamp of upgrade operation, or None.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>@dataclass\nclass IMEIEvent:\n    \"\"\"IMEI event record.\n\n    Represents a logged IMEI-based firmware query or upgrade operation.\n\n    Attributes:\n        id: Database record ID, or None for new records.\n        imei: Device IMEI number.\n        model: Device model identifier.\n        csc: Country Specific Code.\n        version_code: Firmware version identifier (format: AAA/BBB/CCC/DDD).\n        status_fus: FUS query status (ok, error, denied, unauthorized, throttled, unknown).\n        status_upgrade: Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown).\n        created_at: ISO 8601 UTC timestamp of event creation, or None.\n        upgrade_at: ISO 8601 UTC timestamp of upgrade operation, or None.\n    \"\"\"\n\n    id: int | None\n    imei: str\n    model: str\n    csc: str\n    version_code: str\n    status_fus: str = \"unknown\"  # ok/error/denied/unauthorized/throttled/unknown\n    status_upgrade: str = \"unknown\"  # queued/in_progress/ok/failed/skipped/unknown\n    created_at: str | None = None  # ISO-8601 UTC\n    upgrade_at: str | None = None  # ISO-8601 UTC\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.add_imei_event","title":"add_imei_event","text":"Python<pre><code>add_imei_event(\n    *,\n    imei,\n    model,\n    csc,\n    version_code,\n    status_fus=\"ok\",\n    status_upgrade=\"unknown\",\n    upgrade_at=None\n)\n</code></pre> <p>Insert a new IMEI event record.</p> <p>Creates a new IMEI event log entry. No uniqueness constraints are enforced; all events are kept for full traceability.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>Device IMEI number.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>version_code</code> <code>str</code> <p>Firmware version identifier (format: AAA/BBB/CCC/DDD).</p> required <code>status_fus</code> <code>str</code> <p>FUS query status. Defaults to \"ok\".</p> <code>'ok'</code> <code>status_upgrade</code> <code>str</code> <p>Upgrade operation status. Defaults to \"unknown\".</p> <code>'unknown'</code> <code>upgrade_at</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp of upgrade operation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Auto-incremented database ID of the inserted record.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def add_imei_event(\n    *,\n    imei: str,\n    model: str,\n    csc: str,\n    version_code: str,\n    status_fus: str = \"ok\",\n    status_upgrade: str = \"unknown\",\n    upgrade_at: str | None = None,\n) -&gt; int:\n    \"\"\"Insert a new IMEI event record.\n\n    Creates a new IMEI event log entry. No uniqueness constraints are enforced;\n    all events are kept for full traceability.\n\n    Args:\n        imei: Device IMEI number.\n        model: Device model identifier.\n        csc: Country Specific Code.\n        version_code: Firmware version identifier (format: AAA/BBB/CCC/DDD).\n        status_fus: FUS query status. Defaults to \"ok\".\n        status_upgrade: Upgrade operation status. Defaults to \"unknown\".\n        upgrade_at: Optional ISO 8601 UTC timestamp of upgrade operation.\n\n    Returns:\n        int: Auto-incremented database ID of the inserted record.\n    \"\"\"\n    sql = \"\"\"\n    INSERT INTO imei_log\n        (imei, model, csc, version_code, status_fus, status_upgrade, created_at, upgrade_at)\n    VALUES\n        (:imei, :model, :csc, :version_code, :status_fus, :status_upgrade, :created_at, :upgrade_at);\n    \"\"\"\n    params = {\n        \"imei\": imei,\n        \"model\": model,\n        \"csc\": csc,\n        \"version_code\": version_code,\n        \"status_fus\": status_fus,\n        \"status_upgrade\": status_upgrade,\n        \"created_at\": _iso_now(),\n        \"upgrade_at\": upgrade_at,\n    }\n    with connect() as conn:\n        cur = conn.execute(sql, params)\n        return int(cur.lastrowid)  # type: ignore\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.set_upgrade_status","title":"set_upgrade_status","text":"Python<pre><code>set_upgrade_status(id_, status_upgrade, upgrade_at=None)\n</code></pre> <p>Update the upgrade status for an existing event.</p> <p>Updates the upgrade status and timestamp for a previously logged IMEI event.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int</code> <p>Database ID of the event to update.</p> required <code>status_upgrade</code> <code>str</code> <p>New upgrade status (e.g., ok, failed, skipped).</p> required <code>upgrade_at</code> <code>Optional[str]</code> <p>Optional ISO 8601 UTC timestamp. If None, current time is used.</p> <code>None</code> Source code in <code>download/imei_repository.py</code> Python<pre><code>def set_upgrade_status(id_: int, status_upgrade: str, upgrade_at: Optional[str] = None) -&gt; None:\n    \"\"\"Update the upgrade status for an existing event.\n\n    Updates the upgrade status and timestamp for a previously logged IMEI event.\n\n    Args:\n        id_: Database ID of the event to update.\n        status_upgrade: New upgrade status (e.g., ok, failed, skipped).\n        upgrade_at: Optional ISO 8601 UTC timestamp. If None, current time is used.\n    \"\"\"\n    if upgrade_at is None:\n        upgrade_at = _iso_now()\n    sql = \"\"\"\n    UPDATE imei_log\n       SET status_upgrade = :status_upgrade,\n           upgrade_at = :upgrade_at\n     WHERE id = :id\n    \"\"\"\n    with connect() as conn:\n        conn.execute(sql, {\"status_upgrade\": status_upgrade, \"upgrade_at\": upgrade_at, \"id\": id_})\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_by_imei","title":"list_by_imei","text":"Python<pre><code>list_by_imei(imei, *, limit=200, offset=0)\n</code></pre> <p>List IMEI events for a specific IMEI number.</p> <p>Retrieves event records for a given IMEI, ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>Device IMEI number to search for.</p> required <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 200.</p> <code>200</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the IMEI, ordered by created_at descending.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def list_by_imei(imei: str, *, limit: int = 200, offset: int = 0) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events for a specific IMEI number.\n\n    Retrieves event records for a given IMEI, ordered by creation date (newest first).\n\n    Args:\n        imei: Device IMEI number to search for.\n        limit: Maximum number of records to return. Defaults to 200.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the IMEI, ordered by created_at descending.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE imei = ?\n     ORDER BY created_at DESC\n     LIMIT ? OFFSET ?;\n    \"\"\"\n    with connect() as conn:\n        for row in conn.execute(sql, (imei, limit, offset)):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_by_model_csc","title":"list_by_model_csc","text":"Python<pre><code>list_by_model_csc(\n    model,\n    csc,\n    *,\n    since=None,\n    until=None,\n    limit=200,\n    offset=0\n)\n</code></pre> <p>List IMEI events for a specific model and CSC combination.</p> <p>Retrieves event records filtered by model and CSC, with optional date range filtering. Results are ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum created_at filter.</p> <code>None</code> <code>until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum created_at filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 200.</p> <code>200</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the filters, ordered by created_at descending.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def list_by_model_csc(\n    model: str,\n    csc: str,\n    *,\n    since: str | None = None,\n    until: str | None = None,\n    limit: int = 200,\n    offset: int = 0,\n) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events for a specific model and CSC combination.\n\n    Retrieves event records filtered by model and CSC, with optional date range\n    filtering. Results are ordered by creation date (newest first).\n\n    Args:\n        model: Device model identifier.\n        csc: Country Specific Code.\n        since: Optional ISO 8601 UTC timestamp for minimum created_at filter.\n        until: Optional ISO 8601 UTC timestamp for maximum created_at filter.\n        limit: Maximum number of records to return. Defaults to 200.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the filters, ordered by created_at descending.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE model = :model AND csc = :csc\n       AND (:since IS NULL OR created_at &gt;= :since)\n       AND (:until IS NULL OR created_at &lt;= :until)\n     ORDER BY created_at DESC\n     LIMIT :limit OFFSET :offset;\n    \"\"\"\n    with connect() as conn:\n        for row in conn.execute(\n            sql,\n            {\n                \"model\": model,\n                \"csc\": csc,\n                \"since\": since,\n                \"until\": until,\n                \"limit\": limit,\n                \"offset\": offset,\n            },\n        ):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.list_between_dates","title":"list_between_dates","text":"Python<pre><code>list_between_dates(\n    *,\n    created_since=None,\n    created_until=None,\n    upgrade_since=None,\n    upgrade_until=None,\n    limit=500,\n    offset=0\n)\n</code></pre> <p>List IMEI events filtered by creation and/or upgrade date ranges.</p> <p>Retrieves event records with flexible date range filtering on both creation and upgrade timestamps. All filters are optional and can be combined.</p> <p>Parameters:</p> Name Type Description Default <code>created_since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum created_at filter.</p> <code>None</code> <code>created_until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum created_at filter.</p> <code>None</code> <code>upgrade_since</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for minimum upgrade_at filter.</p> <code>None</code> <code>upgrade_until</code> <code>str | None</code> <p>Optional ISO 8601 UTC timestamp for maximum upgrade_at filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 500.</p> <code>500</code> <code>offset</code> <code>int</code> <p>Number of records to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Name Type Description <code>IMEIEvent</code> <code>Iterable[IMEIEvent]</code> <p>Event records matching the date filters, ordered by created_at descending.</p> Note <p>Upgrade date filters only match records where upgrade_at is not NULL.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def list_between_dates(\n    *,\n    created_since: str | None = None,\n    created_until: str | None = None,\n    upgrade_since: str | None = None,\n    upgrade_until: str | None = None,\n    limit: int = 500,\n    offset: int = 0,\n) -&gt; Iterable[IMEIEvent]:\n    \"\"\"List IMEI events filtered by creation and/or upgrade date ranges.\n\n    Retrieves event records with flexible date range filtering on both creation\n    and upgrade timestamps. All filters are optional and can be combined.\n\n    Args:\n        created_since: Optional ISO 8601 UTC timestamp for minimum created_at filter.\n        created_until: Optional ISO 8601 UTC timestamp for maximum created_at filter.\n        upgrade_since: Optional ISO 8601 UTC timestamp for minimum upgrade_at filter.\n        upgrade_until: Optional ISO 8601 UTC timestamp for maximum upgrade_at filter.\n        limit: Maximum number of records to return. Defaults to 500.\n        offset: Number of records to skip for pagination. Defaults to 0.\n\n    Yields:\n        IMEIEvent: Event records matching the date filters, ordered by created_at descending.\n\n    Note:\n        Upgrade date filters only match records where upgrade_at is not NULL.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE (:cs IS NULL OR created_at &gt;= :cs)\n       AND (:cu IS NULL OR created_at &lt;= :cu)\n       AND (:us IS NULL OR (upgrade_at IS NOT NULL AND upgrade_at &gt;= :us))\n       AND (:uu IS NULL OR (upgrade_at IS NOT NULL AND upgrade_at &lt;= :uu))\n     ORDER BY created_at DESC\n     LIMIT :limit OFFSET :offset;\n    \"\"\"\n    params = {\n        \"cs\": created_since,\n        \"cu\": created_until,\n        \"us\": upgrade_since,\n        \"uu\": upgrade_until,\n        \"limit\": limit,\n        \"offset\": offset,\n    }\n    with connect() as conn:\n        for row in conn.execute(sql, params):\n            yield IMEIEvent(\n                id=row[\"id\"],\n                imei=row[\"imei\"],\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                status_fus=row[\"status_fus\"],\n                status_upgrade=row[\"status_upgrade\"],\n                created_at=row[\"created_at\"],\n                upgrade_at=row[\"upgrade_at\"],\n            )\n</code></pre>"},{"location":"api/download.imei_repository/#download.imei_repository.last_status_by_imei","title":"last_status_by_imei","text":"Python<pre><code>last_status_by_imei(imei)\n</code></pre> <p>Get the most recent IMEI event for a specific IMEI number.</p> <p>Retrieves the latest event record (by creation date) for the given IMEI.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>Device IMEI number to search for.</p> required <p>Returns:</p> Type Description <code>IMEIEvent | None</code> <p>IMEIEvent if found, None if no events exist for this IMEI.</p> Source code in <code>download/imei_repository.py</code> Python<pre><code>def last_status_by_imei(imei: str) -&gt; IMEIEvent | None:\n    \"\"\"Get the most recent IMEI event for a specific IMEI number.\n\n    Retrieves the latest event record (by creation date) for the given IMEI.\n\n    Args:\n        imei: Device IMEI number to search for.\n\n    Returns:\n        IMEIEvent if found, None if no events exist for this IMEI.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM imei_log\n     WHERE imei = ?\n     ORDER BY created_at DESC\n     LIMIT 1;\n    \"\"\"\n    with connect() as conn:\n        row = conn.execute(sql, (imei,)).fetchone()\n        if not row:\n            return None\n        return IMEIEvent(\n            id=row[\"id\"],\n            imei=row[\"imei\"],\n            model=row[\"model\"],\n            csc=row[\"csc\"],\n            version_code=row[\"version_code\"],\n            status_fus=row[\"status_fus\"],\n            status_upgrade=row[\"status_upgrade\"],\n            created_at=row[\"created_at\"],\n            upgrade_at=row[\"upgrade_at\"],\n        )\n</code></pre>"},{"location":"api/download.repository/","title":"Package API <code>download.repository</code>","text":""},{"location":"api/download.repository/#download.repository","title":"download.repository","text":"<p>Repository layer for firmware download operations.</p> <p>This module provides the data access layer for managing firmware download records in the database using the repository pattern.</p>"},{"location":"api/download.repository/#download.repository.DownloadRecord","title":"DownloadRecord  <code>dataclass</code>","text":"<p>Firmware download record.</p> <p>Represents a firmware download entry with all associated metadata.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Device model identifier (e.g., SM-G998B).</p> <code>csc</code> <code>str</code> <p>Country Specific Code.</p> <code>version_code</code> <code>str</code> <p>Firmware version identifier (format: AAA/BBB/CCC/DDD).</p> <code>encoded_filename</code> <code>str</code> <p>Encoded filename from the FUS service.</p> <code>size_bytes</code> <code>int | None</code> <p>File size in bytes, or None if unknown.</p> <code>status</code> <code>str</code> <p>Download status (e.g., 'done', 'downloading', 'decrypting', 'error').</p> <code>path</code> <code>str | None</code> <p>Absolute filesystem path to the downloaded file, or None if not yet downloaded.</p> Source code in <code>download/repository.py</code> Python<pre><code>@dataclass\nclass DownloadRecord:\n    \"\"\"Firmware download record.\n\n    Represents a firmware download entry with all associated metadata.\n\n    Attributes:\n        model: Device model identifier (e.g., SM-G998B).\n        csc: Country Specific Code.\n        version_code: Firmware version identifier (format: AAA/BBB/CCC/DDD).\n        encoded_filename: Encoded filename from the FUS service.\n        size_bytes: File size in bytes, or None if unknown.\n        status: Download status (e.g., 'done', 'downloading', 'decrypting', 'error').\n        path: Absolute filesystem path to the downloaded file, or None if not yet downloaded.\n    \"\"\"\n\n    model: str\n    csc: str\n    version_code: str\n    encoded_filename: str\n    size_bytes: int | None\n    status: str\n    path: str | None\n</code></pre>"},{"location":"api/download.repository/#download.repository.upsert_download","title":"upsert_download","text":"Python<pre><code>upsert_download(rec)\n</code></pre> <p>Insert or update a firmware download record.</p> <p>Creates a new download record or updates an existing one if a record with the same model, csc, and version_code already exists. The operation is performed within a transaction.</p> <p>Parameters:</p> Name Type Description Default <code>rec</code> <code>DownloadRecord</code> <p>Download record to insert or update.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the database operation fails, the exception is re-raised after rolling back the transaction.</p> Source code in <code>download/repository.py</code> Python<pre><code>def upsert_download(rec: DownloadRecord) -&gt; None:\n    \"\"\"Insert or update a firmware download record.\n\n    Creates a new download record or updates an existing one if a record with\n    the same model, csc, and version_code already exists. The operation is\n    performed within a transaction.\n\n    Args:\n        rec: Download record to insert or update.\n\n    Raises:\n        Exception: If the database operation fails, the exception is re-raised\n            after rolling back the transaction.\n    \"\"\"\n    sql = \"\"\"\n    INSERT INTO downloads (model, csc, version_code,\n                           encoded_filename, size_bytes, status, path)\n    VALUES (:model, :csc, :version_code,\n            :encoded_filename, :size_bytes, :status, :path)\n    ON CONFLICT(model, csc, version_code) DO UPDATE SET\n        encoded_filename=excluded.encoded_filename,\n        size_bytes=excluded.size_bytes,\n        status=excluded.status,\n        path=excluded.path;\n    \"\"\"\n    with connect() as conn:\n        conn.execute(\"BEGIN;\")\n        try:\n            conn.execute(sql, rec.__dict__)\n            conn.execute(\"COMMIT;\")\n        except Exception:\n            conn.execute(\"ROLLBACK;\")\n            raise\n</code></pre>"},{"location":"api/download.repository/#download.repository.find_download","title":"find_download","text":"Python<pre><code>find_download(model, csc, version_code)\n</code></pre> <p>Find a specific firmware download record.</p> <p>Searches for a download record matching the provided model, CSC, and version code.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier to search for.</p> required <code>csc</code> <code>str</code> <p>Country Specific Code to search for.</p> required <code>version_code</code> <code>str</code> <p>Firmware version identifier to search for.</p> required <p>Returns:</p> Type Description <code>Optional[DownloadRecord]</code> <p>DownloadRecord if found, None otherwise.</p> Source code in <code>download/repository.py</code> Python<pre><code>def find_download(model: str, csc: str, version_code: str) -&gt; Optional[DownloadRecord]:\n    \"\"\"Find a specific firmware download record.\n\n    Searches for a download record matching the provided model, CSC, and version code.\n\n    Args:\n        model: Device model identifier to search for.\n        csc: Country Specific Code to search for.\n        version_code: Firmware version identifier to search for.\n\n    Returns:\n        DownloadRecord if found, None otherwise.\n    \"\"\"\n    sql = \"\"\"\n    SELECT * FROM downloads\n    WHERE model=? AND csc=? AND version_code=?;\n    \"\"\"\n    with connect() as conn:\n        row = conn.execute(sql, (model, csc, version_code)).fetchone()\n        if not row:\n            return None\n        return DownloadRecord(\n            model=row[\"model\"],\n            csc=row[\"csc\"],\n            version_code=row[\"version_code\"],\n            encoded_filename=row[\"encoded_filename\"],\n            size_bytes=row[\"size_bytes\"],\n            status=row[\"status\"],\n            path=row[\"path\"],\n        )\n</code></pre>"},{"location":"api/download.repository/#download.repository.list_downloads","title":"list_downloads","text":"Python<pre><code>list_downloads(model=None, csc=None)\n</code></pre> <p>List firmware download records with optional filtering.</p> <p>Retrieves download records from the database, optionally filtered by model and/or CSC. Results are ordered by creation date (newest first).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str | None</code> <p>Optional device model to filter by. If None, all models are included.</p> <code>None</code> <code>csc</code> <code>str | None</code> <p>Optional Country Specific Code to filter by. If None, all CSCs are included.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>DownloadRecord</code> <code>Iterable[DownloadRecord]</code> <p>Download records matching the filter criteria, ordered by creation date in descending order.</p> Source code in <code>download/repository.py</code> Python<pre><code>def list_downloads(model: str | None = None, csc: str | None = None) -&gt; Iterable[DownloadRecord]:\n    \"\"\"List firmware download records with optional filtering.\n\n    Retrieves download records from the database, optionally filtered by model\n    and/or CSC. Results are ordered by creation date (newest first).\n\n    Args:\n        model: Optional device model to filter by. If None, all models are included.\n        csc: Optional Country Specific Code to filter by. If None, all CSCs are included.\n\n    Yields:\n        DownloadRecord: Download records matching the filter criteria, ordered by\n            creation date in descending order.\n    \"\"\"\n    base = \"SELECT * FROM downloads\"\n    params: list[str] = []\n    where = []\n    if model:\n        where.append(\"model=?\")\n        params.append(model)\n    if csc:\n        where.append(\"csc=?\")\n        params.append(csc)\n    if where:\n        base += \" WHERE \" + \" AND \".join(where)\n    base += \" ORDER BY created_at DESC;\"\n    with connect() as conn:\n        for row in conn.execute(base, params):\n            yield DownloadRecord(\n                model=row[\"model\"],\n                csc=row[\"csc\"],\n                version_code=row[\"version_code\"],\n                encoded_filename=row[\"encoded_filename\"],\n                size_bytes=row[\"size_bytes\"],\n                status=row[\"status\"],\n                path=row[\"path\"],\n            )\n</code></pre>"},{"location":"api/download.service/","title":"Package API <code>download.service</code>","text":""},{"location":"api/download.service/#download.service","title":"download.service","text":"<p>Firmware download service.</p> <p>This module provides high-level firmware download functionality including version resolution, FUS protocol handling, file download with resume support, and optional decryption.</p>"},{"location":"api/download.service/#download.service.download_firmware","title":"download_firmware","text":"Python<pre><code>download_firmware(\n    *,\n    model,\n    csc,\n    device_id,\n    version=None,\n    decrypt=True,\n    resume=True,\n    progress_cb=None\n)\n</code></pre> <p>Download and optionally decrypt firmware, persisting metadata to database.</p> <p>This is the main high-level API for firmware downloads. The process follows these steps:</p> <ol> <li>Version resolution (if not provided) via FOTA version.xml</li> <li>INFORM request to get filename and size</li> <li>INIT request with LOGIC_CHECK computed from filename</li> <li>Download binary with HTTP Range support for resume</li> <li>(Optional) Decrypt ENC4 to ZIP format</li> <li>Persist metadata to database via upsert</li> </ol> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier (e.g., SM-G998B).</p> required <code>csc</code> <code>str</code> <p>Country Specific Code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or serial number.</p> required <code>version</code> <code>Optional[str]</code> <p>Optional firmware version (4-part format). If None, latest version is fetched.</p> <code>None</code> <code>decrypt</code> <code>bool</code> <p>If True, decrypt the downloaded file after download.</p> <code>True</code> <code>resume</code> <code>bool</code> <p>If True, resume from partial download if .part file exists.</p> <code>True</code> <code>progress_cb</code> <code>Optional[Callable[[int, Optional[int]], None]]</code> <p>Optional callback function(bytes_processed, expected_size) for progress tracking.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DownloadRecord</code> <code>DownloadRecord</code> <p>Database record containing download metadata and file path.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>If version lookup fails or FUS protocol errors occur.</p> <code>DownloadError</code> <p>If download fails or size verification fails.</p> Note <p>The output directory is organized as downloads/model/csc/ with path separators sanitized to underscores.</p> Source code in <code>download/service.py</code> Python<pre><code>def download_firmware(\n    *,\n    model: str,\n    csc: str,\n    device_id: str,\n    version: Optional[str] = None,\n    decrypt: bool = True,\n    resume: bool = True,\n    progress_cb: Optional[Callable[[int, Optional[int]], None]] = None,\n) -&gt; DownloadRecord:\n    \"\"\"Download and optionally decrypt firmware, persisting metadata to database.\n\n    This is the main high-level API for firmware downloads. The process follows these steps:\n\n    1. Version resolution (if not provided) via FOTA version.xml\n    2. INFORM request to get filename and size\n    3. INIT request with LOGIC_CHECK computed from filename\n    4. Download binary with HTTP Range support for resume\n    5. (Optional) Decrypt ENC4 to ZIP format\n    6. Persist metadata to database via upsert\n\n    Args:\n        model: Device model identifier (e.g., SM-G998B).\n        csc: Country Specific Code.\n        device_id: Device IMEI or serial number.\n        version: Optional firmware version (4-part format). If None, latest version is fetched.\n        decrypt: If True, decrypt the downloaded file after download.\n        resume: If True, resume from partial download if .part file exists.\n        progress_cb: Optional callback function(bytes_processed, expected_size) for progress tracking.\n\n    Returns:\n        DownloadRecord: Database record containing download metadata and file path.\n\n    Raises:\n        FUSError: If version lookup fails or FUS protocol errors occur.\n        DownloadError: If download fails or size verification fails.\n\n    Note:\n        The output directory is organized as downloads/model/csc/ with path separators\n        sanitized to underscores.\n    \"\"\"\n    # 1) Version (4-part)\n    if not version:\n        version = get_latest_version(model, csc)\n    version_norm = normalize_vercode(version)\n\n    # Output directory (by model/CSC)\n    out_dir = _safe_dir(model, csc)\n\n    # 2) INFORM\n    client = FUSClient()\n    inform_payload = build_binary_inform(version_norm, model, csc, device_id, client.nonce)\n    inform_root = client.inform(inform_payload)\n\n    filename, expected_size = _extract_filename_and_size(inform_root)\n\n    # 3) INIT (LOGIC_CHECK computed from filename - last 16 chars of base-name)\n    init_payload = build_binary_init(filename, client.nonce)\n    client.init(init_payload)\n\n    # 4) DOWNLOAD binary enc4 file (encoded_filename)\n    enc_path = out_dir / filename\n    enc_final = _download_to_file(\n        client=client,\n        filename=filename,\n        out_path=enc_path,\n        expected_size=expected_size,\n        resume=resume,\n        progress_cb=progress_cb,\n    )\n\n    # 5) (Optional) DECRYPT ENC4 -&gt; ZIP\n    dec_path: Optional[Path] = None\n    if decrypt:\n        key = get_v4_key(version_norm, model, csc, device_id, client)\n        dec_path = enc_final.with_suffix(\"\")  # Remove .enc4 -&gt; .zip (or actual suffix)\n        decrypt_file(\n            str(enc_final),\n            str(dec_path),\n            enc_ver=4,\n            key=key,  # type: ignore\n            progress_cb=progress_cb,\n        )\n\n    # 6) UPSERT to database\n    size_bytes = enc_final.stat().st_size if enc_final.exists() else None\n    preferred_path = dec_path if dec_path else enc_final\n\n    rec = DownloadRecord(\n        model=model,\n        csc=csc,\n        version_code=version_norm,\n        encoded_filename=filename,\n        size_bytes=size_bytes,\n        status=\"done\",\n        path=str(preferred_path.resolve()),\n    )\n    upsert_download(rec)\n    return rec\n</code></pre>"},{"location":"api/fus.client/","title":"Package API <code>fus.client</code>","text":""},{"location":"api/fus.client/#fus.client","title":"fus.client","text":""},{"location":"api/fus.client/#fus.client.FUSClient","title":"FUSClient","text":"<p>Samsung Firmware Update Service (FUS) client implementation.</p> <p>Handles core FUS protocol operations including NONCE rotation, signature generation, and session management.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>FUSConfig</code> <p>FUS configuration settings. Defaults to DEFAULT_CONFIG.</p> <code>DEFAULT_CONFIG</code> <code>session</code> <code>Optional[Session]</code> <p>Optional requests.Session for connection reuse.</p> <code>None</code> Source code in <code>fus/client.py</code> Python<pre><code>class FUSClient:\n    \"\"\"\n    Samsung Firmware Update Service (FUS) client implementation.\n\n    Handles core FUS protocol operations including NONCE rotation,\n    signature generation, and session management.\n\n    Args:\n        cfg: FUS configuration settings. Defaults to DEFAULT_CONFIG.\n        session: Optional requests.Session for connection reuse.\n    \"\"\"\n\n    def __init__(self, cfg: FUSConfig = DEFAULT_CONFIG, session: Optional[requests.Session] = None):\n        self.cfg = cfg\n        self.sess = session or requests.Session()\n        self._auth = \"\"\n        self._sessid = \"\"\n        self._enc_nonce = \"\"\n        self.nonce = \"\"\n        # bootstrap: r\u00e9cup\u00e9rer un NONCE\n        self._makereq(\"NF_DownloadGenerateNonce.do\")\n\n    def _headers(self, with_server_nonce: bool = False) -&gt; dict:\n        \"\"\"\n        Build request headers including Authorization and User-Agent.\n\n        Args:\n            with_server_nonce: Whether to include encrypted NONCE in Authorization.\n\n        Returns:\n            dict: Headers dictionary for FUS requests.\n        \"\"\"\n        nonce = self._enc_nonce if with_server_nonce else \"\"\n        authv = (\n            f'FUS nonce=\"{nonce}\", signature=\"{self._auth}\", nc=\"\", type=\"\", realm=\"\", newauth=\"1\"'\n        )\n        return {\"Authorization\": authv, \"User-Agent\": self.cfg.user_agent}\n\n    def _makereq(self, path: str, data: bytes | str = b\"\") -&gt; str:\n        \"\"\"\n        Make an authenticated request to FUS server with NONCE rotation.\n\n        Args:\n            path: API endpoint path.\n            data: Request payload (XML or bytes).\n\n        Returns:\n            str: Response text from server.\n\n        Raises:\n            requests.exceptions.HTTPError: On non-200 response.\n        \"\"\"\n        url = f\"{self.cfg.base_url}/{path}\"\n        r = self.sess.post(\n            url,\n            data=data,\n            headers=self._headers(),\n            timeout=self.cfg.request_timeout,\n            cookies={\"JSESSIONID\": self._sessid},\n        )\n        # rotation de nonce + signature\n        if \"NONCE\" in r.headers:\n            self._enc_nonce = r.headers[\"NONCE\"]\n            self.nonce = decrypt_nonce(self._enc_nonce)\n            self._auth = make_signature(self.nonce)\n        if \"JSESSIONID\" in r.cookies:\n            self._sessid = r.cookies[\"JSESSIONID\"]\n        r.raise_for_status()\n        return r.text\n\n    def inform(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Send inform request to get firmware information.\n\n        Args:\n            payload: XML payload containing device and firmware details.\n\n        Returns:\n            ET.Element: Parsed XML response containing firmware metadata.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n        return ET.fromstring(xml)\n\n    def init(self, payload: bytes) -&gt; ET.Element:\n        \"\"\"\n        Initialize binary download session.\n\n        Args:\n            payload: XML payload with download request details.\n\n        Returns:\n            ET.Element: Parsed XML response with download authorization.\n\n        Raises:\n            requests.exceptions.HTTPError: On server error.\n        \"\"\"\n        xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n        return ET.fromstring(xml)\n\n    def stream(self, filename: str, start: int = 0) -&gt; requests.Response:\n        \"\"\"\n        Stream firmware download from cloud server.\n\n        Args:\n            filename: Remote firmware file path.\n            start: Byte offset for resume capability.\n\n        Returns:\n            requests.Response: Streaming response object.\n\n        Raises:\n            DownloadError: On download initialization failure.\n        \"\"\"\n        # cloud download (transmits client-side encrypted NONCE)\n        url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n        headers = self._headers(with_server_nonce=True)\n        if start &gt; 0:\n            headers[\"Range\"] = f\"bytes={start}-\"\n        r = self.sess.get(\n            url,\n            params=\"file=\" + filename,\n            headers=headers,\n            stream=True,\n            timeout=self.cfg.request_timeout,\n        )\n        if not r.ok:\n            raise DownloadError(f\"HTTP {r.status_code} on download\")\n        return r\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.inform","title":"inform","text":"Python<pre><code>inform(payload)\n</code></pre> <p>Send inform request to get firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload containing device and firmware details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response containing firmware metadata.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus/client.py</code> Python<pre><code>def inform(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Send inform request to get firmware information.\n\n    Args:\n        payload: XML payload containing device and firmware details.\n\n    Returns:\n        ET.Element: Parsed XML response containing firmware metadata.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInform.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.init","title":"init","text":"Python<pre><code>init(payload)\n</code></pre> <p>Initialize binary download session.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>XML payload with download request details.</p> required <p>Returns:</p> Type Description <code>Element</code> <p>ET.Element: Parsed XML response with download authorization.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>On server error.</p> Source code in <code>fus/client.py</code> Python<pre><code>def init(self, payload: bytes) -&gt; ET.Element:\n    \"\"\"\n    Initialize binary download session.\n\n    Args:\n        payload: XML payload with download request details.\n\n    Returns:\n        ET.Element: Parsed XML response with download authorization.\n\n    Raises:\n        requests.exceptions.HTTPError: On server error.\n    \"\"\"\n    xml = self._makereq(\"NF_DownloadBinaryInitForMass.do\", payload)\n    return ET.fromstring(xml)\n</code></pre>"},{"location":"api/fus.client/#fus.client.FUSClient.stream","title":"stream","text":"Python<pre><code>stream(filename, start=0)\n</code></pre> <p>Stream firmware download from cloud server.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Remote firmware file path.</p> required <code>start</code> <code>int</code> <p>Byte offset for resume capability.</p> <code>0</code> <p>Returns:</p> Type Description <code>Response</code> <p>requests.Response: Streaming response object.</p> <p>Raises:</p> Type Description <code>DownloadError</code> <p>On download initialization failure.</p> Source code in <code>fus/client.py</code> Python<pre><code>def stream(self, filename: str, start: int = 0) -&gt; requests.Response:\n    \"\"\"\n    Stream firmware download from cloud server.\n\n    Args:\n        filename: Remote firmware file path.\n        start: Byte offset for resume capability.\n\n    Returns:\n        requests.Response: Streaming response object.\n\n    Raises:\n        DownloadError: On download initialization failure.\n    \"\"\"\n    # cloud download (transmits client-side encrypted NONCE)\n    url = f\"{self.cfg.cloud_url}/NF_DownloadBinaryForMass.do\"\n    headers = self._headers(with_server_nonce=True)\n    if start &gt; 0:\n        headers[\"Range\"] = f\"bytes={start}-\"\n    r = self.sess.get(\n        url,\n        params=\"file=\" + filename,\n        headers=headers,\n        stream=True,\n        timeout=self.cfg.request_timeout,\n    )\n    if not r.ok:\n        raise DownloadError(f\"HTTP {r.status_code} on download\")\n    return r\n</code></pre>"},{"location":"api/fus.config/","title":"Package API <code>fus.config</code>","text":""},{"location":"api/fus.config/#fus.config","title":"fus.config","text":"<p>FUS configuration helpers.</p> <p>This module defines the FUSConfig dataclass which centralizes default endpoints and HTTP settings used by the FUS client.</p>"},{"location":"api/fus.config/#fus.config.FUSConfig","title":"FUSConfig  <code>dataclass</code>","text":"<p>Configuration for the Firmware Update Service (FUS) client.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for FUS control endpoints. Some clients/tools may use a different host.</p> <code>'https://neofussvr.sslcs.cdngc.net'</code> <code>cloud_url</code> <code>str</code> <p>Primary cloud URL used for firmware downloads.</p> <code>'http://cloud-neofussvr.samsungmobile.com'</code> <code>old_cloud_url</code> <code>str</code> <p>Legacy cloud URL kept for compatibility.</p> <code>'http://cloud-fussvr.sslcs.cdngc.net'</code> <code>user_agent</code> <code>str</code> <p>User-Agent header used for HTTP requests.</p> <code>'Kies2.0_FUS'</code> <code>request_timeout</code> <code>int</code> <p>Default timeout in seconds for HTTP requests.</p> <code>60</code> Source code in <code>fus/config.py</code> Python<pre><code>@dataclass(frozen=True)\nclass FUSConfig:\n    \"\"\"\n    Configuration for the Firmware Update Service (FUS) client.\n\n    Args:\n        base_url: Base URL for FUS control endpoints. Some clients/tools may use a different host.\n        cloud_url: Primary cloud URL used for firmware downloads.\n        old_cloud_url: Legacy cloud URL kept for compatibility.\n        user_agent: User-Agent header used for HTTP requests.\n        request_timeout: Default timeout in seconds for HTTP requests.\n    \"\"\"\n\n    # Endpoints (some clients/tools may use a different cloud host)\n    base_url: str = \"https://neofussvr.sslcs.cdngc.net\"\n    cloud_url: str = \"http://cloud-neofussvr.samsungmobile.com\"\n    old_cloud_url: str = \"http://cloud-fussvr.sslcs.cdngc.net\"\n    # Default User-Agent and timeout for HTTP requests\n    user_agent: str = \"Kies2.0_FUS\"\n    request_timeout: int = 60  # seconds\n</code></pre>"},{"location":"api/fus.crypto/","title":"Package API <code>fus.crypto</code>","text":""},{"location":"api/fus.crypto/#fus.crypto","title":"fus.crypto","text":"<p>FUS crypto helpers: AES CBC utilities, padding, key derivation and logic checks.</p> <p>Provides small helpers used by the FUS client and decryption routines.</p>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_pad","title":"pkcs_pad","text":"Python<pre><code>pkcs_pad(data)\n</code></pre> <p>Apply PKCS#7 padding to reach a 16-byte boundary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw bytes to pad.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Padded bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def pkcs_pad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Apply PKCS#7 padding to reach a 16-byte boundary.\n\n    Args:\n        data: Raw bytes to pad.\n\n    Returns:\n        Padded bytes.\n    \"\"\"\n    pad_len = 16 - (len(data) % 16)\n    return data + bytes([pad_len]) * pad_len\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.pkcs_unpad","title":"pkcs_unpad","text":"Python<pre><code>pkcs_unpad(data)\n</code></pre> <p>Remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Padded bytes.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Original unpadded bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def pkcs_unpad(data: bytes) -&gt; bytes:\n    \"\"\"\n    Remove PKCS#7 padding.\n\n    Args:\n        data: Padded bytes.\n\n    Returns:\n        Original unpadded bytes.\n    \"\"\"\n    return data[: -data[-1]]\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_encrypt","title":"aes_cbc_encrypt","text":"Python<pre><code>aes_cbc_encrypt(inp, key)\n</code></pre> <p>Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Plaintext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key (16/24/32 bytes).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Ciphertext bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def aes_cbc_encrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypt data using AES-CBC with IV equal to the first 16 bytes of the key.\n\n    Args:\n        inp: Plaintext bytes.\n        key: AES key (16/24/32 bytes).\n\n    Returns:\n        Ciphertext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return cipher.encrypt(pkcs_pad(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.aes_cbc_decrypt","title":"aes_cbc_decrypt","text":"Python<pre><code>aes_cbc_decrypt(inp, key)\n</code></pre> <p>Decrypt AES-CBC ciphertext and remove PKCS#7 padding.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>Ciphertext bytes.</p> required <code>key</code> <code>bytes</code> <p>AES key used to encrypt.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Plaintext bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def aes_cbc_decrypt(inp: bytes, key: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt AES-CBC ciphertext and remove PKCS#7 padding.\n\n    Args:\n        inp: Ciphertext bytes.\n        key: AES key used to encrypt.\n\n    Returns:\n        Plaintext bytes.\n    \"\"\"\n    iv = key[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return pkcs_unpad(cipher.decrypt(inp))\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.derive_key","title":"derive_key","text":"Python<pre><code>derive_key(nonce)\n</code></pre> <p>Build a key from a 16-character server nonce.</p> <p>The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars, concatenated with KEY_2, returned as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>16-character nonce string.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Derived key bytes.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def derive_key(nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a key from a 16-character server nonce.\n\n    The resulting key is KEY_1[ord(nonce[i])%16] repeated for 16 chars,\n    concatenated with KEY_2, returned as bytes.\n\n    Args:\n        nonce: 16-character nonce string.\n\n    Returns:\n        Derived key bytes.\n    \"\"\"\n    k = \"\".join(KEY_1[ord(nonce[i]) % 16] for i in range(16))\n    k += KEY_2\n    return k.encode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.make_signature","title":"make_signature","text":"Python<pre><code>make_signature(nonce)\n</code></pre> <p>Compute the base64-encoded signature for a nonce.</p> <p>The signature is base64(AES-CBC(nonce, derive_key(nonce))).</p> <p>Parameters:</p> Name Type Description Default <code>nonce</code> <code>str</code> <p>Plaintext nonce.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base64-encoded signature string.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def make_signature(nonce: str) -&gt; str:\n    \"\"\"\n    Compute the base64-encoded signature for a nonce.\n\n    The signature is base64(AES-CBC(nonce, derive_key(nonce))).\n\n    Args:\n        nonce: Plaintext nonce.\n\n    Returns:\n        Base64-encoded signature string.\n    \"\"\"\n    raw = aes_cbc_encrypt(nonce.encode(), derive_key(nonce))\n    return base64.b64encode(raw).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.decrypt_nonce","title":"decrypt_nonce","text":"Python<pre><code>decrypt_nonce(enc_nonce)\n</code></pre> <p>Decrypt a server NONCE header.</p> <p>Parameters:</p> Name Type Description Default <code>enc_nonce</code> <code>str</code> <p>Base64-encoded ciphertext from server.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Decrypted plaintext nonce.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates base64 and AES decode errors if input is malformed.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def decrypt_nonce(enc_nonce: str) -&gt; str:\n    \"\"\"\n    Decrypt a server NONCE header.\n\n    Args:\n        enc_nonce: Base64-encoded ciphertext from server.\n\n    Returns:\n        Decrypted plaintext nonce.\n\n    Raises:\n        Exception: Propagates base64 and AES decode errors if input is malformed.\n    \"\"\"\n    data = base64.b64decode(enc_nonce)\n    return aes_cbc_decrypt(data, KEY_1.encode()).decode()\n</code></pre>"},{"location":"api/fus.crypto/#fus.crypto.logic_check","title":"logic_check","text":"Python<pre><code>logic_check(inp, nonce)\n</code></pre> <p>Compute the FUS logic-check value.</p> <p>Picks characters from <code>inp</code> using the low 4 bits of each character in <code>nonce</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Input string (must be at least 16 characters).</p> required <code>nonce</code> <code>str</code> <p>Server nonce string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Computed logic-check string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>inp</code> is shorter than 16 characters.</p> Source code in <code>fus/crypto.py</code> Python<pre><code>def logic_check(inp: str, nonce: str) -&gt; str:\n    \"\"\"\n    Compute the FUS logic-check value.\n\n    Picks characters from `inp` using the low 4 bits of each character in `nonce`.\n\n    Args:\n        inp: Input string (must be at least 16 characters).\n        nonce: Server nonce string.\n\n    Returns:\n        Computed logic-check string.\n\n    Raises:\n        ValueError: If `inp` is shorter than 16 characters.\n    \"\"\"\n    if len(inp) &lt; 16:\n        raise ValueError(\"logic_check input too short\")\n    return \"\".join(inp[ord(c) &amp; 0xF] for c in nonce)\n</code></pre>"},{"location":"api/fus.csclist/","title":"Package API <code>fus.csclist</code>","text":""},{"location":"api/fus.csclist/#fus.csclist","title":"fus.csclist","text":"<p>CSC mapping for Samsung firmware regions.</p> <p>This module provides CSC_DICT, a dictionary that maps 3-letter Samsung CSC codes to their corresponding country or region names. It is used by the CLI and GUI components to display or validate CSC/region information.</p> <p>Attributes:</p> Name Type Description <code>CSC_DICT</code> <code>dict</code> <p>Mapping of 3-letter CSC codes to region/country names.</p>"},{"location":"api/fus.decrypt/","title":"Package API <code>fus.decrypt</code>","text":""},{"location":"api/fus.decrypt/#fus.decrypt","title":"fus.decrypt","text":"<p>FUS decryption helpers.</p> <p>Provides functions to derive ENC2/ENC4 keys and to decrypt streaming firmware blobs.</p> <p>Functions: - get_v2_key: derive MD5-based ENC2 key. - get_v4_key: retrieve logic value via FUS inform and derive ENC4 key. - decrypt_file: decrypt a file encrypting in 16-byte AES blocks.</p>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v2_key","title":"get_v2_key","text":"Python<pre><code>get_v2_key(version, model, region, _device_id)\n</code></pre> <p>Derive ENC2 key (V2) using MD5.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>_device_id</code> <code>str</code> <p>Unused for V2 (kept for API parity).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>MD5 digest bytes of the string \"region:model:version\".</p> Source code in <code>fus/decrypt.py</code> Python<pre><code>def get_v2_key(version: str, model: str, region: str, _device_id: str) -&gt; bytes:\n    \"\"\"\n    Derive ENC2 key (V2) using MD5.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        _device_id: Unused for V2 (kept for API parity).\n\n    Returns:\n        MD5 digest bytes of the string \"region:model:version\".\n    \"\"\"\n    deckey = f\"{region}:{model}:{version}\"\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.get_v4_key","title":"get_v4_key","text":"Python<pre><code>get_v4_key(version, model, region, device_id, client=None)\n</code></pre> <p>Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version string.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>Region/CSC code.</p> required <code>device_id</code> <code>str</code> <p>IMEI or Serial required by Samsung for ENC4.</p> required <code>client</code> <code>FUSClient | None</code> <p>Optional FUSClient instance to use (a new one is created if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>MD5 digest bytes derived from the logic-check value, or None on failure.</p> <p>Raises:</p> Type Description <code>DecryptError</code> <p>If device_id is not provided.</p> <code>InformError</code> <p>If the inform response lacks expected fields.</p> Source code in <code>fus/decrypt.py</code> Python<pre><code>def get_v4_key(\n    version: str, model: str, region: str, device_id: str, client: FUSClient | None = None\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Derive ENC4 key (V4) by calling FUS inform to obtain the logic value.\n\n    Args:\n        version: Firmware version string.\n        model: Device model identifier.\n        region: Region/CSC code.\n        device_id: IMEI or Serial required by Samsung for ENC4.\n        client: Optional FUSClient instance to use (a new one is created if None).\n\n    Returns:\n        MD5 digest bytes derived from the logic-check value, or None on failure.\n\n    Raises:\n        DecryptError: If device_id is not provided.\n        InformError: If the inform response lacks expected fields.\n    \"\"\"\n    if not device_id:\n        raise DecryptError(\n            \"Device ID (IMEI or Serial) required for ENC4 key (Samsung requirement).\"\n        )\n    client = client or FUSClient()\n    ver = normalize_vercode(version)\n    resp = client.inform(build_binary_inform(ver, model, region, device_id, client.nonce))\n    try:\n        fwver = resp.find(\"./FUSBody/Results/LATEST_FW_VERSION/Data\").text  # type: ignore\n        logicval = resp.find(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\").text  # type: ignore\n    except Exception as exc:\n        raise InformError(\"Could not obtain decryption key; check model/region/device_id.\") from exc\n    deckey = logic_check(fwver, logicval)  # type: ignore\n    return hashlib.md5(deckey.encode()).digest()\n</code></pre>"},{"location":"api/fus.decrypt/#fus.decrypt.decrypt_file","title":"decrypt_file","text":"Python<pre><code>decrypt_file(\n    enc_path, out_path, *, enc_ver, key, progress_cb=None\n)\n</code></pre> <p>Decrypt an encrypted firmware file to disk.</p> <p>Parameters:</p> Name Type Description Default <code>enc_path</code> <code>str</code> <p>Path to the encrypted input file.</p> required <code>out_path</code> <code>str</code> <p>Path to write the decrypted output file.</p> required <code>enc_ver</code> <code>int</code> <p>Encryption version (unused by this function but kept for API parity).</p> required <code>key</code> <code>bytes</code> <p>AES key used for decryption.</p> required <code>progress_cb</code> <code>Optional[Callable[[int, int], None]]</code> <p>Optional progress callback(progress_bytes, total_bytes).</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>fus/decrypt.py</code> Python<pre><code>def decrypt_file(\n    enc_path: str,\n    out_path: str,\n    *,\n    enc_ver: int,\n    key: bytes,\n    progress_cb: Optional[Callable[[int, int], None]] = None,\n) -&gt; None:\n    \"\"\"\n    Decrypt an encrypted firmware file to disk.\n\n    Args:\n        enc_path: Path to the encrypted input file.\n        out_path: Path to write the decrypted output file.\n        enc_ver: Encryption version (unused by this function but kept for API parity).\n        key: AES key used for decryption.\n        progress_cb: Optional progress callback(progress_bytes, total_bytes).\n\n    Returns:\n        None\n    \"\"\"\n    size = os.stat(enc_path).st_size\n    with open(enc_path, \"rb\") as fin, open(out_path, \"wb\") as fout:\n        _decrypt_progress(fin, fout, key, size, progress_cb=progress_cb)\n</code></pre>"},{"location":"api/fus.deviceid/","title":"Package API <code>fus.deviceid</code>","text":""},{"location":"api/fus.deviceid/#fus.deviceid","title":"fus.deviceid","text":"<p>Device identifier helpers for FUS interactions.</p> <p>Provides IMEI Luhn checksum computation, TAC-based IMEI autofill, and validation helpers for serial numbers and IMEIs.</p> <p>Functions: - luhn_checksum: compute Luhn check digit for a 14-digit IMEI core. - autofill_imei: complete a TAC to a full 15-digit IMEI (random fill + Luhn). - validate_serial: basic alphanumeric serial validation. - validate_imei: full 15-digit IMEI validation using Luhn. - is_device_id_required: policy for when a device id is required by commands.</p>"},{"location":"api/fus.deviceid/#fus.deviceid.luhn_checksum","title":"luhn_checksum","text":"Python<pre><code>luhn_checksum(imei_without_cd)\n</code></pre> <p>Compute the Luhn check digit for the provided IMEI core.</p> <p>Parameters:</p> Name Type Description Default <code>imei_without_cd</code> <code>str</code> <p>IMEI digits excluding the check digit (typically 14 digits).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The single-digit Luhn checksum as an int.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def luhn_checksum(imei_without_cd: str) -&gt; int:\n    \"\"\"\n    Compute the Luhn check digit for the provided IMEI core.\n\n    Args:\n        imei_without_cd: IMEI digits excluding the check digit (typically 14 digits).\n\n    Returns:\n        The single-digit Luhn checksum as an int.\n    \"\"\"\n    s, tmp = 0, imei_without_cd + \"0\"\n    parity = len(tmp) % 2\n    for idx, ch in enumerate(tmp):\n        d = int(ch)\n        if idx % 2 == parity:\n            d *= 2\n            if d &gt; 9:\n                d -= 9\n        s += d\n    return (10 - (s % 10)) % 10\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.autofill_imei","title":"autofill_imei","text":"Python<pre><code>autofill_imei(tac)\n</code></pre> <p>Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.</p> <p>Parameters:</p> Name Type Description Default <code>tac</code> <code>str</code> <p>TAC prefix (must be numeric and at least 8 digits).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A 15-digit IMEI string.</p> <p>Raises:</p> Type Description <code>DeviceIdError</code> <p>If TAC is not numeric or shorter than 8 digits.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def autofill_imei(tac: str) -&gt; str:\n    \"\"\"\n    Build a full 15-digit IMEI from a TAC by filling missing digits and appending Luhn.\n\n    Args:\n        tac: TAC prefix (must be numeric and at least 8 digits).\n\n    Returns:\n        A 15-digit IMEI string.\n\n    Raises:\n        DeviceIdError: If TAC is not numeric or shorter than 8 digits.\n    \"\"\"\n    if not tac.isdecimal() or len(tac) &lt; 8:\n        raise DeviceIdError(\"TAC must have at least 8 digits\")\n    if len(tac) &gt;= 15:\n        return tac[:15]\n    missing = 14 - len(tac)\n    rnd = f\"{random.randint(0, 10**missing - 1):0{missing}d}\"\n    core = tac + rnd\n    return core + str(luhn_checksum(core))\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_serial","title":"validate_serial","text":"Python<pre><code>validate_serial(serial)\n</code></pre> <p>Validate a device serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str</code> <p>Serial string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if serial is non-empty, alphanumeric and length between 1 and 35.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def validate_serial(serial: str) -&gt; bool:\n    \"\"\"\n    Validate a device serial number.\n\n    Args:\n        serial: Serial string to validate.\n\n    Returns:\n        True if serial is non-empty, alphanumeric and length between 1 and 35.\n    \"\"\"\n    return bool(serial) and (1 &lt;= len(serial) &lt;= 35) and serial.isalnum()\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.validate_imei","title":"validate_imei","text":"Python<pre><code>validate_imei(imei)\n</code></pre> <p>Validate a full 15-digit IMEI using the Luhn checksum.</p> <p>Parameters:</p> Name Type Description Default <code>imei</code> <code>str</code> <p>IMEI string to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def validate_imei(imei: str) -&gt; bool:\n    \"\"\"\n    Validate a full 15-digit IMEI using the Luhn checksum.\n\n    Args:\n        imei: IMEI string to validate.\n\n    Returns:\n        True if IMEI is numeric, exactly 15 digits, and has a correct Luhn check digit.\n    \"\"\"\n    if not imei or not imei.isdecimal():\n        return False\n    if len(imei) != 15:\n        return False\n    try:\n        check_digit = int(imei[14])\n    except ValueError:\n        return False\n    return luhn_checksum(imei[:14]) == check_digit\n</code></pre>"},{"location":"api/fus.deviceid/#fus.deviceid.is_device_id_required","title":"is_device_id_required","text":"Python<pre><code>is_device_id_required(command, enc_ver)\n</code></pre> <p>Policy deciding whether a device id is required for an operation.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name (e.g. \"download\", \"decrypt\").</p> required <code>enc_ver</code> <code>int | None</code> <p>Encryption version (None if unknown).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the command requires a device id (download always, decrypt only for ENC4).</p> Source code in <code>fus/deviceid.py</code> Python<pre><code>def is_device_id_required(command: str, enc_ver: int | None) -&gt; bool:\n    \"\"\"\n    Policy deciding whether a device id is required for an operation.\n\n    Args:\n        command: Command name (e.g. \"download\", \"decrypt\").\n        enc_ver: Encryption version (None if unknown).\n\n    Returns:\n        True if the command requires a device id (download always, decrypt only for ENC4).\n    \"\"\"\n    return command == \"download\" or (command == \"decrypt\" and enc_ver == 4)\n</code></pre>"},{"location":"api/fus.errors/","title":"Package API <code>fus.errors</code>","text":""},{"location":"api/fus.errors/#fus.errors","title":"fus.errors","text":"<p>FUS package error definitions.</p> <p>This module defines custom exceptions used across the FUS package. In particular, DeviceIdError is raised by the device identifier utilities (e.g. IMEI/TAC validation and autofill) when provided input is invalid.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>Base class for FUS-related errors.</p> <code>AuthError</code> <p>Raised for authentication failures in FUS operations.</p> <code>InformError</code> <p>Raised for protocol or information errors in FUS communication.</p> <code>DownloadError</code> <p>Raised when a firmware download fails or is incomplete.</p> <code>DecryptError</code> <p>Raised when firmware decryption fails.</p> <code>DeviceIdError</code> <p>Raised by fus.deviceid helpers on invalid TAC/IMEI/serial input.</p>"},{"location":"api/fus.firmware/","title":"Package API <code>fus.firmware</code>","text":""},{"location":"api/fus.firmware/#fus.firmware","title":"fus.firmware","text":"<p>Firmware parsing and FOTA helpers for Samsung FUS.</p> <p>Provides utilities to normalize firmware version codes, parse PDA strings into meaningful fields (bootloader type, year, month, iteration), format human-readable info and fetch the latest firmware version from the FOTA endpoint.</p> <p>Functions: - normalize_vercode: Normalize a version code to a 4-part representation. - _read_firmware: Extract structured fields from a PDA/firmware string. - read_firmware_info: Return parsed firmware fields as a dictionary. - format_firmware_info: Produce a human-readable summary. - get_latest_version: Query the FOTA service for the latest version.</p>"},{"location":"api/fus.firmware/#fus.firmware.normalize_vercode","title":"normalize_vercode","text":"Python<pre><code>normalize_vercode(vercode)\n</code></pre> <p>Normalize a 3- or 4-part firmware version code to exactly 4 parts.</p> <p>Parameters:</p> Name Type Description Default <code>vercode</code> <code>str</code> <p>Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A normalized 4-part version string separated by '/'.</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def normalize_vercode(vercode: str) -&gt; str:\n    \"\"\"\n    Normalize a 3- or 4-part firmware version code to exactly 4 parts.\n\n    Args:\n        vercode: Firmware version string, e.g. \"G900FXXU1ANE2\" or \"G900F/XXU/1ANE/2\".\n\n    Returns:\n        A normalized 4-part version string separated by '/'.\n    \"\"\"\n    parts = vercode.split(\"/\")\n    if len(parts) == 3:\n        parts.append(parts[0])\n    if parts[2] == \"\":\n        parts[2] = parts[0]\n    return \"/\".join(parts)\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.read_firmware_info","title":"read_firmware_info","text":"Python<pre><code>read_firmware_info(firmware)\n</code></pre> <p>Return parsed firmware information as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: - \"bl\": bootloader type or None - \"date\": formatted \"YYYY.MM\" string - \"it\": iteration string \"major.minor\"</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def read_firmware_info(firmware: str) -&gt; dict:\n    \"\"\"\n    Return parsed firmware information as a dictionary.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        Dictionary with keys:\n            - \"bl\": bootloader type or None\n            - \"date\": formatted \"YYYY.MM\" string\n            - \"it\": iteration string \"major.minor\"\n    \"\"\"\n    ff = _read_firmware(firmware)\n    return {\"bl\": ff[0], \"date\": f\"{ff[2]}.{ff[3]+1:02d}\", \"it\": f\"{ff[1]}.{ff[4]}\"}\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.format_firmware_info","title":"format_firmware_info","text":"Python<pre><code>format_firmware_info(firmware)\n</code></pre> <p>Produce a human-readable summary of firmware information.</p> <p>Parameters:</p> Name Type Description Default <code>firmware</code> <code>str</code> <p>Samsung firmware version or PDA string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A multi-line string with normalized firmware, bootloader (if any),</p> <code>str</code> <p>date (YYYY.MM) and version iteration. If parsing fails, returns an</p> <code>str</code> <p>explanatory message containing the original input.</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def format_firmware_info(firmware: str) -&gt; str:\n    \"\"\"\n    Produce a human-readable summary of firmware information.\n\n    Args:\n        firmware: Samsung firmware version or PDA string.\n\n    Returns:\n        A multi-line string with normalized firmware, bootloader (if any),\n        date (YYYY.MM) and version iteration. If parsing fails, returns an\n        explanatory message containing the original input.\n    \"\"\"\n    try:\n        info = read_firmware_info(firmware)\n        norm_fw = normalize_vercode(firmware)\n\n        result = f\"Firmware: {norm_fw}\\n\"\n        if info[\"bl\"]:\n            result += f\"Bootloader type: {info['bl']}\\n\"\n        result += f\"Date: {info['date']} (YYYY.MM)\\n\"\n        result += f\"Version iteration: {info['it']}\"\n\n        return result\n    except ValueError:\n        return f\"Could not parse firmware string: {firmware}\"\n</code></pre>"},{"location":"api/fus.firmware/#fus.firmware.get_latest_version","title":"get_latest_version","text":"Python<pre><code>get_latest_version(model, region)\n</code></pre> <p>Query the FOTA endpoint and return the latest firmware version code.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Device model identifier (e.g. \"SM-G900F\").</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized version code string.</p> <p>Raises:</p> Type Description <code>FUSError</code> <p>If the endpoint returns 403 or other domain-specific errors.</p> <code>HTTPError</code> <p>For other non-success HTTP responses.</p> Source code in <code>fus/firmware.py</code> Python<pre><code>def get_latest_version(model: str, region: str) -&gt; str:\n    \"\"\"\n    Query the FOTA endpoint and return the latest firmware version code.\n\n    Args:\n        model: Device model identifier (e.g. \"SM-G900F\").\n        region: CSC/region code.\n\n    Returns:\n        Normalized version code string.\n\n    Raises:\n        FUSError: If the endpoint returns 403 or other domain-specific errors.\n        requests.exceptions.HTTPError: For other non-success HTTP responses.\n    \"\"\"\n    # Use the request_timeout from DEFAULT_CONFIG (FUSConfig), fallback to 30 if not present.\n    if hasattr(DEFAULT_CONFIG, \"request_timeout\"):\n        timeout = DEFAULT_CONFIG.request_timeout\n    else:\n        timeout = 30\n    req = requests.get(\n        \"https://fota-cloud-dn.ospserver.net/firmware/\" + region + \"/\" + model + \"/version.xml\",\n        headers={'User-Agent': 'curl/7.87.0'},\n        timeout=timeout,\n    )\n    if req.status_code == 403:\n        raise FUSError(\"Model or region not found (403)\")\n    req.raise_for_status()\n    root = ET.fromstring(req.text)\n    latest = root.find(\"./firmware/version/latest\").text  # type: ignore\n    if latest is None:\n        raise FUSError(\"No latest firmware available\")\n    return normalize_vercode(latest)\n</code></pre>"},{"location":"api/fus.messages/","title":"Package API <code>fus.messages</code>","text":""},{"location":"api/fus.messages/#fus.messages","title":"fus.messages","text":"<p>FUS XML message builders.</p> <p>Provides helpers to construct XML payloads used by the FUS protocol (inform/init). These builders return raw XML bytes ready to be posted to the FUS endpoints.</p>"},{"location":"api/fus.messages/#fus.messages.build_binary_inform","title":"build_binary_inform","text":"Python<pre><code>build_binary_inform(fwv, model, region, device_id, nonce)\n</code></pre> <p>Build a BinaryInform request payload.</p> <p>Parameters:</p> Name Type Description Default <code>fwv</code> <code>str</code> <p>Firmware version code.</p> required <code>model</code> <code>str</code> <p>Device model identifier.</p> required <code>region</code> <code>str</code> <p>CSC/region code.</p> required <code>device_id</code> <code>str</code> <p>Device IMEI or Serial number.</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus/messages.py</code> Python<pre><code>def build_binary_inform(fwv: str, model: str, region: str, device_id: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInform request payload.\n\n    Args:\n        fwv: Firmware version code.\n        model: Device model identifier.\n        region: CSC/region code.\n        device_id: Device IMEI or Serial number.\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    params = {\n        \"ACCESS_MODE\": 2,\n        \"BINARY_NATURE\": 1,\n        \"CLIENT_PRODUCT\": \"Smart Switch\",\n        \"CLIENT_VERSION\": \"4.3.23123_1\",\n        \"DEVICE_IMEI_PUSH\": device_id,\n        \"DEVICE_FW_VERSION\": fwv,\n        \"DEVICE_LOCAL_CODE\": region,\n        \"DEVICE_MODEL_NAME\": model,\n        \"LOGIC_CHECK\": logic_check(fwv, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.messages/#fus.messages.build_binary_init","title":"build_binary_init","text":"Python<pre><code>build_binary_init(filename, nonce)\n</code></pre> <p>Build a BinaryInitForMass request payload.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Firmware file name (including extension).</p> required <code>nonce</code> <code>str</code> <p>Current FUS nonce.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Raw XML payload as bytes.</p> Source code in <code>fus/messages.py</code> Python<pre><code>def build_binary_init(filename: str, nonce: str) -&gt; bytes:\n    \"\"\"\n    Build a BinaryInitForMass request payload.\n\n    Args:\n        filename: Firmware file name (including extension).\n        nonce: Current FUS nonce.\n\n    Returns:\n        Raw XML payload as bytes.\n    \"\"\"\n    m = ET.Element(\"FUSroot\")\n    _hdr(m)\n    checkinp = filename.split(\".\")[0][-16:]\n    params = {\n        \"BINARY_FILE_NAME\": filename,\n        \"LOGIC_CHECK\": logic_check(checkinp, nonce),\n    }\n    _body_put(m, params)\n    return ET.tostring(m)\n</code></pre>"},{"location":"api/fus.responses/","title":"Package API <code>fus.responses</code>","text":""},{"location":"api/fus.responses/#fus.responses","title":"fus.responses","text":"<p>FUS inform response parsing helpers.</p> <p>Provides a small dataclass and utilities to extract firmware-related metadata (filename, path, size) and server-provided values from a FUS BinaryInform XML response.</p> <p>Functions: - get_info_from_inform: extract server path, filename and size from an inform response. - parse_inform: build an InformInfo instance combining results and logic values.</p>"},{"location":"api/fus.responses/#fus.responses.get_info_from_inform","title":"get_info_from_inform","text":"Python<pre><code>get_info_from_inform(root)\n</code></pre> <p>Extract download metadata from a BinaryInform XML response.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>Parsed XML root element of the BinaryInform response.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str, int]</code> <p>A tuple (filename, path, size_bytes).</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If the inform response status is not 200.</p> <code>AttributeError</code> <p>If expected XML elements are missing or malformed.</p> Source code in <code>fus/responses.py</code> Python<pre><code>def get_info_from_inform(root: ET.Element) -&gt; Tuple[str, str, int]:\n    \"\"\"\n    Extract download metadata from a BinaryInform XML response.\n\n    Args:\n        root: Parsed XML root element of the BinaryInform response.\n\n    Returns:\n        A tuple (filename, path, size_bytes).\n\n    Raises:\n        InformError: If the inform response status is not 200.\n        AttributeError: If expected XML elements are missing or malformed.\n    \"\"\"\n    status = int(root.find(\"./FUSBody/Results/Status\").text)  # type: ignore\n    if status != 200:\n        raise InformError(f\"DownloadBinaryInform returned {status}\")\n    filename = root.find(\"./FUSBody/Put/BINARY_NAME/Data\").text  # type: ignore\n    size = int(root.find(\"./FUSBody/Put/BINARY_BYTE_SIZE/Data\").text)  # type: ignore\n    path = root.find(\"./FUSBody/Put/MODEL_PATH/Data\").text  # type: ignore\n    return filename, path, size  # type: ignore\n</code></pre>"},{"location":"api/fus.responses/#fus.responses.parse_inform","title":"parse_inform","text":"Python<pre><code>parse_inform(root)\n</code></pre> <p>Parse a BinaryInform XML response into an InformInfo structure.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>Parsed XML root element of the BinaryInform response.</p> required <p>Returns:</p> Name Type Description <code>InformInfo</code> <code>InformInfo</code> <p>Dataclass containing latest firmware version, logic value,         filename, path and size in bytes.</p> <p>Raises:</p> Type Description <code>InformError</code> <p>If get_info_from_inform detects a non-200 status or other          inform-related errors occur.</p> Source code in <code>fus/responses.py</code> Python<pre><code>def parse_inform(root: ET.Element) -&gt; InformInfo:\n    \"\"\"\n    Parse a BinaryInform XML response into an InformInfo structure.\n\n    Args:\n        root: Parsed XML root element of the BinaryInform response.\n\n    Returns:\n        InformInfo: Dataclass containing latest firmware version, logic value,\n                    filename, path and size in bytes.\n\n    Raises:\n        InformError: If get_info_from_inform detects a non-200 status or other\n                     inform-related errors occur.\n    \"\"\"\n    latest = root.findtext(\"./FUSBody/Results/LATEST_FW_VERSION/Data\")\n    logic = root.findtext(\"./FUSBody/Put/LOGIC_VALUE_FACTORY/Data\")\n    filename, path, size = get_info_from_inform(root)\n    return InformInfo(\n        latest_fw_version=latest,\n        logic_value_factory=logic,\n        filename=filename,\n        path=path,\n        size_bytes=size,\n    )\n</code></pre>"},{"location":"database/schema/","title":"Database Schema","text":"<p>This document describes the database schema used by nanosamfw for tracking firmware downloads and IMEI operations.</p>"},{"location":"database/schema/#overview","title":"Overview","text":"<p>The application uses SQLite for local data persistence with two main tables:</p> <ul> <li>downloads - Tracks firmware download metadata and status</li> <li>imei_log - Logs IMEI-based firmware queries and upgrade operations</li> </ul>"},{"location":"database/schema/#tables","title":"Tables","text":""},{"location":"database/schema/#downloads","title":"downloads","text":"<p>Stores metadata about firmware downloads including model, CSC, version, and download status.</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>model</code> TEXT NOT NULL Device model identifier (e.g., SM-G998B) <code>csc</code> TEXT NOT NULL Country Specific Code <code>version_code</code> TEXT NOT NULL Firmware version identifier <code>encoded_filename</code> TEXT NOT NULL Encoded filename from FUS <code>size_bytes</code> INTEGER - File size in bytes <code>status</code> TEXT NOT NULL, DEFAULT 'done' Download status <code>path</code> TEXT - Local filesystem path to downloaded file <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of creation <code>updated_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of last update <p>Unique Constraint: <code>(model, csc, version_code)</code></p>"},{"location":"database/schema/#indexes","title":"Indexes","text":"<ul> <li><code>idx_downloads_model_csc</code> - Composite index on <code>(model, csc)</code> for efficient lookups</li> </ul>"},{"location":"database/schema/#triggers","title":"Triggers","text":"<ul> <li><code>trg_downloads_updated_at</code> - Automatically updates <code>updated_at</code> timestamp on row updates</li> </ul>"},{"location":"database/schema/#imei_log","title":"imei_log","text":"<p>Logs IMEI-based firmware query and upgrade operations with status tracking.</p> Column Type Constraints Description <code>id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier <code>imei</code> TEXT NOT NULL Device IMEI number <code>model</code> TEXT NOT NULL Device model identifier <code>csc</code> TEXT NOT NULL, CHECK length Country Specific Code (3-5 chars, supports multi-CSC like EUX/FTM) <code>version_code</code> TEXT NOT NULL, CHECK format Firmware version in AAA/BBB/CCC/DDD format <code>status_fus</code> TEXT NOT NULL, DEFAULT 'unknown' FUS query status (ok, error, denied, unauthorized, throttled, unknown) <code>status_upgrade</code> TEXT NOT NULL, DEFAULT 'unknown' Upgrade operation status (queued, in_progress, ok, failed, skipped, unknown) <code>created_at</code> TEXT NOT NULL, DEFAULT (now) ISO 8601 timestamp of log entry creation <code>upgrade_at</code> TEXT - ISO 8601 timestamp when upgrade operation occurred <p>Constraints:</p> <ul> <li><code>status_fus</code> must be one of: <code>ok</code>, <code>error</code>, <code>denied</code>, <code>unauthorized</code>, <code>throttled</code>, <code>unknown</code></li> <li><code>status_upgrade</code> must be one of: <code>queued</code>, <code>in_progress</code>, <code>ok</code>, <code>failed</code>, <code>skipped</code>, <code>unknown</code></li> <li><code>version_code</code> must contain exactly 3 forward slashes (AAA/BBB/CCC/DDD format)</li> <li><code>csc</code> length must be between 3 and 5 characters</li> </ul>"},{"location":"database/schema/#indexes_1","title":"Indexes","text":"<ul> <li><code>idx_imei_log__imei_created</code> - Composite index on <code>(imei, created_at DESC)</code> for IMEI history queries</li> <li><code>idx_imei_log__model_csc_created</code> - Composite index on <code>(model, csc, created_at DESC)</code> for device queries</li> <li><code>idx_imei_log__model_csc_version</code> - Composite index on <code>(model, csc, version_code)</code> for version lookups</li> <li><code>idx_imei_log__created_at</code> - Index on <code>created_at</code> for chronological queries</li> <li><code>idx_imei_log__upgrade_at</code> - Index on <code>upgrade_at</code> for upgrade operation queries</li> </ul>"},{"location":"database/schema/#sql-schema-files","title":"SQL Schema Files","text":"<p>The schema definitions are maintained in the following source files:</p> <ul> <li><code>download/sql/download.sql</code> - Downloads table schema</li> <li><code>download/sql/imei_log.sql</code> - IMEI log table schema</li> </ul>"},{"location":"database/schema/#usage","title":"Usage","text":"<p>The database is managed through the repository pattern:</p> <ul> <li>download.repository - Main download operations</li> <li>download.imei_repository - IMEI log operations</li> <li>download.db - Database connection management</li> </ul>"}]}